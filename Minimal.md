# Documentation Context

Generated on: 2025-11-28T17:26:24+05:30

## Repository Overview
- Total Files: 103
- Total Size: 1001908 bytes

## Directory Structure
```
0001-tailscale.com.md
1011-log-mesh-traffic.md
1013-sso-providers.md
1017-install.md
1019-subnets.md
1023-troubleshooting.md
1028-key-expiry.md
1054-dns.md
1059-ip-blocklist-relays.md
1068-tags.md
1077-secure-server-ubuntu.md
1080-cli.md
1081-magicdns.md
1084-sharing.md
1085-auth-keys.md
1088-run-unattended.md
1100-services.md
1101-api.md
1103-exit-nodes.md
1106-taildrop.md
1111-ephemeral-nodes.md
1114-pi-hole.md
1115-high-availability.md
1151-what-is-tailscale.md
1153-enabling-https.md
1155-terminology-and-concepts.md
1166-vscode-ipad.md
1167-release-stages.md
1168-versions.md
1192-acl-samples.md
1193-tailscale-ssh.md
1203-audit-logging.md
1212-shared-responsibility.md
1213-webhooks.md
1217-tailnet-name.md
1219-network-flow-logs.md
1222-invite-only-feature.md
1223-funnel.md
1224-contact-preferences.md
1226-tailnet-lock.md
1227-bug-report.md
1245-set-up-servers.md
1246-tailscale-ssh-session-recording.md
1250-support-options.md
1255-log-streaming.md
1259-domain-ownership.md
1277-key-prefixes.md
1292-pikvm.md
1293-cloud-init.md
1300-production-best-practices.md
1307-nas.md
1312-serve.md
1337-policy-syntax.md
1342-app-connectors-setup.md
1346-start.md
1347-installation.md
1348-guides.md
1349-log-events.md
1350-manage.md
1351-route.md
1352-servers.md
1353-share-web-server.md
1354-share.md
1355-solutions.md
1356-integrations.md
1357-cloud-server.md
1358-containers-and-virtualization.md
1359-database.md
1360-developer-tools.md
1361-firewall.md
1363-remote-code.md
1364-serverless.md
1365-webserver.md
1366-faq.md
1367-reference.md
1368-resources.md
1372-manage-devices.md
1373-manage-users.md
1375-pb-lp.md
1376-tech-overviews.md
1377-use-cases.md
1393-access-control.md
1415-quick-guides.md
1430-automations.md
1431-manage-account.md
1432-get-support.md
1443-just-in-time-access.md
1458-grant-examples.md
1469-unencrypted-macbooks-postgres.md
1482-client-metrics.md
1526-openvpn-migration-guide.md
1531-community-projects.md
1549-legacy-vpn-migration-guide.md
1552-tailscale-services.md
1554-messages.md
1586-secure-github-runners.md
1598-apple-tv-route-traffic.md
1599-rustdesk.md
1601-connect-mongodb-atlas.md
compare.md
kb.md
security.md
support.md

```

## File Contents


### File: 0001-tailscale.com.md

```markdown
# Your legacy VPNbelongs in the past

Fast, seamless device connectivity - no hardware, no firewall rules, no wasted time.

[Start connecting devices](https://login.tailscale.com/start) | [Contact sales](https://tailscale.com/contact/sales)

![masthead static](https://cdn.sanity.io/images/w77i7m8x/production/fab2bfd901de3d58f7f62d35fe9a5107fedc43c1-1360x725.svg?w=3840&q=75&fit=clip&auto=format)

## Trusted by 10,000+ companies

(Random Tailscale IPs)

100.78.14.63

100.108.47.7

100.81.144.123

100.101.33.15

## Tailscale makes secure networking easy

Achieve point-to-point network connectivity that enforces least privilege.

[How it works](https://tailscale.com/blog/how-tailscale-works)

## Deploy a zero-config, no-fuss VPN

Deploy a WireGuard®-based VPN that eliminates single points of failure.

[Business VPN](https://tailscale.com/use-cases/business-vpn)

![vpn](https://cdn.sanity.io/images/w77i7m8x/production/7d0130ecdd01b48ade3f864b8465d603b3f28c89-1280x584.svg?w=3840&q=75&fit=clip&auto=format)

## Securely access resources on any infrastructure

Granularly segment your network to ensure the right users get access to the right resources.

[Remote Access](https://tailscale.com/use-cases/remote-access)

![remote access](https://cdn.sanity.io/images/w77i7m8x/production/2aff9e711ae845bedfb1fc1db4bf12d01ffc219d-1280x584.svg?w=3840&q=75&fit=clip&auto=format)

## Unlock site-to-site networking

Connect clouds, VPCs, and on-premises networks without opening firewall ports with NAT traversal.

[Site-to-Site Networking](https://tailscale.com/use-cases/site-to-site-networking)

![site to site](https://cdn.sanity.io/images/w77i7m8x/production/3316fb3b6301a9160b5456ee5b88cc7a55223492-1280x584.svg?w=3840&q=75&fit=clip&auto=format)

## Tailscale for Enterprise

Gain the tools to protect enterprises of any scale with automated user onboarding, SSH session recording, and audit log streaming.

[Enterprise](https://tailscale.com/enterprise)

![enterprise](https://cdn.sanity.io/images/w77i7m8x/production/481ad859f0d7ae07295066a7b655588b1069ab1c-1280x584.svg?w=3840&q=75&fit=clip&auto=format)

## 100+ integrations means you can incorporate Tailscale into any workflow

![apple](https://cdn.sanity.io/images/w77i7m8x/production/f2165c578beeb00eba8d8ab9b9f497582ef5561d-140x141.svg?w=384&q=75&fit=clip&auto=format)

![docker](https://cdn.sanity.io/images/w77i7m8x/production/fd5ace20704ee1d1d3c7473da3acf37ebfb68c87-140x140.svg?w=384&q=75&fit=clip&auto=format)

![duolingo](https://cdn.sanity.io/images/w77i7m8x/production/f4b2bfcd48f641a22e730f56b3765bff3da95f9a-139x140.svg?w=384&q=75&fit=clip&auto=format)

![pi](https://cdn.sanity.io/images/w77i7m8x/production/84e489c54a18b9181288defb3baa52596a4fe31d-139x140.svg?w=384&q=75&fit=clip&auto=format)

![logo](https://cdn.sanity.io/images/w77i7m8x/production/a0f70705d8af722299490b8c32b19fe65faa8afb-139x140.svg?w=384&q=75&fit=clip&auto=format)

![logo](https://cdn.sanity.io/images/w77i7m8x/production/040a7fa9084571d9180dc0859ae8811dcf538a3f-139x140.svg?w=384&q=75&fit=clip&auto=format)

![mac os](https://cdn.sanity.io/images/w77i7m8x/production/73caae2d6b96ebcdaad6c832c75937afa93c1a17-139x140.svg?w=384&q=75&fit=clip&auto=format)

![synology](https://cdn.sanity.io/images/w77i7m8x/production/b874dfeb68a63d08282a12c7de4a5bbb487face2-139x140.svg?w=384&q=75&fit=clip&auto=format)

![android](https://cdn.sanity.io/images/w77i7m8x/production/4a4487a99a1409efc76acbd2b56dc3094621f5e4-140x140.svg?w=384&q=75&fit=clip&auto=format)

![logo](https://cdn.sanity.io/images/w77i7m8x/production/7429e3ada9a6a8bfb7c86fd39d76e0761ec1fbcf-139x140.svg?w=384&q=75&fit=clip&auto=format)

![logo](https://cdn.sanity.io/images/w77i7m8x/production/624220f941f37ebb8df84fcb33cc54c49894030a-139x140.svg?w=384&q=75&fit=clip&auto=format)

![logo](https://cdn.sanity.io/images/w77i7m8x/production/48a861b5427f501ef828283d4e557ec07aa7f9ff-140x140.svg?w=384&q=75&fit=clip&auto=format)

![github](https://cdn.sanity.io/images/w77i7m8x/production/38611ffd97c4bc3c4356ea5204165c4f60b63de0-139x140.svg?w=384&q=75&fit=clip&auto=format)

![meta mask](https://cdn.sanity.io/images/w77i7m8x/production/acb02cdab82fe85fc5cd9b1701e3360485d5944e-139x140.svg?w=384&q=75&fit=clip&auto=format)

![windows](https://cdn.sanity.io/images/w77i7m8x/production/4b164d99596fff05ec355459e5260254fa0b5c87-140x140.svg?w=384&q=75&fit=clip&auto=format)

[Operating systems](https://tailscale.com/integrations?category=operating-systems-(os)) | [Identity providers](https://tailscale.com/integrations?category=identity-providers#identity-providers) | [Get started with AWS](https://aws.amazon.com/marketplace/pp/prodview-jvxfapco43wr4?trk=41156f33-2a52-4124-8993-f9cde0e7aaab&sc_channel=el&source=tailscale)

## Homelab

### Your home away from home

Access your homelab, personal devices, and dev environments wherever you are - for free.

[Download for free](https://login.tailscale.com/start) | [Learn more](https://tailscale.com/use-cases/homelab)

#### Developer approved

## Simple, powerful, and reliable

![quick deployment](https://cdn.sanity.io/images/w77i7m8x/production/71f614d92af4821e1c55ec43e61d0df7df305424-138x103.svg?w=384&q=75&fit=clip&auto=format)

#### [Quick deployment](https://tailscale.com/why-tailscale#streamlined-setup)

Establish private networks in minutes and push out Tailscale to users without having to configure every device.

![Infrastructure agnostic](https://cdn.sanity.io/images/w77i7m8x/production/c4d3b72947b9f9359f2a3c2bbc20b3ae3ebed0bf-138x103.svg?w=384&q=75&fit=clip&auto=format)

#### [Infrastructure agnostic](https://tailscale.com/why-tailscale#infrastructure-agnostic)

Tailscale works wherever you do, on any platform, service, or runtime, anywhere.

![Secure by default](https://cdn.sanity.io/images/w77i7m8x/production/53da8fed443bccea69db6b8d3bf98126cd5d80d0-138x103.svg?w=384&q=75&fit=clip&auto=format)

#### [Secure by default](https://tailscale.com/why-tailscale#secure-and-private)

Authorize which resources are accessible to users, roles, or groups with grants and Access Control Lists (ACLs).

#### 3 mins

to set up your network

#### 2.5m

devices connected

#### 10k+

companies running Tailscale

## Our commitment to security

We are committed to always safeguarding your data. Every connection is encrypted end-to-end using WireGuard®, a modern VPN protocol designed for usability, performance, and security. Stay up-to-date on updates via our security bulletin below.

[Learn more](https://tailscale.com/security) | [Security bulletins](https://tailscale.com/security-bulletins)

![sso](https://cdn.sanity.io/images/w77i7m8x/production/91e48b4514e8c5beb3583fb6810d214c040fd350-180x211.svg?w=384&q=75&fit=clip&auto=format)

![access control list](https://cdn.sanity.io/images/w77i7m8x/production/6d6337bac55bab4d05b49b4dcc40c6b11e8c5907-180x212.svg?w=384&q=75&fit=clip&auto=format)

![end to end encrypted](https://cdn.sanity.io/images/w77i7m8x/production/eccd917b4275e52b4acbac120c8e25e4b3869063-180x212.svg?w=384&q=75&fit=clip&auto=format)

![soc 2](https://cdn.sanity.io/images/w77i7m8x/production/f45caa9b380058aabbd7be47c484eb94888ff36c-180x211.svg?w=384&q=75&fit=clip&auto=format)

![latacora audits](https://cdn.sanity.io/images/w77i7m8x/production/7c081b956070e21ef707e825da90793c43d3d76d-180x212.svg?w=384&q=75&fit=clip&auto=format)

![security bulletins](https://cdn.sanity.io/images/w77i7m8x/production/48f907c3c098142c7f979757e64a94fb405c5ce4-180x212.svg?w=384&q=75&fit=clip&auto=format)

### Fits into your preferred workflow

With 100+ integrations, Tailscale works with all your favorite tools. Provision resources that automatically join the tailnet using Terraform or Pulumi. Integrate policy management into your existing GitOps workflow. Our docs will help you get started on building your tailnet today.

[See docs](https://tailscale.com/kb/)

![docs](https://cdn.sanity.io/images/w77i7m8x/production/527b93e1e1c9b63f0f7b90a8ac60886f462f0794-790x215.svg?w=1920&q=75&fit=clip&auto=format)

[

![quickstart guides](https://cdn.sanity.io/images/w77i7m8x/production/1356c41503382f05f78366329d62b84d62e4fb75-400x430.svg?w=828&q=75&fit=clip&auto=format)

GUIDES

### Tailscale quickstart guide

[Read guide](https://tailscale.com/kb/1017/install/)
```



### File: 1011-log-mesh-traffic.md

```markdown
# Logging overview

Each Tailscale agent in your distributed network streams its logs to a central log server (at `log.tailscale.com`). This includes real-time events for open and close events for every inter-machine connection (TCP or UDP) on your network.

Because every connection requires two endpoints, and both endpoints log every connection, it's possible to detect lost or tampered logs by comparing the double entries of each endpoint. You could also use IDS (intrusion detection system) rules to automatically detect suspicious activity on your network.

## [Client logs](#client-logs)

Each client logs information about its own operation and its attempts to contact other nodes. The data collected and how it is used are described in our [privacy policy](https://tailscale.com/privacy-policy).

You can access logs locally for nodes on some desktop platforms.

[Windows](https://tailscale.com/kb/1011/log-mesh-traffic?tab=windows)[macOS](https://tailscale.com/kb/1011/log-mesh-traffic?tab=macos)[iOS / tvOS](https://tailscale.com/kb/1011/log-mesh-traffic?tab=ios+%2F+tvos)[Android](https://tailscale.com/kb/1011/log-mesh-traffic?tab=android)[Linux](https://tailscale.com/kb/1011/log-mesh-traffic?tab=linux)

Logs are stored in `C:\ProgramData\Tailscale` (or, more generally `$env:ALLUSERSPROFILE\Tailscale`).

### [Centralized log management](#centralized-log-management)

Some logs are centrally collected by Tailscale for debugging. This is done with a [custom-built, high-capacity, high-reliability, distributed logging system](https://apenwarr.ca/log/20190216).

Client operational logs are only accessible locally on each node, but you could stream your system- and container-level logs to the same centralized data store for further analysis. [Network flow logs](#network-flow-logs) are available from the admin console when enabled.

### [Opt out of client logging](#opt-out-of-client-logging)

If you block client logging, Tailscale may not be able to provide technical support.

[Windows](https://tailscale.com/kb/1011/log-mesh-traffic?tab=windows)[macOS](https://tailscale.com/kb/1011/log-mesh-traffic?tab=macos)[Linux](https://tailscale.com/kb/1011/log-mesh-traffic?tab=linux)

This is possible if you set the `TS_NO_LOGS_NO_SUPPORT` environment variable in `%ProgramData%\Tailscale\tailscaled-env.txt`:

```powershell
TS_NO_LOGS_NO_SUPPORT=true
```

To track when you can instead use the `--no-logs-no-support` flag, follow our [GitHub issue](https://github.com/tailscale/tailscale/issues/5114) for making it easier to use environment variables.

## [Kubernetes Operator logs](#kubernetes-operator-logs)

The Kubernetes Operator's reconciliation logs are centrally collected for debugging. These logs describe steps the Kubernetes Operator has taken to bring the deployed state in-line with the desired state regarding Kubernetes resources.

Refer to our [privacy policy](https://tailscale.com/privacy-policy) to understand the data collected and how we use it.

You can access logs locally using the `kubectl logs` command.

### [Opt out of Kubernetes logging](#opt-out-of-kubernetes-logging)

If you deployed the Kubernetes Operator with Helm, add the `TS_NO_LOGS_NO_SUPPORT` environment variable to the `operatorConfig.extraEnv` section:

```yaml
operatorConfig:
  extraEnv:
  - name: TS_NO_LOGS_NO_SUPPORT
    value: "true"
```

If you deployed the Kubernetes Operator with static manifests, add the `TS_NO_LOGS_NO_SUPPORT` environment variable to the Kubernetes Operator's Deployment:

```yaml
env:
- name: TS_NO_LOGS_NO_SUPPORT
  value: "true"
```

## [Network flow logs](#network-flow-logs)

Network flow logs are available for [the Premium and Enterprise plans](https://tailscale.com/pricing).

[Network flow logs](https://tailscale.com/kb/1219/network-flow-logs) are available to help you understand which devices are connecting to one another over time, that is, the _flow_ of traffic across your tailnet.

These logs strictly do not contain any information about client operations or contents of network traffic.

Network flow logs must be [enabled](https://tailscale.com/kb/1219/network-flow-logs#enable-network-flow-logs).

Flow logs can be configured to [stream](https://tailscale.com/kb/1255/log-streaming) to a security information and event management (SIEM) system.

## [Server logs](#server-logs)

[Configuration audit logs](https://tailscale.com/kb/1203/audit-logging) record actions that modify a tailnet's configuration, including the type of action, the actor, the target resource, and the time.

All [users who have access to the admin console](https://tailscale.com/kb/1138/user-roles) can view configuration audit logs in the [Logs](https://login.tailscale.com/admin/logs) page of the admin console, and can filter these logs to find specific events.

Configuration audit logs are enabled by default for all tailnets, and are available for the most recent 90 days.

Audit logs can be configured to [stream](https://tailscale.com/kb/1255/log-streaming) to a security information and event management (SIEM) system.

## [Local SSH session logs](#local-ssh-session-logs)

Local SSH session logs are not supported as of version 1.48.0.

You can use [Tailscale SSH session recording](https://tailscale.com/kb/1246/tailscale-ssh-session-recording) to streaming recordings from the server device.
```



### File: 1013-sso-providers.md

```markdown
# Supported SSO identity providers

Tailscale works on top of the identity provider (IdP) or single sign-on (SSO) provider that you already use.

## [Set up an identity provider](#set-up-an-identity-provider)

When you activate your domain name with Tailscale for the first time, you must choose which identity provider you want to use.

You need to be an [Owner](https://tailscale.com/kb/1138/user-roles) of a tailnet to set up an identity provider.

### [Supported native identity providers](#supported-native-identity-providers)

Tailscale natively supports the following identity providers:

-   [Apple](https://tailscale.com/kb/1283/sso-apple)
-   [Google](https://tailscale.com/kb/1199/sso-google), including Gmail and Google Workspace (G Suite)
-   [GitHub](https://tailscale.com/kb/1284/sso-github)
-   [Microsoft](https://tailscale.com/kb/1285/sso-microsoft), including Microsoft Accounts, Office365, Active Directory, and Microsoft Entra ID
-   [Okta](https://tailscale.com/kb/1066/sso-okta)
-   [OneLogin](https://tailscale.com/kb/1070/sso-onelogin)

### [Supported custom identity providers](#supported-custom-identity-providers)

In addition to the natively supported identity providers, Tailscale also lets you authenticate with [custom OpenID Connect (OIDC) providers](https://tailscale.com/kb/1240/sso-custom-oidc). For the list of custom identity providers that Tailscale has successfully tested, see [Additional provider configurations](https://tailscale.com/kb/1240/sso-custom-oidc#additional-provider-configurations).

### [Support for passkeys](#support-for-passkeys)

Tailscale supports the use of [passkey](https://tailscale.com/kb/1269/passkeys) authentication for any tailnet that you are authorized to join.

### [Signing up with an email address](#signing-up-with-an-email-address)

Tailscale does not support sign-up with email addresses. By design, Tailscale is not an identity provider-there are no Tailscale passwords.

Identity providers build robust infrastructure to handle identity and authentication, which are core and complex aspects of security. Tailscale delegates user authentication to identity providers because of their expertise, which allows Tailscale to focus on areas like secure networking.

Using an identity provider is not only more secure than email and password, but it allows us to automatically [rotate connection encryption keys](https://tailscale.com/blog/rotate-ssh-keys), [follow security policies](https://tailscale.com/kb/1018/acls) set by your team such as multifactor authentication (MFA), and more.

For more information about why Tailscale is not an identity provider, refer to the [Tailscale doesn't want your password](https://tailscale.com/blog/passkeys) and [SSO tax, cut](https://tailscale.com/blog/sso-tax-cut) blog posts.

### [Support for 2FA and MFA](#support-for-2fa-and-mfa)

Tailscale supports two-factor and multifactor authentication.

Tailscale does not handle authentication itself. Instead, you can [enable 2FA and MFA features](https://tailscale.com/kb/1075/multifactor-auth) in your single sign-on identity provider, and they will apply to all your apps, including Tailscale.

## [Changing identity providers](#changing-identity-providers)

You need to be an [Owner, Admin, or IT admin](https://tailscale.com/kb/1138/user-roles) of a tailnet to change the identity provider configuration.

If you need to change identity providers, [contact support](https://tailscale.com/contact/support?type=sso).

Unfortunately, we cannot migrate your tailnet from/to GitHub or Apple as an identity provider.

## [What Tailscale accesses from identity providers](#what-tailscale-accesses-from-identity-providers)

Tailscale uses OpenID Connect (OIDC) for authentication.

Tailscale requests the minimum access needed to function. When authenticating to Tailscale, you must share information about users' emails and their name. Some providers also share a user photo; in this case, Tailscale stores the photo URL but not the photo itself.

Tailscale only uses your organization's team membership to ensure users can join the tailnet for their organization. With the GitHub identity provider, Tailscale requests the minimum set of permissions needed to get team membership, which includes access to your repositories and project boards. Tailscale does not use any content in your repositories or project boards.

Tailscale requests the minimum number scopes required to operate, and the information on how we use your data can be found in our [privacy policy](https://tailscale.com/privacy-policy).
```



### File: 1017-install.md

```markdown
# Tailscale quickstart

Welcome! Follow the steps below to create your own private Tailscale network (known as a tailnet), or watch the video to learn how to get started with Tailscale and set up some useful features.

## [Create a tailnet](#create-a-tailnet)

1.  Go to [`tailscale.com`](https://tailscale.com/) and select **Get Started**. Alternatively, you can [download and install](https://tailscale.com/kb/1347/installation) the Tailscale client on your device, then [sign up](https://login.tailscale.com/start).

2.  On the **Sign up with your identity provider** page, log in using a [single sign-on (SSO) identity provider](https://tailscale.com/kb/1013/sso-providers) account.

    If you sign up using a custom-owned domain, you are automatically enrolled in the [Enterprise](https://tailscale.com/pricing) plan for a 14-day trial. If you sign up using a public domain email account such as `@gmail.com`, you are automatically enrolled in the [Personal](https://tailscale.com/pricing) plan, which entitles you to three free users and many of the features offered in the Enterprise plan. You can always change your plan. For details, refer to [Modify billing](https://tailscale.com/kb/1182/billing-information).

3.  On the **Welcome to Tailscale** page, select either **Business use** or **Personal use**.

4.  On the **Let's add your first device** page, select the OS that corresponds to the device you are using to download and install the client. Authenticate the client using the same credentials that you used to create the tailnet in step 2.

    Once you are authenticated, the device will appear in the browser window.

5.  On the **Next, add a second device** page, select the OS for another machine to add to the tailnet. Copy the link and send it to the second device. After the second device is authenticated, both devices will display.

6.  Select **Take me home**. You will be redirected to the Tailscale [admin console](https://login.tailscale.com/admin). This interface lets you control most aspects of your tailnet including users, devices, DNS, permissions, authentication keys, and more.


## [Rename devices](#rename-devices)

Every device added to a tailnet, including servers, nodes, phones, and personal computers is assigned a unique name generated from the device's OS hostname. This name is displayed in the [Machines](https://login.tailscale.com/admin/machines) page of the admin console. You can also [rename a device](https://tailscale.com/kb/1098/machine-names#renaming-a-machine) to help you locate and organize devices in the **Machines** page list.

## [Use MagicDNS](#use-magicdns)

[MagicDNS](https://tailscale.com/kb/1081/magicdns) makes communicating with devices across your tailnet easier by allowing you to use the name listed in the **Machines** page of the admin console instead of an IP address. This works using automatically assigned OS hostnames or renamed device names. MagicDNS is enabled by default, and we recommend you keep it enabled.

## [Invite users](#invite-users)

There are two types of tailnet user invites.

Team member invites are for users who will authenticate using the same identity provider you used when creating the tailnet.

External invites are for users who are not part of your custom domain, such as contractors, friends, and family.

### [Team members](#team-members)

If your tailnet uses a custom domain (`example.com`), users with email addresses with the same domain can log in without needing an invite. Alternatively, you can send [team member invites](https://tailscale.com/kb/1064/invite-team-members) to notify them to join.

### [External users](#external-users)

To invite external users to a tailnet, open the [Users](https://login.tailscale.com/admin/users) page of the admin console, select **Invite external users**, and choose one of the following options:

-   **Invite via email** to send one or more invites.
-   **Copy invite link** to share the invite link with others.

When users select the link, they will be directed to the Tailscale login page, where they can authenticate using a [supported single sign-on (SSO) identity provider](https://tailscale.com/kb/1013/sso-providers) account. Once they are authenticated, users are added on the **Users** page of the admin console.

For more information, refer to [Invite any user to your tailnet](https://tailscale.com/kb/1271/invite-any-user).

## [Add devices](#add-devices)

You can add more devices to your tailnet using one of the following methods:

-   [Login](https://login.tailscale.com/login) to the tailnet from other devices using an existing user account.
-   Add servers to a tailnet using a [tag](https://tailscale.com/kb/1068/tags) as the identity of the server, and provision the server using an [authentication key](https://tailscale.com/kb/1085/auth-keys). For more information, refer to [Setting up a server on your Tailscale network](https://tailscale.com/kb/1245/set-up-servers).
-   Incorporate your existing system policies such as mobile device management (MDM) to control device management. For more information, refer to [Integrate with an MDM solution](https://tailscale.com/kb/1362/mdm).

Tailscale automatically assigns each device on your network a [unique 100.x.y.z IP address](https://tailscale.com/kb/1033/ip-and-dns-addresses), to establish stable connections between machines no matter where they are in the world, even when they switch networks or are [behind a firewall](https://tailscale.com/blog/how-nat-traversal-works).

To learn more about adding devices, refer to [Add a device](https://tailscale.com/kb/1316/device-add).

## [Secure traffic using exit nodes](#secure-traffic-using-exit-nodes)

Keep your internet activity private on an untrusted network by designating devices in your tailnet as exit nodes, then configure your tailnet devices to use those exit nodes.

-   For details on how to quickly configure and use exit nodes, refer to [Use exit nodes](https://tailscale.com/kb/1408/quick-guide-exit-nodes).
-   For more in-depth information about exit nodes, refer to the main [Exit nodes](https://tailscale.com/kb/1103/exit-nodes) topic.

## [Route traffic using subnets](#route-traffic-using-subnets)

You can provide tailnet access to existing resources in your network using a subnet router. This can be useful if you need to access devices on which the Tailscale client cannot be installed, such as printers.

-   For details on how to quickly configure and use a subnet router, refer to [Configure a subnet router](https://tailscale.com/kb/1406/quick-guide-subnets).
-   For more in-depth information about subnet routers, refer to the main [Subnet routers](https://tailscale.com/kb/1019/subnets) topic.

## [Manage permissions with access control policies](#manage-permissions-with-access-control-policies)

You can define your own custom permission for the users and devices in your tailnet, using [access control policies](https://tailscale.com/kb/1393/access-control) (such as [ACLs](https://tailscale.com/kb/1018/acls) or [grants](https://tailscale.com/kb/1324/grants)). These permissions are configured in the tailnet policy file, which is located on the [Access controls](https://login.tailscale.com/admin/acls) page of the admin console.

## [Monitor and log traffic](#monitor-and-log-traffic)

You can monitor and log tailnet activity such as network traffic, client activity, tailnet configuration changes, and SSH session recordings.

For more information, refer to [Logging, auditing, and streaming](https://tailscale.com/kb/1011/log-mesh-traffic).

## [Use cases](#use-cases)

Need some inspiration? Tailscale can be used for a wide variety of users and environments. This section provides guidance for some common scenarios that you may want to use in your tailnet.

### [Developers](#developers)

-   Interact with tailnet resources from Visual Studio Code using our [Visual Studio Code extension](https://tailscale.com/kb/1265/vscode-extension).
-   Deploy, scale, and manage containerized applications such as [Kubernetes](https://tailscale.com/kb/1185/kubernetes), [Docker](https://tailscale.com/kb/1282/docker), and [Proxmox](https://tailscale.com/kb/1133/proxmox).
-   [Connect to serverless apps](https://tailscale.com/kb/1364/serverless) such as AWS App Runner, AWS Lambda, Google Cloud Run, and Heroku.
-   [Connect to cloud services](https://tailscale.com/kb/1357/cloud-server) such as AWS, Azure, Google Compute Engine, Hetzner, and Oracle Cloud.
-   Share local services on your machine such as web applications, accessible only from your tailnet using [Tailscale Serve](https://tailscale.com/kb/1312/serve) or share publicly over the internet using [Tailscale Funnel](https://tailscale.com/kb/1223/funnel).
-   [Share prototype servers](https://tailscale.com/kb/1034/local-team-server) with other colleagues without needing to modify firewall settings.

### [IT admins](#it-admins)

-   Manage the authentication and authorization of SSH connections in your tailnet using [Tailscale SSH](https://tailscale.com/kb/1193/tailscale-ssh).
-   Integrate Tailscale deployments on [AWS](https://tailscale.com/kb/1296/aws-reference-architecture) and [Azure](https://tailscale.com/kb/1314/azure-reference-architecture).
-   Control device and user access to your third-party applications without requiring any end-user configuration using [app connectors](https://tailscale.com/kb/1281/app-connectors).
-   Control what users can access in their Tailscale client using [system policies](https://tailscale.com/kb/1315/mdm-keys).
-   Use [Tailscale SSH session recording](https://tailscale.com/kb/1246/tailscale-ssh-session-recording) to stream recordings of Tailscale SSH sessions from the destination node to a recorder node in your tailnet.
-   Automate aspects of your Tailscale network using the [Tailscale API](https://tailscale.com/kb/1101/api).
-   Share an existing service with your peers outside your domain with [node sharing](https://tailscale.com/kb/1084/sharing).
-   Administer a computer remotely and lock down your [connections to a Microsoft Remote Desktop Protocol (RDP) server](https://tailscale.com/kb/1095/secure-rdp-windows).

### [Personal users](#personal-users)

-   Connect an [Apple TV](https://tailscale.com/kb/1280/appletv) to your tailnet for viewing your media server files, use your Apple TV as an [exit node](https://tailscale.com/kb/1103/exit-nodes) to route traffic through your home internet connection when you're away, or choose an exit node to route your Apple TV's traffic through.
-   Receive files from a [network attached storage](https://tailscale.com/kb/1307/nas) (NAS) server using FTP, and access media files from players such as VLC, Plex, and JellyFin.
-   Implement DNS-based ad blocking for your tailnet using [Control D](https://tailscale.com/kb/1403/control-d), [NextDNS](https://tailscale.com/kb/1218/nextdns) or a [Pi-hole](https://tailscale.com/kb/1114/pi-hole) server.
-   Share files between your own devices, even across operating systems, with [Taildrop](https://tailscale.com/kb/1106/taildrop).
-   Host a private server for you and your peers to play [Minecraft](https://tailscale.com/kb/1137/minecraft) or chat on IRC.

## [Troubleshooting and support](#troubleshooting-and-support)

Visit our [Support](https://tailscale.com/contact/support) page to read common questions and answers, file bugs, request new features, observe Tailscale's operational status, or engage directly with our Support team.

Here are some links that provide assistance for common inquiries:

-   [Troubleshooting guide](https://tailscale.com/kb/1023/troubleshooting)
-   [Production best practices](https://tailscale.com/kb/1300/production-best-practices)
-   [Security best practices](https://tailscale.com/kb/1196/security-hardening)
-   [Using Tailscale with your firewall](https://tailscale.com/kb/1181/firewalls)
```



### File: 1019-subnets.md

```markdown
# Subnet routers

Subnet routers are available for [all plans](https://tailscale.com/pricing).

Subnet routers let you extend your Tailscale network (known as a tailnet) to include devices that don't or can't run the Tailscale client. They act as gateways between your tailnet and physical subnets, enabling secure access to legacy devices, entire networks, or services without installing Tailscale everywhere. This capability maintains Tailscale's security model while providing flexibility for complex network environments.

## [Why it matters](#why-it-matters)

When designing a secure network, installing the Tailscale client directly on each device provides the best security and performance through end-to-end [encryption](https://tailscale.com/kb/1504/encryption). However, network administrators frequently encounter situations where direct installation isn't feasible. Devices like printers often lack the capability to run Tailscale, and in large environments such as [AWS VPCs](https://tailscale.com/kb/1021/install-aws) or legacy networks undergoing gradual modernization, installing clients on every endpoint becomes impractical.

Subnet routers bridge this gap by functioning as gateways that relay traffic between your tailnet and conventional subnet-based networks. They maintain Tailscale's security model by respecting [access control policies](https://tailscale.com/kb/1393/access-control) while extending connectivity to non-Tailscale devices. This approach offers a practical balance between security and connectivity requirements.

An important consideration for organizations is that devices behind subnet routers don't count toward your [pricing plan's device limit](https://tailscale.com/pricing). Nevertheless, when possible, installing Tailscale directly on devices remains preferable for optimal performance, security, and configuration simplicity.

## [Benefits](#benefits)

The subnet router approach provides several important advantages for network administrators and organizations. Each benefit addresses specific challenges in modern network environments.

-   **Connect legacy devices**-include devices that can't run the Tailscale client in your Tailscale network.
-   **Integrate entire networks**-connect large networks, such as AWS VPCs, without installing Tailscale on each device.
-   **Gradual deployment**-phase in Tailscale adoption by connecting existing network segments through subnet routers.
-   **Maintain access control**-subnet routers respect Tailscale's access control policies, maintaining security across your network.

## [Use cases](#use-cases)

Subnet routers solve practical problems in various network environments by extending Tailscale's secure connectivity model. These use cases represent common deployment scenarios where subnet routers provide substantial value.

-   **Managed service access**-securely connect to cloud-managed services like Amazon RDS or Google Cloud SQL without exposing them to the public internet.
-   **Cloud network integration**-seamlessly connect cloud VPCs or other cloud network segments to your Tailscale network.
-   **Device connectivity**-make devices like printers or cameras accessible to remote Tailscale users without needing to install the Tailscale client.

## [How subnet routers work](#how-subnet-routers-work)

Subnet routers function as networking bridges that connect separate network environments under a unified access model. They operate at the network layer to facilitate communication between your Tailscale network and traditional subnet-based networks.

A subnet router connects subnets, which are parts of a larger network. In Tailscale, a subnet router is a device in your tailnet that you use as a gateway to advertise routes to other devices. This lets devices connect to your tailnet without installing the Tailscale client.

Any device that uses the subnet router as a gateway is considered _behind_ the subnet router. Subnet routers use Source Network Address Translation (SNAT) by default. When SNAT is enabled, traffic from a device behind a subnet router appears to come from the router itself, not the original device. If preserving the original source IP address is important for your use case, you can [disable SNAT](#disable-snat) to maintain the original device's IP address in the traffic packets.

### [Subnet routers and exit nodes](#subnet-routers-and-exit-nodes)

Subnet routers and exit nodes serve different purposes in the Tailscale ecosystem, though they both involve routing traffic. Understanding the distinction helps you deploy the right solution for your networking needs.

Exit nodes route outbound internet traffic from your tailnet devices, effectively functioning as VPN servers. When you connect to an exit node, your internet traffic appears to come from the exit node's location. This is useful for accessing geo-restricted content or improving privacy. In contrast, subnet routers provide access to specific private subnets. They enable tailnet devices to reach non-Tailscale devices within those subnets, but don't affect internet traffic routing. If you need to access private networks like office LANs or cloud VPCs, subnet routers are the appropriate solution.

## [Set up a subnet router](#set-up-a-subnet-router)

Setting up a subnet router involves installing Tailscale on a device that will act as the gateway, configuring it to advertise routes, and ensuring proper access controls. This process requires administrative access to both the subnet router device and your Tailscale network.

You can use almost any device that runs the Tailscale client as a subnet router. To configure a device to run as a subnet router, use the instructions below or refer to the [quickstart guide](https://tailscale.com/kb/1406/quick-guide-subnets).

1.  [Install the Tailscale client](#install-the-tailscale-client).
2.  [Connect to Tailscale as a subnet router](#connect-to-tailscale-as-a-subnet-router).
3.  [Enable subnet routes from the admin console](#enable-subnet-routes-from-the-admin-console).
4.  [Add access rules for advertised subnet routes](#add-access-rules-for-the-advertised-subnet-routes).
5.  [Verify your connection](#verify-your-connection).
6.  [Use your subnet routes from other devices](#use-your-subnet-routes-from-other-devices).

### [Install the Tailscale client](#install-the-tailscale-client)

The first step in creating a subnet router is installing the Tailscale client on the device that will serve as your gateway. Installation procedures vary by platform, but the process is straightforward across supported operating systems.

[Linux](https://tailscale.com/kb/1019/subnets?tab=linux)[macOS](https://tailscale.com/kb/1019/subnets?tab=macos)[tvOS](https://tailscale.com/kb/1019/subnets?tab=tvos)[Windows](https://tailscale.com/kb/1019/subnets?tab=windows)[Android](https://tailscale.com/kb/1019/subnets?tab=android)

[Download and install Tailscale](https://tailscale.com/download/linux) onto the device you plan to use as a subnet router.

### [Connect to Tailscale as a subnet router](#connect-to-tailscale-as-a-subnet-router)

After installing Tailscale, you need to configure the device to function as a subnet router by enabling IP forwarding and advertising the subnet routes you want to make available. These steps transform a standard Tailscale node into a gateway for other networks.

[Linux](https://tailscale.com/kb/1019/subnets?tab=linux)[macOS](https://tailscale.com/kb/1019/subnets?tab=macos)[tvOS](https://tailscale.com/kb/1019/subnets?tab=tvos)[Windows](https://tailscale.com/kb/1019/subnets?tab=windows)[Android](https://tailscale.com/kb/1019/subnets?tab=android)

To use a Linux device as a subnet router, you need to complete two essential configurations: enabling IP forwarding and advertising subnet routes. Linux devices make particularly good subnet routers due to their stability and networking capabilities.

1.  Enable IP forwarding.
2.  Advertise subnet routes.

#### [Enable IP forwarding](#enable-ip-forwarding)

When enabling IP forwarding, ensure your firewall denies traffic forwarding by default. This is the default setting for standard firewalls like `ufw` and `firewalld`. Blocking traffic forwarding by default prevents unintended routing of traffic.

IP forwarding is required to use a Linux device as a subnet router. This kernel setting lets the system forward network packets between interfaces, essentially functioning as a router. The process for enabling IP forwarding varies between Linux distributions. However, the following instructions work in most cases.

If your Linux system has a `/etc/sysctl.d` directory, use:

```shell
echo 'net.ipv4.ip_forward = 1' | sudo tee -a /etc/sysctl.d/99-tailscale.conf
echo 'net.ipv6.conf.all.forwarding = 1' | sudo tee -a /etc/sysctl.d/99-tailscale.conf
sudo sysctl -p /etc/sysctl.d/99-tailscale.conf
```

Otherwise, use:

```shell
echo 'net.ipv4.ip_forward = 1' | sudo tee -a /etc/sysctl.conf
echo 'net.ipv6.conf.all.forwarding = 1' | sudo tee -a /etc/sysctl.conf
sudo sysctl -p /etc/sysctl.conf
```

If your Linux node uses `firewalld`, you might need to allow masquerading due to a [known issue](https://github.com/tailscale/tailscale/issues/3416). As a workaround, you can allow masquerading with this command:

```shell
firewall-cmd --permanent --add-masquerade
```

#### [Advertise subnet routes](#advertise-subnet-routes)

After you enable IP forwarding, run `tailscale set` with the `--advertise-routes` flag. It accepts a comma-separated list of subnet routes.

```shell
sudo tailscale set --advertise-routes=192.0.2.0/24,198.51.100.0/24
```

Make sure to replace the subnets in the example above with the correct ones for your network. All platforms except Apple TV support both IPv4 and IPv6 subnets. Apple TV only supports IPv4 subnets.

If the device is authenticated by a user who can advertise the specified route in [`autoApprovers`](https://tailscale.com/kb/1337/policy-syntax#autoapprovers), the subnet router's routes will automatically be approved. You can also advertise any subset of the routes allowed by `autoApprovers` in the tailnet policy file. If you'd like to expose default routes (`0.0.0.0/0` and `::/0`), consider using [exit nodes](https://tailscale.com/kb/1103/exit-nodes) instead.

### [Enable subnet routes from the admin console](#enable-subnet-routes-from-the-admin-console)

The admin console provides a centralized interface for approving and managing subnet routes advertised by your devices. This step ensures that the routes you've configured on your subnet router become active in your tailnet.

You can skip this step if you use [`autoApprovers`](https://tailscale.com/kb/1337/policy-syntax#autoapprovers).

1.  Open the [Machines](https://login.tailscale.com/admin/machines) page of the admin console.
2.  Locate the **Subnets** badge in the devices list or use the [`property:subnet`](https://login.tailscale.com/admin/machines?q=property%3Asubnet) filter to list all devices advertising subnet routes.
3.  Select a device with the `subnet` property, then go to the **Subnets** section.
4.  Select **Edit**. This opens the **Edit route settings**.
5.  Under **Subnet routes**, select the routes to approve, then select **Save**.

You can disable [key expiry](https://tailscale.com/kb/1028/key-expiry) on your server to avoid having to periodically reauthenticate. If you use [tags](https://tailscale.com/kb/1068/tags), [key expiry is disabled by default](https://tailscale.com/kb/1068/tags#key-expiry).

### [Add access rules for the advertised subnet routes](#add-access-rules-for-the-advertised-subnet-routes)

Access controls determine which devices and users can access resources through your subnet router. Properly configured access rules are essential for maintaining security while enabling the connectivity you need.

You can skip this step if you already have rules that allow access to your advertised subnet routes.

1.  Open the [Access controls](https://login.tailscale.com/admin/acls) page of the admin console to update your [tailnet policy file](https://tailscale.com/kb/1018/acls).
2.  Create an [access rule](https://tailscale.com/kb/1337/policy-syntax#acls) that lets access to the advertised subnet.

The following example tailnet policy configuration ensures members of `group:dev` can access devices in the subnets `192.0.2.0/24`, `198.51.100.0/24` and `2001:db8::/32`, and ensures the subnet `192.0.2.0/24` can access the subnet `198.51.100.0/24` and vice versa, _if [subnet route masquerading](https://tailscale.com/kb/1023/troubleshooting#disable-subnet-route-masquerading) is disabled_.

```json
{
  "groups": {
    "group:dev": ["alice@example.com", "bob@example.com"]
  },
  "grants": [
    {
      "src": ["group:dev","192.0.2.0/24", "198.51.100.0/24"],
      "dst": ["192.0.2.0/24", "198.51.100.0/24", "2001:db8::/32"],
      "ip": ["*:*"]
    }
  ]
}
```

You can use the [visual policy editor](https://tailscale.com/kb/1550/visual-editor) to manage your tailnet policy file. Refer to the [visual editor reference](https://tailscale.com/kb/1587/visual-editor-reference) for guidance on using the visual editor.

### [Verify your connection](#verify-your-connection)

Verification ensures that your subnet router is properly configured and functioning as expected. This step confirms that your tailnet devices can communicate with the subnet router before attempting to access resources behind it.

Check that you can ping the Tailscale IP address of your new subnet routers from a tailnet device (such as a Linux, macOS, or Windows device). You can find the Tailscale IP in the [admin console](https://login.tailscale.com/admin) or by running the following command on the subnet router.

```shell
tailscale ip -4
```

### [Use your subnet routes from other devices](#use-your-subnet-routes-from-other-devices)

Once your subnet router is configured and verified, you need to ensure that other devices in your tailnet can discover and use the new routes. This process varies slightly by operating system.

Android, iOS, macOS, tvOS, and Windows automatically pick up your new subnet routes.

By default, Linux devices only discover [Tailscale IP addresses](https://tailscale.com/kb/1015/100.x-addresses). To enable automatic discovery of new subnet routes on Linux devices, use the `--accept-routes` flag:

```shell
sudo tailscale set --accept-routes
```

## [Update subnet routes](#update-subnet-routes)

Network requirements evolve over time, and you may need to modify the subnet routes advertised by your subnet router. This process involves updating the route advertisements and ensuring that the changes are properly approved and accessible.

To update subnet routes:

1.  [Connect to Tailscale as a subnet router](#connect-to-tailscale-as-a-subnet-router).
2.  [Enable subnet routes from the admin console](#enable-subnet-routes-from-the-admin-console).
3.  [Add access rules for advertised subnet routes](#add-access-rules-for-the-advertised-subnet-routes).
4.  [Verify your connection](#verify-your-connection).
5.  [Use your subnet routes from other devices](#use-your-subnet-routes-from-other-devices).

You can exclude any routes to prevent the subnet router from advertising them.

## [Use advanced subnet routing](#use-advanced-subnet-routing)

After you set up a subnet router, you might consider:

-   [Route DNS lookups to an internal DNS server](#route-dns-lookups-to-an-internal-dns-server).
-   [Set up high availability for subnet routers](#set-up-high-availability).
-   [Use overlapping routes with different prefix lengths](#use-overlapping-routes-with-different-prefix-lengths) for granular routing control.
-   Connect two or more subnets using [site-to-site](https://tailscale.com/kb/1214/site-to-site) networking.
-   [Disable source NAT (SNAT)](#disable-snat).

### [Route DNS lookups to an internal DNS server](#route-dns-lookups-to-an-internal-dns-server)

DNS configuration lets your tailnet resolve names both for Tailscale devices and for resources on the advertised subnets. This capability enables seamless name resolution across your hybrid network environment.

You can add [Tailscale IP addresses to public DNS records](https://tailscale.com/kb/1054/dns) because Tailscale IP addresses are only accessible to authenticated users of your network. You can use an internal DNS server on your subnet by configuring split DNS in the [DNS](https://login.tailscale.com/admin/dns) page of the admin console.

### [Set up high availability](#set-up-high-availability)

For critical environments, redundant subnet routers provide reliability by ensuring continued connectivity even if individual subnet router devices fail. This approach is essential for production networks where continuous availability is required.

You can set up high availability to ensure your network is connectable even if one subnet router goes offline. For more information, refer to our topic on [high availability failover](https://tailscale.com/kb/1115/high-availability).

When setting up subnet routers for high availability (HA), be careful with the `--accept-routes` flag. If you turn on `--accept-routes` for subnet routers that share the same routes in the same region, the standby router will accept its own advertised routes from the primary router.

This leads to an inefficient routing path. The standby router will send traffic for its directly connected subnet through the primary router instead. For example, if both subnet routers advertise and accept the same route, such as `192.168.1.0/24`, the standby router will send all `192.168.1.0/24` traffic through the primary router, even though it is directly connected to that network.

For most HA subnet router setups, use the `--advertise-routes` flag alone. Avoid using `--accept-routes` unless you specifically need that routing behavior.

### [Use overlapping routes with different prefix lengths](#use-overlapping-routes-with-different-prefix-lengths)

Tailscale supports advertising overlapping subnet routes with different prefix lengths from multiple subnet routers. When traffic is sent to a destination IP address, Tailscale uses longest prefix matching (LPM) to select the most specific route available.

For example, if you configure:

-   Subnet router A advertising `10.0.0.0/16`
-   Subnet router B advertising `10.0.0.0/24`

Traffic is routed based on the most specific match:

-   `10.0.0.1` routes through subnet router B (matched by the more specific `/24` route)
-   `10.0.1.1` routes through subnet router A (only matched by the `/16` route)

This capability is useful for scenarios where you need granular control over routing within a larger address space, such as:

-   Directing specific subnets through dedicated routers for performance
-   Applying different security policies to specific subnets
-   Gradually migrating subnets to new infrastructure

### [Disable SNAT](#disable-snat)

Source Network Address Translation (SNAT) affects how source IP addresses appear to devices in different parts of your network. By default, Tailscale performs SNAT on traffic passing through subnet routers, but this behavior can be modified when necessary.

By default, when you advertise subnet routes, Tailscale uses source network address translation (SNAT) (also called masquerading). You can disable SNAT by using the `--snat-subnet-routes=false` flag (Linux only) with the [`tailscale up`](https://tailscale.com/kb/1241/tailscale-up) command. Disabling SNAT preserves the source IP addresses of the hosts behind the subnet router.

```shell
tailscale up --snat-subnet-routes=false
```

When you disable source NAT on a subnet router, devices behind it can access the Tailscale IP addresses of devices they connect to but don't automatically know how to route traffic back to those Tailscale IP addresses. To fix this, you must add a return route that tells the devices to send all Tailscale traffic through your subnet router. You can configure this route in one of three places:

-   On the device's operating system
-   In your VPC settings
-   Through your DHCP server

The route should include:

-   Network: `100.64.0.0/10` (the Tailscale IP address range)
-   Next hop or gateway: The LAN IP address of your subnet router

The `--snat-subnet-routes` flag only works with Linux subnet routers.
```



### File: 1023-troubleshooting.md

```markdown
# Troubleshooting guide

This topic contains various suggestions and tips to help troubleshoot common issues. Refer to [Troubleshoot device connectivity](https://tailscale.com/kb/1463/troubleshoot-connectivity) for connectivity-specific instructions. If you have additional issues, [contact support](https://tailscale.com/contact/support).

## [Linux](#linux)

### [Linux DNS issues](#linux-dns-issues)

For information about troubleshooting DNS issues on Linux, refer to [Configuring Linux DNS](https://tailscale.com/kb/1188/linux-dns).

### [Operator permission](#operator-permission)

The [Tailscale daemon](https://tailscale.com/kb/1278/tailscaled) (tailscaled) typically runs as the `root` user, and so only `root` can manage the daemon. To allow a different user to manage Tailscale, set the user as the operator using the command:

```shell
sudo tailscale set --operator=<username>
```

### [Unseal Linux node state error](#unseal-linux-node-state-error)

If you see error in the [logs](https://tailscale.com/kb/1011/log-mesh-traffic#client-logs) that mention `failed to unseal state file`, see [Recovering from TPM failures](https://tailscale.com/kb/1596/secure-node-state-storage#recover-from-tpm-failures).

## [Apple](#apple)

### [Access macOS files from an iPhone](#access-macos-files-from-an-iphone)

1.  Open the Files app on your iPhone.
2.  Go to the **Browse** tab.
3.  Select the ![ellipsis icon](/files/images/icons/fa-ellipsis-h.svg) in the top right.
4.  Select **Connect to Server** and enter your Mac's Tailscale IP address.

Any folders shared by your Mac (using SMB) can now be browsed.

### [Apple TV access issues](#apple-tv-access-issues)

Refer to [Install Tailscale on an Apple TV](https://tailscale.com/kb/1280/appletv#troubleshooting) for troubleshooting guidance.

### [macOS doesn't display the Tailscale icon in the menu bar](#macos-doesnt-display-the-tailscale-icon-in-the-menu-bar)

When the Tailscale client is running on macOS, an icon should display in the menu bar. If there are many icons in the menu bar, the Tailscale icon can become hidden by other icons. To fix this, hold down the Command key and drag the menu bar icons around to reveal the Tailscale icon and place it in a visible location.

### [macOS gets stuck at `Loading backend...`](#macos-gets-stuck-at-loading-backend)

Do you have Screen Time enabled? Refer to [macOS Screen Time and Tailscale](https://tailscale.com/kb/1420/macos-webproxyfilterd) for troubleshooting guidance.

Do you have a virus scanner (or other form of endpoint security) such as ESET installed? In some cases we've found that security measures interfere with Tailscale's operation.

### [macOS ping issues](#macos-ping-issues)

macOS' "stealth mode" will prevent macOS from responding to pings. This can be enabled or disabled in your Mac's **Security & Privacy** settings. Refer to [this issue](https://github.com/tailscale/tailscale/issues/454) for updates on improving related notifications and user experience.

### [macOS system extension errors](#macos-system-extension-errors)

Refer to [Authorizing the Tailscale system extension on macOS](https://tailscale.com/kb/1340/macos-sysext) for troubleshooting guidance.

## [Windows](#windows)

### [Current supported Windows versions for the Tailscale client](#current-supported-windows-versions-for-the-tailscale-client)

The current version of the Tailscale client available for [download](https://tailscale.com/download/windows) requires Windows 10 or later or Windows Server 2016 or later.

### [Windows error displays when installing the Tailscale client](#windows-error-displays-when-installing-the-tailscale-client)

The Tailscale client installer requires the following Windows system services to be running:

-   `Dnscache`
-   `iphlpsvc`
-   `netprofm`
-   `WinHttpAutoProxySvc`

If the installer does not detect that these services are running, it will automatically fail. For official Microsoft guidance on disabling system services, refer to [Guidance on disabling system services on Windows Server 2016 with Desktop Experience](https://learn.microsoft.com/en-us/windows-server/security/windows-services/security-guidelines-for-disabling-system-services-in-windows-server).

### [Windows errors displays when upgrading the Tailscale client](#windows-errors-displays-when-upgrading-the-tailscale-client)

As part of some Windows 10 and Windows 11 updates, the SYSTEM user's `%LocalAppData%`, usually at `C:\WINDOWS\system32\config\systemprofile\AppData\Local`, is wiped. This directory is where Tailscale 1.14.3 and earlier stored its internal state.

If you upgraded your Windows device and lost connectivity to Tailscale, you can either:

1.  **(Recommended)** Remove the old device using the admin console, and then re-login to Tailscale from the affected Windows device. This needs both a Tailscale admin and someone with access to the device to take action.
    -   Open the [Machines](https://login.tailscale.com/admin/machines) page of the admin console. Find the row corresponding to the device that is affected. Select the ![ellipsis icon](/files/images/icons/fa-ellipsis-h.svg) menu at the far right and select the **Remove** option. This will remove the device from your tailnet.
    -   [Upgrade](https://tailscale.com/kb/1067/update) the affected Windows device to Tailscale v1.14.4 or later.
    -   The affected Windows device should now prompt you to log in again to rejoin your tailnet. If [device approval](https://tailscale.com/kb/1099/device-approval) is enabled, the device will need to be re-approved.
    -   With this option, the device will retain the same name, but have a new IP address.
2.  Remove the remaining Tailscale state files from the Windows device, and then re-login to Tailscale. This does not require an admin to take action, unless [device approval](https://tailscale.com/kb/1099/device-approval) is enabled.
    -   For the affected device, remove all files in the `%LocalAppData%\Tailscale` directory. To do this, you can open cmd.exe and run
        `rmdir /s %LocalAppData%\Tailscale\`
    -   [Upgrade](https://tailscale.com/kb/1067/update) the affected Windows device to Tailscale v1.14.4 or later.
    -   Re-login to Tailscale on the device. If [device approval](https://tailscale.com/kb/1099/device-approval) is enabled, the device will need to be re-approved by an administrator.
    -   With this option, the device will be assigned a new name (for example, `old-name-1`), and have a new IP address. The device's old name will still be listed in the admin console until it is removed. At that time, the admin can rename the new device to the old name.

To avoid this issue in the future, upgrade Windows device to v1.14.4 or later prior to performing a Windows update.

### [Windows ping issues occur after installing the Tailscale client](#windows-ping-issues-occur-after-installing-the-tailscale-client)

Windows generally has aggressive firewall rules set up, even for ICMP (ping) traffic (both incoming and outgoing). Be sure that you've enabled your Windows devices to be able to both send and receive ICMP traffic.

A faster, but riskier approach to test this is to (temporarily) disable the Windows firewalls and check for any impact. Refer to [this issue](https://github.com/tailscale/tailscale/issues/454) for updates on improving related notifications and user experience.

### [Windows RDP error displays indicating user account restriction](#windows-rdp-error-displays-indicating-user-account-restriction)

Users in a Windows domain environment might encounter the following error when attempting to connect to another machine using Remote Desktop Protocol (RDP):

```shell
A user account restriction (for example, a time-of-day restriction)
is preventing you from logging on. For assistance, contact your system
administrator or technical support.
```

This can occur in an environment where the following is true:

-   [MagicDNS](https://tailscale.com/kb/1081/magicdns) is enabled in the tailnet.
-   The remote machine is accessed by its unqualified name or MagicDNS domain name instead of the FQDN in the Active Directory domain.
    -   An example of an unqualified name is `win11e`.
    -   An example of a MagicDNS name is `win11e.example.ts.net`.
    -   An example of a FQDN in Active Directory is `win11e.example.com`.
-   Kerberos authentication is required due to [NTLM](https://en.wikipedia.org/wiki/NTLM) authentication [restrictions](https://learn.microsoft.com/en-us/previous-versions/windows/it-pro/windows-server-2008-r2-and-2008/jj865668\(v=ws.10\)) in the domain.
-   A [service principal name](https://learn.microsoft.com/en-us/windows/win32/ad/service-principal-names) (SPN) is not configured for the remote machine.

We recommend using the [`setspn`](https://learn.microsoft.com/en-us/previous-versions/windows/it-pro/windows-server-2008-r2-and-2008/cc731241\(v=ws.10\)) command to register an SPN. To do this, run the following command as a domain administrator:

```powershell
setspn -S TERMSRV/win11e.example.ts.net WIN11E
```

In the example above, `win11e.example.ts.net` is the hostname in the tailnet, and `WIN11E` is the account name in Active Directory.

### [Windows RDP error displays when a password is not set](#windows-rdp-error-displays-when-a-password-is-not-set)

If you log in to Windows locally using a PIN (Windows Hello) you might find you're unable to log in over Remote Desktop (RDP). Windows requires traditional account passwords for RDP connections.

If you do not have an account password, for example, Windows 11 defaults to using a PIN (Windows Hello), you will want to change your sign-in options and enable password authentication. You can find more information from the Microsoft Support topic [Windows sign-in options and account protection](https://support.microsoft.com/en-us/windows/windows-sign-in-options-and-account-protection-7b34d4cf-794f-f6bd-ddcc-e73cdf1a6fbf#managehello&WindowsVersion=Windows_11).

### [Windows system tray internet icon indicates no access](#windows-system-tray-internet-icon-indicates-no-access)

When hovering over the internet icon in the Windows system tray, the `Tailscale No internet access` status will display if the Windows client is not connected to an [exit node](https://tailscale.com/kb/1103/exit-nodes). This can be ignored and will have no negative impact on your connectivity to your tailnet.

The reason this happens is Windows sends active probes in the form of HTTP requests through all the available interfaces. Since no response is received over the Tailscale client unless an exit node is used, it reports no internet.

The `Tailscale Internet access` status will display when the Windows client is connected to an exit node.

### [Unseal Windows node state error](#unseal-windows-node-state-error)

If you see error in the [logs](https://tailscale.com/kb/1011/log-mesh-traffic#client-logs) that mention `failed to unseal state file`, see [Recovering from TPM failures](https://tailscale.com/kb/1596/secure-node-state-storage#recover-from-tpm-failures).

## [Mobile](#mobile)

### [Mobile device battery drains too quickly](#mobile-device-battery-drains-too-quickly)

This is a [known issue](https://github.com/tailscale/tailscale/issues/3363). However, we are continuously making improvements. Battery drain is most commonly attributed to a device using an exit node for all traffic.

### [Disable specific apps from using Tailscale](#disable-specific-apps-from-using-tailscale)

On Android devices, you can use [app-based split tunneling](https://tailscale.com/kb/1444/android-app-split-tunneling) to choose which apps will bypass or be forced to use the tailnet.

## [Cloud](#cloud)

### [AWS cannot access Google after setting up `--advertise-routes=172.0.0.0/8`](#aws-cannot-access-google-after-setting-up---advertise-routes1720008)

Only part of the `172.0.0.0/8` range is private. The rest is public address space and Google has IP addresses in that range for some of its data centers.

You can safely advertise the `172.16.0.0/12` range instead:

```shell
tailscale set --advertise-routes=172.16.0.0/12
```

### [Cloud Linux VM issues](#cloud-linux-vm-issues)

Refer to the topic [Access Oracle Cloud VMs privately using Tailscale](https://tailscale.com/kb/1149/cloud-oracle#troubleshooting) for troubleshooting guidance.

### [Subnet router connectivity issues in a cloud environment](#subnet-router-connectivity-issues-in-a-cloud-environment)

The most common issue in AWS, Azure Cloud, and GCP that we've seen is a security group being too restrictive, and blocking connections. For troubleshooting purposes, try setting the internal security group to allow all traffic on the subnet, and the security group on the subnet router itself to allow all traffic to test if that unblocks connections.

## [Network](#network)

### [Which firewall ports need to be opened](#which-firewall-ports-need-to-be-opened)

For details, refer to the topic [What firewall ports should I open to use Tailscale?](https://tailscale.com/kb/1082/firewall-ports).

### [CGNAT conflicts](#cgnat-conflicts)

Tailscale assigns each device in your tailnet a unique [100.x.y.z](https://tailscale.com/kb/1015/100.x-addresses) IP address. This is called the carrier grade NAT (CGNAT) address space, reserved by [RFC6598](https://tools.ietf.org/html/rfc6598), _IANA-Reserved IPv4 Prefix for Shared Address Space_. CGNAT conflicts can arise, for example, if your internet service provider (ISP), or [other VPN](https://tailscale.com/kb/1105/other-vpns), also uses the `100.64.0.0/10` subnet (from `100.64.0.0` to `100.127.255.255`).

If you are experiencing CGNAT conflicts, you can disable IPv4 in your tailnet. This will cause Tailscale to use IPv6 only. Be aware that disabling IPv4 will prevent you from accessing IPv4-only resources on your network. For example, IPv4-only exit nodes will not be accessible.

#### [Selectively disable IPv4](#selectively-disable-ipv4)

To selectively disable IPv4, apply the `disable-ipv4` [node attribute](https://tailscale.com/kb/1337/policy-syntax#nodeattrs) to the targets that require it in your tailnet's access control policies:

```json
{
  "nodeAttrs": [
    {
      "target": ["tag:lab-foo"],
      "attr":   ["disable-ipv4"],
    },
  ]
}
```

You can use the [visual policy editor](https://tailscale.com/kb/1550/visual-editor) to manage your tailnet policy file. Refer to the [visual editor reference](https://tailscale.com/kb/1587/visual-editor-reference) for guidance on using the visual editor.

#### [Disable IPv4 tailnet-wide](#disable-ipv4-tailnet-wide)

To disable IPv4 tailnet-wide, apply the `disable-ipv4` [node attribute](https://tailscale.com/kb/1337/policy-syntax#nodeattrs) to all targets in your tailnet's access control policies:

```json
{
  "nodeAttrs": [
    {
      "target": ["*"],
      "attr":   ["disable-ipv4"],
    },
  ]
}
```

You can use the [visual policy editor](https://tailscale.com/kb/1550/visual-editor) to manage your tailnet policy file. Refer to the [visual editor reference](https://tailscale.com/kb/1587/visual-editor-reference) for guidance on using the visual editor.

### [Deploy Tailscale to a fleet of devices](#deploy-tailscale-to-a-fleet-of-devices)

You'll want to use Tailscale's [pre-authenticated keys](https://tailscale.com/kb/1085/auth-keys) feature, which let you authenticate devices by key rather than in-browser.

As an [Admin](https://tailscale.com/kb/1138/user-roles), once you're logged in, you can go to the [Keys](https://login.tailscale.com/admin/settings/keys) page in the admin console to create keys.

### [DERP traffic route checking](#derp-traffic-route-checking)

More in depth information is provided to troubleshoot [direct and relayed connections](https://tailscale.com/kb/1257/connection-types). Use the [Tailscale CLI](https://tailscale.com/kb/1080/cli) to run the [`tailscale status`](https://tailscale.com/kb/1080/cli#status) command. If you observe output in the form of `relay "code"`, then your traffic is being routed through a [relay server](https://tailscale.com/kb/1232/derp-servers) that has "code" as its location. For example, the second line in this `tailscale status` output indicates traffic is being routed through the "sea" (Seattle) relay server:

```shell
100.99.98.97 device1 linux active; direct 1.2.3.4:1234; tx 1000 rx 1000
100.99.98.96 device2 linux active; relay "sea", tx 1000 rx 1000
```

If there is no `relay "code"` line in the `tailscale status` output, then your traffic is not being routed through DERP.

Also, the [`tailscale ping`](https://tailscale.com/kb/1080/cli#ping) command will indicate whether a successful ping was by direct path or using DERP. `tailscale ping` will keep trying until it either sends 10 pings (the default if not using the `--c` flag) through the relays, or finds a direct path. For example, if the first five pings were relayed and the sixth ping was a direct path, `tailscale ping` will stop. This `tailscale ping device2` example indicates the device was reached using the "sea" relay on the first ping, and by direct path on the second ping, at which time `tailscale ping` stopped.

```shell
tailscale ping device2

pong from device2 (100.99.98.96) via DERP(sea) in 242ms
pong from device2 (100.99.98.96) via 1.2.3.4:1234 in 127ms
```

### [Disable subnet route masquerading](#disable-subnet-route-masquerading)

You can disable subnet route masquerading with the following command (Linux only):

```shell
tailscale up --snat-subnet-routes=false
```

SNAT enables transparent communication to the rest of the network by re-writing the source IP address to that of the subnet router. If you disable subnet route masquerading, NAT traffic to local routes that are advertised with `--advertise-routes` will need to have routing manually configured.

### [DNS errors for internal service connectivity](#dns-errors-for-internal-service-connectivity)

If you are using DNS names to access internal services and some people have difficulty connecting to those services, the problem might be caused by [DNS Rebinding Protection](https://tailscale.com/kb/1195/dns-rebinding).

### [Hard NAT with slow or timed out connections](#hard-nat-with-slow-or-timed-out-connections)

In a scenario with three contingent conditions, you may experience network performance issues. This affects latency-sensitive traffic through connectors (exit nodes, subnet routers, and app connectors). One possible visible symptom is DNS resolution timing out. Perform network tests to diagnose your configuration and traffic and ascertain if the following are applicable.

1.  [Hard NAT](https://tailscale.com/kb/1257/connection-types#hard-nat) makes establishing direct connections difficult (if not impossible). Tailscale will fall back to DERP relay servers based around the world.

2.  If heavy packets per second or bits per second of traffic are relaying over these DERP TCP connections, there is a higher potential for [head-of-line blocking](https://en.wikipedia.org/wiki/Head-of-line_blocking)-and in the extreme case: a [TCP meltdown](https://en.wikipedia.org/wiki/Tunneling_protocol#TCP_meltdown_problem).

3.  This packet blocking can occur with greater likelihood and impact on a network that consists of nodes with traffic aggregation and forwarding like subnet routers and exit nodes.


The preferred and recommended approach is to use direct peer-to peer connections rather than DERP relay connections for these key nodes. Removing the Hard NAT will address the underlying and contributing factors. Change it to a no NAT (directly accessible) or [easy NAT](https://tailscale.com/kb/1411/device-connectivity#easy-nat) configuration.

However, if removing the Hard NAT on the connector is not an option, you can attempt to minimize the contributing factor of packets blocked by shared traffic. One approach is to isolate latency-sensitive services behind separate subnet routers. Another approach would be to host latency-sensitive services on their own nodes without a subnet router in front of them.

### [IP forwarding errors when using `advertise-routes`](#ip-forwarding-errors-when-using-advertise-routes)

Tailscale's routing features ([subnet routers](https://tailscale.com/kb/1019/subnets) and [exit nodes](https://tailscale.com/kb/1103/exit-nodes)) require IP forwarding to be enabled. If it is not enabled, you may encounter an error when using `--advertise-routes` or `--advertise-exit-node`.

To learn how to do this for your Linux device, refer to [how to enable IP forwarding](https://tailscale.com/kb/1019/subnets#enable-ip-forwarding).

### [IP routes that Tailscale installs](#ip-routes-that-tailscale-installs)

As of v0.99, Tailscale routes moved into a separate routing table (to prevent routing loops in [subnet routers](https://tailscale.com/kb/1019/subnets)), which the legacy `netstat` tool doesn't display.

To review routes installed by Tailscale use `ip route` instead, use the following command:

```shell
ip route show table 52
```

### [LAN traffic prioritization with overlapping subnet routes](#lan-traffic-prioritization-with-overlapping-subnet-routes)

You may have a LAN subnet that contains a mix of both Tailscale devices, and non-Tailscale devices that all must accept routes to communicate with a second subnet. In this condition routing can become asymmetric leading to new configuration challenges. To work around this challenge, there are different solutions depending on the operating system of the affected device.

Using the solutions described below on non-fixed network interfaces, such as Wi-Fi, on a laptop could lead to a situation where the device sends traffic to a public LAN network that was intended for the Tailscale network. We recommend that these solutions only be used where the network configurations of the subnets and devices that access them are well known and fixed.

On both Windows and macOS, routes are accepted by default. The operating system will prioritize routes with the longest prefix match, or in other words the most specific of all configured routes. A solution for overlapping subnet routers is therefore to adjust the Tailscale advertised route to be less specific than the LAN subnets that you wish to avoid routing conflicts with. If for example, you have a LAN subnet of `192.168.2.0/24` and you wish to avoid routing traffic to that subnet through Tailscale when devices are on this LAN segment, you can configure the subnet router to advertise a route of `192.168.2.0/23`.

On Linux, the `--accept-routes` flag must be passed explicitly to `tailscale up` to accept subnet routes from other devices in the tailnet. Tailscale on Linux uses a routing feature known as policy routing that introduces an additional layer of prioritization to routing.

Tailscale uses IP rules in the priority range of `5200` to `5500` to prioritize routes, at this time 5210, 5230, 5250 and 5270.

On OpenWRT systems detected as running mwan3, Tailscale rules are installed at a lower priority for compatibility reasons. On such systems, IP rules are installed with priorities ranging between `1300`-`1400` instead of `5200`-`5300`.

Install a rule ahead of the Tailscale rules that uses `lookup` to jump over them:

```shell
ip rule add to 192.168.2.0/24 priority 2500 lookup main
```

The above command installs a rule that matches traffic destined for `192.168.2.0/24` in a rule with priority `2500` (a higher priority than the Tailscale rules). When matched, the rule jumps to the `main` routing table, which is the default routing table. This rule will therefore take precedence over the Tailscale rules, and use the regular LAN routes in the main routing table.

Note that this change is not persistent, and will need to be applied on boot. `systemd-networkd` users may look to the `RoutingPolicyRule` configuration option in `systemd.network(5)`. The configuration can also be applied in a "oneshot" service as described in `systemd.service(5)`.

### [Multiple devices have the same 100.x IP address](#multiple-devices-have-the-same-100x-ip-address)

This can occur if you use a backup of one device to create another, or clone a file system from one device to another. The Tailscale configuration files are duplicated. The Tailscale files will need to be removed from one of the two.

You can identify duplicated devices in the [Machines](https://login.tailscale.com/admin/machines) page of the admin console by looking for a **Duplicate node key** badge underneath the device name.

On one of the systems, [uninstall and _completely_ delete](https://tailscale.com/kb/1069/uninstall) the Tailscale app. It is especially important to remove the files listed for your platform, the goal is to make a new Tailscale IP address when it is installed again. Then, [reinstall the app](https://tailscale.com/kb/install).

### [Network traffic examination inside an encrypted tunnel](#network-traffic-examination-inside-an-encrypted-tunnel)

It is sometimes useful to be able to inspect the unencrypted packets inside the WireGuard tunnel using tools like Wireshark. This can only be done from one of the devices at the endpoints of the tunnel, packets captured in flight from the network can not be decrypted.

From the devices at the endpoints of the tunnel there are several ways to accomplish this:

1.  `tailscale debug capture -o /path/to/capture.pcap`
2.  Run Wireshark on the tun device (does not work in userspace-networking mode).

With `tailscale debug capture` the `-o /path/to/capture.pcap` argument specifies the name of a file to write packets to. If omitted, Tailscale will attempt to start Wireshark locally for a live capture. These `pcap` files are captured with a header of metadata about the tailnet. To inspect them in Wireshark you must install a [Lua dissector](https://raw.githubusercontent.com/tailscale/tailscale/refs/heads/main/feature/capture/dissector/ts-dissector.lua).

To capture from a tun device one starts Wireshark and has it capture from:

1.  `tailscale0` for Linux and Windows systems.
2.  `utun#` on macOS, where the number can vary. Wireshark will show a list of interfaces, and one of the `utun` interfaces should show some traffic.

Wireshark 3.65 or later support capturing Wireshark frames from TUN devices.

### [Route all traffic through a default route](#route-all-traffic-through-a-default-route)

On Tailscale, you can define an [exit node](https://tailscale.com/kb/1103/exit-nodes), which automatically configures default routes on your behalf.

If you want to force your traffic through a particular IP (to handle an IP blocklist or IP allowlist) you can also route only a subset of your traffic using subnets. Refer to [Connecting to external services with IP blocklists using Tailscale](https://tailscale.com/kb/1059/ip-blocklist-relays) for more information.

### [SoraCOM issues](#soracom-issues)

Tailscale can work on SoraCOM but not with the ISP's DNS servers. We recommend enabling the **Override DNS servers** toggle on the [DNS](https://login.tailscale.com/admin/dns) page of the admin console.

### [Sunrise Communications issues](#sunrise-communications-issues)

It appears that Sunrise Communications is blocking the Tailscale service.

Specifically, Tailscale has been (incorrectly) flagged by Sunrise's [Surf Protect](https://www.sunrise.ch/en/residential/mobile/freedom/options/surf-protect1/surf-protect-home.html) as a potentially malicious application.

To use Tailscale, you'll need to work with Sunrise support:

-   Find your Sunrise site ID.
-   Contact Sunrise support at [Sunrise support](https://www.sunrise.ch/en/residential/help/kontakt.html), and ask that `*.tailscale.com` and `*.tailscale.io` be added to the exclusion list for your Surf Protect subscription. Alternately if desired, you could remove Surf Protect from your account.

### [Tally ERP issues](#tally-erp-issues)

Tally appears to bind to interfaces in a way which conflicts with VPN software like Tailscale. If the license server is running on the local device, fix this by changing the Tally configuration through the UI or by editing `Tally.ini` to use `127.0.0.1:9999` as the license server instead of using the PC hostname.

### [TCP connection issues between two devices](#tcp-connection-issues-between-two-devices)

If your devices are visible in the admin console, and there is no [access rule](https://tailscale.com/kb/1337/policy-syntax#acls) blocking connections between the devices, check the level of connectivity with Tailscale's three types of `ping`:

-   `ping 100.x.x.x` tells the OS to send an ICMP ping across the tailnet.
-   `tailscale ping 100.x.x.x` tests whether the two `tailscaled` processes can communicate at all, and how (direct, or relayed).
-   `tailscale ping --tsmp 100.x.x.x` sends a packet that goes one level further than `tailscale ping`, also going through the WireGuard level, but doesn't involve the host's networking stack.

Packet size limits can also cause connection problems on certain types of networks.

Tailscale uses a maximum transmission unit (MTU) of `1280`. If there are other interfaces which might send a packet larger than this, those packets might get dropped silently. These can be verified by using `tcpdump`.

To solve this, we can set the MTU at the LAN level to a lower value, or use MSS (maximum segment size) clamping.

### [Tailscale domains and sites are unreachable](#tailscale-domains-and-sites-are-unreachable)

If your network and internet connectivity are working as expected, but you cannot reach any of the Tailscale sites, including our corporate site, documentation, and admin console, this may be because we were erroneously added to an internet blocklist. To prevent temporary DNS blocking to our sites, we recommend adding the following entries to your DNS service allowlists.

```shell
*.tailscale.com
*.tailscale.io
```

We support a wide variety of DNS services, including [Control D](https://tailscale.com/kb/1403/control-d), [Linux DNS](https://tailscale.com/kb/1188/linux-dns), [NextDNS](https://tailscale.com/kb/1218/nextdns) and [Unbound DNS in OPNsense](https://tailscale.com/kb/1299/opnsense-unbound).

## [Containers](#containers)

### [Kubernetes issues](#kubernetes-issues)

Refer to [Troubleshooting the Kubernetes operator](https://tailscale.com/kb/1446/kubernetes-operator-troubleshooting) for troubleshooting guidance.

### [Proxmox issues](#proxmox-issues)

Refer to [Tailscale on a Proxmox host](https://tailscale.com/kb/1133/proxmox#troubleshooting) for troubleshooting guidance.

## [General](#general)

### [Antivirus flagging](#antivirus-flagging)

The Tailscale client can be falsely flagged by antivirus software, especially with new releases, because many antivirus engines use machine learning and other automated tools that can result in false positives. Refer to the topic [Antivirus flagging of the Tailscale client](https://tailscale.com/kb/1477/av-flagging) to learn what to do when Tailscale is being flagged by antivirus software and how to report legitimate concerns.

### [Captive portal notifications](#captive-portal-notifications)

When you connect to a public network, you might be redirected to a [captive portal](https://en.wikipedia.org/wiki/Captive_portal) requiring you to authenticate or accept terms before accessing the internet. Refer to [Using Tailscale with captive portals](https://tailscale.com/kb/1457/captive-portals) for troubleshooting guidance.

### [Client bug reports](#client-bug-reports)

You can [generate a bug report](https://tailscale.com/kb/1227/bug-report) or export a Configuration Report from within the Tailscale client, that you can send to us to help you troubleshoot issues more effectively. Exporting a configuration report is only available on macOS.

### [Client download issues](#client-download-issues)

If you are experiencing issues downloading the Tailscale client to your device, it may be due to one of the following reasons:

-   **Device OS version needs updating**. Update your device to the latest OS version if possible. While we support some older OS versions, we recommend using the latest.
-   **Download occurred without notification**. Check your default download folder.
-   **Network or internet connection failed during download**. Check your connection and retry the download.
-   **Network policies prevent downloading**. Contact the IT administration in your organization for guidance, if you suspect that this is the issue.
-   **Storage capacity on the device is exceeded**. Clear space on your device to allow the download.
-   **Virus scanner is preventing the download**. Configure the virus scanner to allow downloads from `tailscale.com`.
-   **Web browser pop-up blocker is preventing downloads**. Disable the pop-up blocker or configure it to allow downloads from `tailscale.com`.

### [Debug menu and options](#debug-menu-and-options)

The macOS and Windows versions of the Tailscale client contain a debug mode of the menu that provides advanced settings for monitoring and troubleshooting.

[macOS](https://tailscale.com/kb/1023/troubleshooting?tab=macos)[Windows](https://tailscale.com/kb/1023/troubleshooting?tab=windows)

To access the debug options on macOS, hold down Option and select the Tailscale icon in the menu bar. Available options include:

-   Sent and received traffic information.
-   Device key expiry information.
-   The **Debug** menu provides the following options:
    -   **Bug report**: [Generates a bug report ID and a configuration report](https://tailscale.com/kb/1227/bug-report) that you can send to us to help you troubleshoot issues more effectively.
    -   **Reauthenticate**: Logs the user out of the tailnet, requiring them to re-authenticate from the Tailscale [Login](https://login.tailscale.com/login) page.
    -   **Reset All Settings**: Sets the client settings back to default while keeping the user logged in.
    -   **Show Onboarding**: Displays the walk-through onboarding screens that a user typically sees when they first install the client.
    -   **Flush DNS Cache**: Clears the macOS DNS cache. This requires administrative credentials.
    -   **Add Account**: Displays a dialog for adding the client to a custom coordination server.
    -   **System Extension**: Displays the health of the Tailscale system extension. You can also use the [`tailscale configure sysext status`](https://tailscale.com/kb/1080/cli#configure) CLI command.
    -   **Reset**: Deletes and reinstalls the macOS VPN configuration. Using this option may be helpful if Tailscale refuses to start even after rebooting your Mac. This option won't work if your organization is deploying a VPN configuration profile on your Mac using an MDM solution.
-   **Quit (Leave VPN Active)**: Terminates the Tailscale GUI app, but leaves the VPN network extension running in the background. If you use this option, you may then separately toggle the network extension in the macOS System Settings app.

If you use [Group Policy](https://learn.microsoft.com/en-us/windows-server/identity/ad-ds/manage/group-policy/group-policy-overview) or an [MDM solution](https://tailscale.com/kb/1362/mdm) to manage your fleet of devices, you can [control the visibility of the Debug menu](https://tailscale.com/kb/1315/mdm-keys#hide-the-debug-menu).

### [Device connectivity issues](#device-connectivity-issues)

Refer to [Troubleshooting device connectivity](https://tailscale.com/kb/1411/device-connectivity) for troubleshooting guidance.

### [Interoperability with other software](#interoperability-with-other-software)

Tailscale tries to cooperate and run alongside other software on your device, but sometimes that's not possible. Some operating systems impose limitations on how many VPN-type programs can run at once or register with certain OS-level facilities, and sometimes other software accidentally or by design breaks Tailscale.

When debugging issues where Tailscale doesn't work, we generally start by trying to identify how your device or network is different and what other software you're running on the device that's apparently conflicting. Here are some general questions to consider:

-   Are you running any other networking, VPN, endpoint security, antivirus, virtualization or other security software?
-   Any security proxy on the network/router?

A non-exhaustive list of other software that may or may not cause problems, depending on OS/versions/configs:

-   Apple Private Relay
-   [Apple Screen Time (or any other macOS content filters)](https://tailscale.com/kb/1420/macos-webproxyfilterd)
-   Avast
-   Clash, ClashX, Clash Pro X
-   Cloudflare Warp
-   CrowdStrike Falcon
-   Docker Desktop
-   FortiClient
-   GlobalProtect VPN
-   Little Snitch
-   McAfee LiveSafe
-   Mullvad
-   Netskope
-   PIA
-   TunnelBear
-   Tunnelblick
-   VMWare Carbon Black
-   Webroot
-   WireGuard
-   VirtualBox
-   VMWare
-   WSL
-   ZeroTier

Let us know if you're running one of those, or similar programs. On some operating systems Tailscale is not even able to detect the presence of those programs due to sandboxing. If you let us know what you're running, we might be able to advise you on how to configure things to work.

If your device was supplied by your employer, it's very likely not "just a stock macOS install" or "just a stock Windows install" and it's quite likely to be running other software.
```



### File: 1028-key-expiry.md

```markdown
# Key expiry

As a security feature, users need to periodically reauthenticate on each of their devices. The default expiration period depends on your domain setting. By default, new domains are set with an expiry period of 180 days.

If reauthentication does not occur, keys expire and connections to/from the given endpoint will stop working.

## [Disabling key expiry](#disabling-key-expiry)

Disabling key expiry is available for [all plans](https://tailscale.com/pricing).

You may want to disable key expiry on some devices, such as trusted servers, [subnet routers](https://tailscale.com/kb/1019/subnets), or remote IoT devices that are hard to reach.

1.  Open the [Machines](https://login.tailscale.com/admin/machines) page of the admin console.
2.  Find the row corresponding to the device you are interested in.
3.  Select the ![ellipsis icon](/files/images/icons/fa-ellipsis-h.svg) menu at the far right and select the **Disable Key Expiry** option:

    ![](/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fdisable-key-expiry.4683b4d2.png&w=1200&q=75)

4.  Done. The keys for that device will no longer expire.

## [Enabling key expiry](#enabling-key-expiry)

Enabling key expiry is available for [all plans](https://tailscale.com/pricing).

1.  Open the [Machines](https://login.tailscale.com/admin/machines) page of the admin console.
2.  Find the row corresponding to the device you are interested in.
3.  Select the ![ellipsis icon](/files/images/icons/fa-ellipsis-h.svg) menu at the far right and select the **Enable Key Expiry** option:
4.  Done. The keys for that device are now set with an expiration.

## [Renewing keys for an expired device](#renewing-keys-for-an-expired-device)

If keys expire for a device, connections to/from the given endpoint will stop working. For devices that have the [Tailscale CLI](https://tailscale.com/kb/1080/cli), running [`tailscale up --force-reauth`](https://tailscale.com/kb/1241/tailscale-up) (using `sudo` if needed) will renew the keys.

Be aware that `tailscale up --force-reauth` might bring down the tailnet connection and thus should not be done remotely over SSH or RDP without an alternate means to log in if the connection is lost.

However, for remote devices that you've [restricted to Tailscale-only traffic](https://tailscale.com/kb/1077/secure-server-ubuntu), signing in again without Tailscale access can be difficult or impossible. In these cases, we allow admins of a network to temporarily extend a key's lifetime to help the device owner regain access and reauthenticate.

To regain access to an expired device:

1.  Open the [Machines](https://login.tailscale.com/admin/machines) page of the admin console.
2.  Find the row corresponding to the device you are interested in.
3.  Select the ![ellipsis icon](/files/images/icons/fa-ellipsis-h.svg) menu at the far right and select the **Temporarily extend key** option. This option only appears for devices with expired keys:

    ![](/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fextend-key-expiry.1426d027.png&w=1200&q=75)

4.  The key will be extended for 30 minutes. Instruct the owner of the machine to log in and reauthenticate within the extended timeframe, or disable key expiry for this device within that window.
5.  Once the machine has been reauthenticated, the key should be renewed for your standard expiry time (6 months by default).

If you're renewing keys for a machine that belongs to you, and it has already signed a new authentication URL, we provide a one-select **Reauthenticate** option in place of **Temporarily extend key**. However, extending the key is the far more common way to regain access.

## [Using key expiry with tagged devices](#using-key-expiry-with-tagged-devices)

When you apply a tag to a device for the first time and authenticate it, the tagged device will have [key expiry](https://tailscale.com/kb/1028/key-expiry) disabled by default. For more details, see [Key expiry for tagged devices](https://tailscale.com/kb/1068/tags#key-expiry).

## [Setting a custom authentication period](#setting-a-custom-authentication-period)

Setting a custom authentication period is available for [all plans](https://tailscale.com/pricing).

1.  Open the [Device management](https://login.tailscale.com/admin/settings/device-management) page of the admin console.
2.  In the **Key Expiry** section, select from 1 to 180 days as the custom authentication period.
3.  Select **Save**.

A change to the **Key Expiry** value applies to any devices that are logged in after you make the change. The key expiration for any devices that are already logged in remains unchanged, until the next time the device is logged in.

## [Admin console session expiry](#admin-console-session-expiry)

A browser session that is accessing the Tailscale [admin console](https://login.tailscale.com/admin) has an expiry of 30 days. This expiry is unrelated to any key expiry. For more details, see the topic [Do admin console sessions expire?](https://tailscale.com/kb/1321/admin-console-session-expiry)
```



### File: 1054-dns.md

```markdown
# DNS in Tailscale

Managing DNS is available for [all plans](https://tailscale.com/pricing).

Tailscale provides each device on your Tailscale network (known as a tailnet) with [a unique IP address](https://tailscale.com/kb/1033/ip-and-dns-addresses) that stays the same no matter where your devices are. However, IP addresses aren't very memorable, and can be unwieldy to work with. You can map [Tailscale IP addresses](https://tailscale.com/kb/1015/100.x-addresses) to human-readable names using DNS.

## [Manage DNS in Tailscale](#manage-dns-in-tailscale)

Clients must be configured to [use Tailscale DNS settings](https://tailscale.com/kb/1072/client-preferences#use-tailscale-dns-settings) for the settings on this page to take effect.

You can manage DNS for your tailnet using [MagicDNS](#magicdns), your [tailnet DNS settings](#tailscale-dns-settings), or [public DNS records](#public-dns-records). You can also use the [`tailscale dns`](https://tailscale.com/kb/1080/cli#dns) command.

### [MagicDNS](#magicdns)

You can leverage Tailscale's **MagicDNS** feature, which is enabled by default, to automatically assign DNS names for devices in your tailnet.

The MagicDNS setting determines whether your tailnet uses [MagicDNS](https://tailscale.com/kb/1081/magicdns) to automatically assign DNS names to devices in your tailnet. MagicDNS is optional and not required to use other DNS settings.

It's not possible to add arbitrary records to MagicDNS. Subscribe to or comment on [this GitHub issue for updates](https://github.com/tailscale/tailscale/issues/1543).

[Read more about MagicDNS →](https://tailscale.com/kb/1081/magicdns)

### [Tailscale DNS settings](#tailscale-dns-settings)

You can manage the DNS settings for your tailnet from the [DNS](https://login.tailscale.com/admin/dns) page of the admin console. This includes settings for [MagicDNS](#magicdns), nameservers, and search domains.

![The DNS page of the admin console with the sections for MagicDNS and nameservers.](/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fdns-settings.e3683d16.png&w=1200&q=75)

#### [Nameservers](#nameservers)

Nameservers are the IPv4 or IPv6 addresses of the DNS servers you want devices to use when connected to your tailnet. You can use public nameservers or private name servers that include mappings for devices in your private network.

There are two types of nameservers: [restricted nameservers](#the-order-of-dns-resolvers) and [global nameservers](#global-nameservers).

##### [Restricted nameservers](#restricted-nameservers)

A restricted nameserver only applies to DNS queries matching a specific search domain. Using a restricted nameserver is also known as split DNS.

An example of a split DNS scenario would be if you configure `1.1.1.1` as a nameserver for the domain `example.com`. This tells devices in your tailnet to only use the `1.1.1.1` name server to look up DNS queries that match `*.example.com` (such as `foo.example.com` and `bar.example.com`).

##### [Global nameservers](#global-nameservers)

A global nameserver handles DNS queries for any domain. You can use a public DNS nameserver or run your own that to include additional DNS mappings.

When you use a public global nameserver, such as Cloudflare or Google, Tailscale automatically uses DNS-over-HTTPS (DoH) to ensure your DNS queries are encrypted before traversing the internet.

Some [public global DNS nameservers](https://en.wikipedia.org/wiki/Public_recursive_name_server) include:

-   [Quad9](https://www.quad9.net/service/service-addresses-and-features): `9.9.9.9`, `149.112.112.112`, `2620:fe::fe`, and `2620:fe::9`.
-   [Google](https://developers.google.com/speed/public-dns/docs/using): `8.8.8.8`, `8.8.4.4`, `2001:4860:4860::8888`, and `2001:4860:4860::8844`.
-   [Cloudflare](https://www.cloudflare.com/learning/dns/what-is-1.1.1.1): `1.1.1.1`, `1.0.0.1`, `2606:4700:4700::1111`, and `2606:4700:4700::1001`.

You can also set a personalized DNS nameserver, such as [NextDNS](https://tailscale.com/kb/1218/nextdns) or [Control D](https://tailscale.com/kb/1403/control-d), as your global nameserver. These nameservers are available when you add a nameserver using the [DNS](https://login.tailscale.com/admin/dns) page of the admin console.

Tailscale considers each global DNS nameserver's list of addresses as one entity. For example, if you add one of Google's nameservers, Tailscale automatically includes all of Google's nameserver addresses. This is true whether you add the addresses manually or through the [DNS](https://login.tailscale.com/admin/dns) page of the admin console.

![The DNS page of the admin console with the section for Nameservers. The 'Add nameservers' dropdown listing public global DNS options.](/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fnameserver-dropdown.84508d2f.png&w=640&q=75)

It's best practice to use more than one global nameserver (which can be from the same provider) to ensure redundancy. However, keep in mind that using multiple global nameservers can bypass explicit content restrictions if they aren't the same across all the nameservers.

By default, your tailnet's devices use their local DNS settings for all queries. To force clients to always use the nameservers you define, you can enable the **Override DNS servers** toggle.

Unless your nameservers are public, or using [Tailscale IP addresses](https://tailscale.com/kb/1033/ip-and-dns-addresses), you probably need to configure [subnet routing](https://tailscale.com/kb/1019/subnets) to allow your devices to reach the private DNS servers.

##### [Nameservers and exit nodes](#nameservers-and-exit-nodes)

By default, when you configure a device to use an exit node, the device also uses the exit node as a DNS resolver for all domains, regardless of configuration of global and restricted (split DNS) nameservers.

You can override this behavior per nameserver through the admin console by configuring the nameserver to be included when devices are using an exit node.

To include a nameserver in DNS resolution for devices using an exit node:

1.  Go to the [DNS](https://login.tailscale.com/admin/dns) of the admin console.
2.  Locate the **Nameservers** section, then select the three dots next to the nameserver to enable. This opens the **Edit nameserver** options.
3.  Enable the **Use with exit node** setting.
4.  Select **Save**.

You can also enable this setting when adding a nameserver through the **Add nameserver** dialog.

#### [Search domains](#search-domains)

Only devices running Tailscale v1.34 or later can use search domains.

Search domains provide a convenient way for users to access local network resources without having to specify the full domain path every time they connect to a resource. A user can specify a list of domain suffixes that are automatically appended to any domain name that is not a fully qualified domain name (FQDN).

For example, if a tailnet has `example.com` and `test.com` configured as search domains, and a user enters the phrase `server`, Tailscale uses the phrase to search for `server.example.com` against the tailnet's configured nameservers (such as `8.8.8.8` or `1.1.1.1`). If no match is returned, it searches for `server.test.com` against the tailnet's configured nameservers.

![The DNS page of the admin console with the Search Domains section. Listing several example domains.](/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fsearch-domains.6f696d46.png&w=1200&q=75)

-   When [MagicDNS](#magicdns) is enabled, it is always the first domain in the **Search Domains** list. This is not configurable by a user.
-   You can add, reorder, modify, and remove your search domains.

Previous versions of the [DNS](https://login.tailscale.com/admin/dns) page of the admin console allowed you to define search domains separately from nameservers. However, due to cross-platform compatibility reasons, this is no longer possible. To define a search domain, you must add at least one nameserver along with it. If you don't have a preference, Tailscale recommends using [well-trusted public DNS nameservers](https://www.lifewire.com/free-and-public-dns-servers-2626062) alongside your search domain.

### [Public DNS records](#public-dns-records)

If you prefer not to manage DNS settings through the admin console, you can instead publish records on your public-facing DNS server if you have one. The DNS names can be looked up (converted to a private IP address) by anyone on the internet, but because [Tailscale IP addresses](https://tailscale.com/kb/1015/100.x-addresses) are only accessible to users of your network, this is relatively harmless.

Almost every organization already has a public DNS server for routing email and publishing a website, so this is easier than setting up an internal private DNS server.

Tailscale does not offer a DNS server, so you need to use one you run yourself or one offered by your cloud, domain host, or DNS provider.

Public DNS names might take a while to propagate after you add them.

## [Test DNS configurations](#test-dns-configurations)

Traditionally, network admins use tools like `nslookup` to review DNS responses for various domains. However, on some platforms, `nslookup` doesn't use DNS information provided by the operating system, and returns incorrect results. You'll likely notice this issue when using split DNS or MagicDNS, which rely on advanced DNS features.

To test DNS settings on different platforms, Tailscale recommends the following approaches:

[macOS](https://tailscale.com/kb/1054/dns?tab=macos)[Windows](https://tailscale.com/kb/1054/dns?tab=windows)[Linux](https://tailscale.com/kb/1054/dns?tab=linux)

Use the native `dscacheutil` command:

```shell
dscacheutil -q host -a name <domain-or-magic-dns-hostname>
```

For example, searching for the IP address for a MagicDNS hostname returns:

```shell
$ dscacheutil -q host -a name my-server

name: my-server.example.ts.net
ip_address: 100.15.193.72
```

## [Override DNS servers](#override-dns-servers)

By default, devices in your tailnet prefer their local DNS settings and only use the tailnet's DNS servers when needed. However, you might want to prevent devices in your tailnet from using their local DNS settings. For example, you might want to:

-   Ensure devices have access to private DNS records.
-   Prevent devices from using untrusted nameservers.
-   Require all traffic to go through a specific DNS server that filters traffic.

Tailscale lets you force any device in your tailnet to use your tailnet DNS settings instead of its local DNS settings. To force tailnet devices to use the tailnet-defined DNS settings, enable **Override DNS servers**. When enabled, devices connected to your tailnet ignore their local DNS settings and always use the global nameservers defined for the tailnet.

To override DNS server settings:

1.  Go to the [DNS](https://login.tailscale.com/admin/dns) page of the admin console.
2.  Under **Global nameservers**, enable **Override DNS servers**.

Make sure all devices in your tailnet have access to your global nameservers before you force them to use the tailnet DNS settings. If an [ACL](https://tailscale.com/kb/1018/acls) or [grant](https://tailscale.com/kb/1324/acl-grants) prevents a device from accessing the global nameserver for the tailnet, the device won't be able to resolve DNS queries.

## [The order of DNS resolvers](#the-order-of-dns-resolvers)

You might expect to be able to give an operating system a list of DNS nameservers in order, and that operating system will try each of those nameservers in sequence to find a given domain.

However, as increasingly more systems and software applications require a connection to the internet to function, even small delays or rare hiccups in DNS lookup can result in a degraded user experience. In response, many modern operating systems have adopted more complicated rules for how to optimize response time when multiple DNS nameservers are available.

For example, operating systems might:

-   Query nameservers in order, with small delays in between each attempt.
-   Query all nameservers in parallel.
-   Change the order of nameservers based on past performance.
-   Change the order of nameservers based on known geographic proximity.
-   Load balance queries between nameservers.

Because each operating system handles resolver ordering a little differently, Tailscale cannot guarantee that the DNS resolvers you add to the [DNS](https://login.tailscale.com/admin/dns) page of the admin console will be queried in the exact order that you've specified. Depending on your DNS settings and your operating system, Tailscale either proxies all DNS requests (in which case Tailscale queries all nameservers in parallel and uses the quickest response) or defers to the operating system.

If you need nameservers to be in a specific order because you expect one of them (such as a private DNS service you run) to have different responses than the others. In that case, you're probably better off using the [split DNS feature](#restricted-nameservers) or setting up conditional forwarding on your private DNS service and only using that resolver in your settings.
```



### File: 1059-ip-blocklist-relays.md

```markdown
# Connect to external services with IP block lists

If you're migrating from a traditional office network or a centralized VPN concentrator, you might have external servers that don't run Tailscale but still need their connections secured.

Third-party or internal services running on [serverless](https://tailscale.com/kb/1364/serverless) cloud providers such as Heroku might use an IP block list (sometimes called an IP allowlist). When a service uses an IP block list, the service expects all user traffic to originate from a single IP address or a few IP addresses. Because Tailscale doesn't need to send all traffic through a central concentrator, your user traffic will suddenly start arriving from all over the internet, running into the IP block list protections operated by your service provider.

## [What is an IP block list?](#what-is-an-ip-block-list)

Setting up secure links between devices in different locations often proves challenging. As a result, it's common to operate "internal use" services that still use internet-facing ports and IP addresses between devices in different locations and connect to those servers from their office locations. This is common with SSH, RDP (remote desktop protocol), and various web services.

The exposed port allows attacks from anywhere on the internet, including attacks such as port scanning, password guessing, infrastructure zero-days, and so on. Even if the service itself requires [encryption](https://tailscale.com/kb/1504/encryption) and multifactor authentication, a bug anywhere in the stack could result in a complete bypass of security protections.

To make these kinds of attacks harder, the best practice is to restrict which IP addresses are allowed to initiate connections to your service, usually at the firewall level. This makes your server invisible to most of the internet, so potential malicious actors don't know where to attack.

Unfortunately, IP block lists have a few flaws:

-   IP block lists are, essentially, [_security by obscurity_](https://en.wikipedia.org/wiki/Security_through_obscurity). If an attacker can learn which IP addresses are allowed to initiate connections-and this is not always too hard to guess-then a sufficiently dedicated attacker can forge packets from that address or take control of a device located at that address (for example, using a botnet), to talk to the server.

-   Users are not all at a single location. Remote workers, multiple offices, or servers in various data centers generate traffic from different IP addresses. IP block lists need to become longer and longer to ensure that all those locations can access the service. And the longer the block list, the more ways an attacker can get in.

-   Cloud VPCs make IP address propagation even worse. If you have internal services running in a cloud provider that accesses the internet using NAT gateways and elastic IP addresses, then your traffic might come from a variety of IP addresses, possibly entire subnets. This can require an extensive IP block list to cover, for example, whole AWS address blocks, just in case your services get allocated one of those blocks. This makes an attacker's job much easier because all they need to do is run their attack from one of those cloud providers and wait until they get allocated an IP address in one of your permitted subnets.

-   To avoid this problem, some companies route all their internal traffic through a single VPN concentrator or central internet gateway, making all traffic appear to come from a single IP address. However, this approach adds a lot of latency for devices not near the central gateway (geographically). It also adds a single point of failure and a choke point for internet bandwidth.


Nevertheless, IP block-listed services are a fact of life. If you can't make a secure VPN tunnel to your service provider, for example, because you don't have the rights to install any software at the hosting provider or because a third party operates the software, IP block lists are still considered the best practice (in addition to other [security measures](https://tailscale.com/kb/1196/security-hardening)).

## [Use Tailscale app connectors to improve IP block lists](#use-tailscale-app-connectors-to-improve-ip-block-lists)

In a pure [Tailscale network](https://tailscale.com/kb/1136/tailnet), you don't need IP block lists because you have something better: [Tailscale's secure IP addresses](https://tailscale.com/kb/1015/100.x-addresses), which aren't allowed over the physical network. You also have [Tailscale role-based access control policies](https://tailscale.com/kb/1393/access-control), which let you configure which groups of users are allowed to access a particular server. This lets you build something like a central IP block list, using encryption keys instead of IP addresses for protection.

However, most networks are not pure Tailscale, and you eventually need to integrate with a third-party service. Luckily, Tailscale can help you significantly reduce the size of your IP block list (and consequently the surface area for attack) without centralizing your network access. This approach also lets your users access the service from anywhere.

To use Tailscale to improve IP block lists, set up an [app connector](https://tailscale.com/kb/1281/app-connectors) to route traffic for a specific application through a single IP address. This IP address is the only one that needs to be on the IP block list. The app connector acts as a subnet router, providing access to the external service from your Tailscale network.

You can also use a small collection of IP addresses and manage them in your tailnet policy file with an [IP set](https://tailscale.com/kb/1387/ipsets).
```



### File: 1068-tags.md

```markdown
# Group devices with tags

Tags are available for [all plans](https://tailscale.com/pricing).

Tailscale tags are how you authenticate and identify non-user devices, such as servers and [ephemeral nodes](https://tailscale.com/kb/1111/ephemeral-nodes). They serve two primary purposes: to provide an identity to non-user devices and to let you manage [access control policies](https://tailscale.com/kb/1393/access-control) based on _purpose_. In this context, a purpose could be anything from hosting a web server to serving as a [subnet router](https://tailscale.com/kb/1019/subnets) for employees in a specific geographic location.

Tags are essentially service accounts, but with more flexibility⎯you can assign multiple tags to a device to account for multiple purposes. For example, you might have a device that runs a PostgreSQL database and serves as a web server for internal access. In such a scenario, you could assign the device the following tags (each of which you could target individually using access control policies): `tag:postgresql`, `tag:internal-access`, and `tag:web-server`.

Other key characteristics of tags include:

-   Applying a tag to a device removes any user-based authentication.
-   Each non-user device can have as many tags as you need.
-   Tags are defined in the tailnet policy file in the `tagOwners` section.
-   Only designated tag owners can apply tags to devices; each tag can have as many owners as necessary.

## [Requirements](#requirements)

Tags are a free feature and are available for all pricing plans. However, you must have permission to perform some tag-related operations:

-   You must be an [Owner, Admin, or Network admin](https://tailscale.com/kb/1138/user-roles) of a tailnet to define a tag in the tailnet policy file.
-   You must be a tag owner to assign a tag to a device. [Owner, Admin, or Network admin](https://tailscale.com/kb/1138/user-roles) can apply any tag, even if they don't own the tag.

## [Limitations](#limitations)

Tags have the following limitations and restrictions:

-   You cannot remove all tags from a device. A device with a tag-based identity must have at least one tag.
-   You cannot remove tags using the `--advertise-tags` flag if the device uses an auth key. Instead, generate a new auth key with the latest set of tags.
-   [IP sets](https://tailscale.com/kb/1387/ipsets) do not support tags.
-   Devices with a tag-based identity can only SSH into other tagged devices; they cannot SSH into devices with a user-based identity.
-   Some restrictions exist around using tags to define a group or as the SSH source.

## [Use cases](#use-cases)

Tags are ideal for managing devices you don't want to link to a specific user (such as a server hosting a web application) because removing a user also removes all their devices. If you link a service-providing device to a user, you lose that device if you remove the user. Removing a user won't affect the device if you use tags to manage the device instead. Do not use tags to associate a user device with a user account. Tags are not designed to tie individual users to a device. They're intended to manage devices with service account roles. Using tags as a substitute for users poses a security risk because the user's devices will remain on your network even if you remove the user.

Tags provide a way to allow multiple users to manage a device. When you manage devices with users, you must link each device to a single user, which isn't ideal for devices that host shared resources. However, when you manage devices with tags, you can assign one or more users as tag owners with tags. These users can manage all the devices with the tags they own.

**Warnings about tags**

Only use tags for non-human machines. Users can only access and use Tailscale through their designated user accounts. Using tags to annotate user devices is poor practice because a device cannot simultaneously have a user and a tag. Adding a tag to a device removes the associated user. Devices can have tags or a user account, not both.

Use tags to:

-   Manage devices you don't have tied to a specific user (such as a server hosting a web application).
-   Manage devices you want to allow multiple users to manage.



Do not use tags to:

-   Annotate user devices.
-   Link a user device with a user.
-   Authenticate end-user devices, such as laptops or mobile devices.



## [Ownership](#ownership)

There's no "tag" section of the tailnet policy file. Instead, you define tags by their owners in the `tagOwners` section of the tailnet policy file. Only owners of a tag can apply that tag to devices in your Tailscale network (known as a tailnet). Tag owners can be users, groups, or even other tags, which means you can create complex tag [ownership hierarchies](#advanced-tag-hierarchies).

A tagged device's identity is the combination of all its tags (not the intersection). You can assign any number of tags to a device and manage the permissions for each tag separately. For example, if you have a device with the tags `tag:postgresql`, `tag:prod`, and `tag:ci-cd`, an access control policy for any one of these tags would apply to the device.

[Owner, Admin, or Network admin](https://tailscale.com/kb/1138/user-roles) can apply any tag, even if they aren't tag owners.

## [Tag vs. user authentication](#tag-vs-user-authentication)

Tags are parallel to user authentication. They serve the same role as a user account, except they're intended for service-based devices, such as a web server or an app connector. As a result, it's impossible for a user account identity and a tag identity to exist on the same device. Applying a tag to a device previously authenticated with a user account removes the user account. Similarly, authenticating a device with a user account removes all tags from the device.

Because tags are for non-user devices, they have qualities and limitations that make them unsuitable for authenticating end-user devices, such as a MacBook or a mobile device. For example, devices with a tag-based identity cannot use SSH to connect to a device with a user-based identity.

## [Key expiry](#key-expiry)

When you apply a tag to a device for the first time and authenticate it, the tagged device's key expiry is disabled by default.

If you re-authenticate a device tagged before March 10, 2022, its expiry will be disabled by default.

If you change the tags on the device from the admin console, [Tailscale CLI](https://tailscale.com/kb/1080/cli), or the [Tailscale API](https://tailscale.com/kb/1101/api), the device's key expiry will not change unless you re-authenticate. After you re-authenticate, Tailscale disables the device's key expiry.

You can enable or disable key expiry on a device from the [Machines](https://login.tailscale.com/admin/machines) page of the admin console or by using the Tailscale API.

## [Tags in the Tailscale ecosystem](#tags-in-the-tailscale-ecosystem)

Like many aspects of a tailnet, you can define and manage tags in the tailnet policy file. While limitations prevent you from using them to authenticate end-user devices, they work seamlessly with nearly every other Tailscale feature, including exit nodes, subnet routers, app connectors, access control lists, and grants.

### [Exit nodes](#exit-nodes)

Using a device as an [exit node](https://tailscale.com/kb/1103/exit-nodes) means that other tailnet devices can choose to route all their internet traffic through that device. Routing all traffic through an exit node lets you encrypt internet traffic and access internal networks. For example, you could run a device as an exit node in a corporate office. That way, employees can access the corporate office's internal network when they use that exit node. Although end-user devices can function as exit nodes, it's more common for subnet routers to use a tag-based identity.

### [Subnet routers](#subnet-routers)

A [subnet router](https://tailscale.com/kb/1019/subnets) is a tailnet device you use to advertise subnet routes to the rest of your tailnet. They're a great way to add entire subnets to your tailnet without installing the Tailscale client to any of the devices (except the subnet router). Although end-user devices can function as subnet routers, it's more common for subnet routers to use a tag-based identity.

### [App connectors](#app-connectors)

An [app connector](https://tailscale.com/kb/1281/app-connectors) is a device that routes app-specific traffic in your tailnet. A device running as an app connector is strictly a service-based device. As a result, you must use a tag-based identity to authenticate a device you plan to use as an app connector.

### [Access controls](#access-controls)

You can use tags to select and target service-based devices in your tailnet to create access control policies using ACLs and grants. Because Tailscale can identify tagged devices by any one of their assigned tags, the access control policies that apply to a device with many tags could become complex. As a result, it's best practice to maintain clear documentation of how you leverage and manage tags in your tailnet.

#### [ACLs](#acls)

You can use tags as part of [access control lists (ACLs)](https://tailscale.com/kb/1018/acls) to make it easier to manage which types of devices should be able to communicate. For example, you might use a tag named `tag:prod` for production servers and production databases, then allow all devices with the `tag:prod` tag to communicate with each other.

The following example [tailnet policy file](https://tailscale.com/kb/1155/terminology-and-concepts#tailnet-policy-file) lets all devices tagged `tag:prod` communicate with each other.

```json
{
  "acls": [
    {
      "action": "accept",
      "src": ["tag:prod"],
      "dst": ["tag:prod:*"],
    },
  ],
}
```

You can use the [visual policy editor](https://tailscale.com/kb/1550/visual-editor) to manage your tailnet policy file. Refer to the [visual editor reference](https://tailscale.com/kb/1587/visual-editor-reference) for guidance on using the visual editor.

You can also ensure that the ACLs for your tagged devices work as expected with [tests](https://tailscale.com/kb/1337/policy-syntax#tests), which verify your tailnet policy file before saving and applying it.

For example, to verify that your tailnet policy file lets users in the `tag:sre` group to access devices tagged `tag:prod`, you might write an ACL like the following example:

```json
"tests": [
  {
    "src": "group:sre",
    "accept": ["tag:prod:1234"],
  },
],
```

You can use the [visual policy editor](https://tailscale.com/kb/1550/visual-editor) to manage your tailnet policy file. Refer to the [visual editor reference](https://tailscale.com/kb/1587/visual-editor-reference) for guidance on using the visual editor.

#### [Grants](#grants)

Like ACLs, you can use tags in grants to target a group of tagged devices. The following example grants devices with the `tag:prod` tag access to devices with the `tag:tailsql` tag.

```json
{
  "grants": [
    {
      "src": ["tag:prod"],
      "dst": ["tag:tailsql"],
      "ip": ["*"]
    }
  ]
}
```

You can use the [visual policy editor](https://tailscale.com/kb/1550/visual-editor) to manage your tailnet policy file. Refer to the [visual editor reference](https://tailscale.com/kb/1587/visual-editor-reference) for guidance on using the visual editor.

### [Autogroups](#autogroups)

[Autogroups](https://tailscale.com/kb/1396/targets) are pre-defined groups of devices in your tailnet that would be difficult to create as custom groups. One of these autogroups is `autogroup:tagged`, which selects all devices with a tag-based identity.

You cannot use `autogroup:tagged` to define an IP set or a custom group.

## [Advanced tag hierarchies](#advanced-tag-hierarchies)

Designating tag owners is flexible by design. You can assign as many tag owners as you need to a device, and these tag owners can be users, groups, or other tags. Because you can assign a tag as an owner of another tag, it's possible to create complex hierarchies of tag ownership. As a result, it's best practice to maintain clear documentation of how you use tags and to audit tags using tools such as [access control policy tests](https://tailscale.com/kb/1337/policy-syntax#tests).

## [Best practices](#best-practices)

To leverage tags effectively, consider the following best practices:

-   **Define clear naming conventions for tags**. Ideally, tag names should follow a consistent and descriptive pattern throughout your tailnet. Defining and enforcing a naming convention early on reduces the likelihood of problems such as ambiguous tag names later on. For example, a tag named "foo-bar" doesn't tell you anything about what the tag is intended for, but a tag name "prod-postgresql-server" tells you that the tag is for PostgreSQL servers in a production environment. However, even with descriptive names, it's a good idea to document your organization's tag conventions.
-   **Use auth keys**. By using [auth keys](https://tailscale.com/kb/1085/auth-keys) with pre-assigned tags, you can streamline the process of authenticating and approving tagged devices.
-   **Don't use tags to authenticate user-owned devices**. Tags are intended to authenticate servers and devices that provide a service, which means they have qualities that make them unsuitable for end-user devices, such as a MacBook or an Android phone. Additionally, a device cannot simultaneously use tag-based and user-based identities. Adding a tag to a previously user-authenticated device removes the user's identity.
-   **Carefully consider each tag's owners**. Tags are defined by their owners in the `tagOwners` section of the tailnet policy file. Because of their flexibility and the ability for a tag to own another tag, tags can take on [complex ownership hierarchies](#advanced-tag-hierarchies).

### [Common patterns for tag names](#common-patterns-for-tag-names)

Tags let you reflect access patterns and network segments based on your organization's requirements. These access patterns and network segments usually fall into a few common categories. Use consistent patterns for tag names based on these categories to make your access control policies easier to understand and maintain over time. Some common categories of access to consider in your tag names are:

-   **Server role**: for example, application server, database, or queue.
-   **Application name**: for example, support console, finance reporting, or operations dashboard.
-   **Environment**: for example, production, staging, or development
-   **Location**: for example, Americas, EMEA, South Asia.

While a device can have many tags assigned to it, tags are not "joined" for access rules. For example, you cannot define a rule that permits access to devices with both `tag:prod` and `tag:database`. Instead, you can use a composite tag such as `tag:prod-database` to represent this type of segmented access pattern. Below are some examples of composite tags.

**Tag**

**Access control**

`tag:prod-app`

To production application servers

`tag:nonprod-db`

To non-production database servers

`tag:prod-app-finance-reporting`

To the production finance reporting application

`tag:prod-emea-app-support-console`

To the production support console application in EMEA

`tag:prod-asiasouth-ingest-logging`

To the production logging ingest endpoint in South Asia.

## [Working with tags](#working-with-tags)

Use the following sections to learn about working with tags:

-   [Define a tag](#define-a-tag).
-   [Define tag owners](#define-tag-owners).
-   [Apply tags to a device](#apply-a-tag-to-a-device).
-   [Apply a tag from another tag](#apply-a-tag-from-another-tag).

### [Define a tag](#define-a-tag)

Before assigning a tag to a device, you must create the tag in the [tailnet policy file](https://tailscale.com/kb/1337/policy-syntax) and define who can use that tag to authenticate devices. You create a tag by defining it in the [`tagOwners`](https://tailscale.com/kb/1337/policy-syntax#tag-owners) section of the tailnet policy file.

The following example creates the tag `tag:server` and assigns `dave@example.com` as the sole owner. Only the tag owner can apply the tag.

```json
{
  "tagOwners": {
    "tag:server": ["dave@example.com"], // dave@example.com can authenticate devices with the tag:server tag
  }
}
```

You can use the [visual policy editor](https://tailscale.com/kb/1550/visual-editor) to manage your tailnet policy file. Refer to the [visual editor reference](https://tailscale.com/kb/1587/visual-editor-reference) for guidance on using the visual editor.

Tailscale ignores tag name case and parses all tags in the tailnet policy file as lowercase.

### [Define tag owners](#define-tag-owners)

You must explicitly define who can use a tag to grant its permissions on a device. You can define tag owners in the [`tagOwners`](https://tailscale.com/kb/1337/policy-syntax#tag-owners) section of the tailnet policy file.

A tag can also have an empty list of owners in the tailnet policy file. All tags are implicitly owned by [Owners, Admins, and Network admins](https://tailscale.com/kb/1138/user-roles) of a tailnet. You can apply these tags to devices from the admin console and as part of an [auth key](https://tailscale.com/kb/1085/auth-keys).

The following example shows the `tag:infrastructure` with no tag owners.

```json
{
  "tagOwners": {
    "tag:server": ["dave@tailscale.com"],
    "tag:infrastructure": [], // No tag owners defined
  }
}
```

You can use the [visual policy editor](https://tailscale.com/kb/1550/visual-editor) to manage your tailnet policy file. Refer to the [visual editor reference](https://tailscale.com/kb/1587/visual-editor-reference) for guidance on using the visual editor.

### [Apply a tag to a device](#apply-a-tag-to-a-device)

You can tag devices using the admin console, the [Tailscale CLI](https://tailscale.com/kb/1080/cli), or the Tailscale API.

When you re-authenticate and tag a device, it generates a new [node key](https://tailscale.com/kb/1010/node-keys) for the device. The [Tailscale IP address](https://tailscale.com/kb/1015/100.x-addresses) for the device does not change.

#### [Apply a tag to a device in the admin console](#apply-a-tag-to-a-device-in-the-admin-console)

You must be an [Owner, Admin, or Network admin](https://tailscale.com/kb/1138/user-roles) of a tailnet to tag a device from the [admin console](https://login.tailscale.com/admin). You don't need to re-authenticate because the current user is automatically used to authenticate the device.

To tag a device from the admin console:

1.  Open the [Machines](https://login.tailscale.com/admin/machines) page in the admin console.
2.  Find the row corresponding to the device you are interested in.
3.  Select on the ![ellipsis icon](/files/images/icons/fa-ellipsis-h.svg) menu at the far right, then select the **Edit tags** option.
4.  Add, change, or remove desired tags. To apply a tag, it must already exist in the [tailnet policy file](https://tailscale.com/kb/1155/terminology-and-concepts#tailnet-policy-file).
5.  Select **Save** to apply tags.

[Owners, Admins, and Network admins](https://tailscale.com/kb/1138/user-roles) can apply any tag from the admin console even if they don't own the tag.

You cannot remove all tags from a tagged device in the admin console because the device must have an identity. Either assign the device a new tag or re-authenticate to Tailscale from the device.

#### [Apply a tag to a device with the CLI](#apply-a-tag-to-a-device-with-the-cli)

You can use the [Tailscale CLI](https://tailscale.com/kb/1080/cli) to add and remove tags from devices running Linux, macOS, or Windows. To tag other devices, use the admin console.

To assign tags to a device using the CLI, run `tailscale login` command with the `--advertise-tags=tag:<tag-name>` flag.

```shell
sudo tailscale login --advertise-tags=tag:server
```

To assign multiple tags to a device, pass multiple tags (separated with commas) to the `--advertise-tags` flag.

```shell
sudo tailscale login --advertise-tags=tag:server,tag:development
```

To remove all tags from a device, use the `--advertise-tags=` flag without any values.

```shell
sudo tailscale login --advertise-tags=
```

You cannot remove tags using the `--advertise-tags` flag if the device uses an auth key. Instead, generate a new auth key with the new set of tags.

You might need to change the signed-in user on the device if it's already authenticated with another user. To re-authenticate with the current user, add the `--force-reauth` flag to the command:

```shell
sudo tailscale login --advertise-tags=tag:server --force-reauth
```

#### [Apply a tag to a device using the API](#apply-a-tag-to-a-device-using-the-api)

You can apply a tag to a device using the [Update device tags](https://tailscale.com/api#tag/devices/POST/device/%7BdeviceId%7D/tags) method from the [Tailscale API](https://tailscale.com/kb/1101/api).

To apply a tag this way, send a `POST` request for a device, with the body specifying the desired `tags`. For example:

```shell
curl https://api.tailscale.com/api/v2/device/11055/tags \
-u "tskey-<key>" \
-H "Content-Type: application/json" \
--data-binary '{"tags": ["tag:foo", "tag:bar"]}'
```

### [Apply a tag from another tag](#apply-a-tag-from-another-tag)

You can apply different tags from those in the [auth key](https://tailscale.com/kb/1085/auth-keys) when you authenticate. However, doing so replaces the device's existing tags.

**Important for OAuth authentication**: Tags implicitly own themselves, which lets devices or OAuth clients authenticated with a specific tag apply that same tag to other devices. However, when you define a tag as owned by another tag in the `tagOwners` section, the tag loses its implicit self-ownership. To use an OAuth client to authenticate a device with its own tag when that tag is owned by another tag, you must explicitly add the tag as its own owner in the `tagOwners` section.

Applying a tag from another tag is useful for larger infrastructure deployments, where you might need to tag many servers, typically using a deployment tool. For example, you could have your deployment system tagged with `tag:deployment-1`, which owns both `tag:prod-2` and `tag:test-2`:

```json
  "TagOwners": {
    "tag:deployment-1": ["alice@tailscale.com"],
    "tag:prod-2": ["tag:deployment-1"],
    "tag:test-2": ["tag:deployment-1"],
  },
```

You can use the [visual policy editor](https://tailscale.com/kb/1550/visual-editor) to manage your tailnet policy file. Refer to the [visual editor reference](https://tailscale.com/kb/1587/visual-editor-reference) for guidance on using the visual editor.

In this configuration, `tag:prod-2` loses its implicit self-ownership because `tag:deployment-1` now owns it. If you need an OAuth client with `tag:prod-2` to authenticate devices with the same tag, you must explicitly add self-ownership:

```json
  "TagOwners": {
    "tag:deployment-1": ["alice@tailscale.com"],
    "tag:prod-2": ["tag:deployment-1", "tag:prod-2"],
    "tag:test-2": ["tag:deployment-1", "tag:test-2"],
  },
```

You can use the [visual policy editor](https://tailscale.com/kb/1550/visual-editor) to manage your tailnet policy file. Refer to the [visual editor reference](https://tailscale.com/kb/1587/visual-editor-reference) for guidance on using the visual editor.

You could generate an [auth key](https://tailscale.com/kb/1085/auth-keys) `<key-1>` with the tag `tag:deployment-1`, and make it available to the deployment tool. Then, depending on what workload you deploy, the system authenticates the device and applies the correct infrastructure tag, which enforces the correct [access controls](https://tailscale.com/kb/1393/access-control). When spinning up a new production server, the deployment tool could tag the device as `tag:prod-2`:

```shell
sudo tailscale up --auth-key=<key-1> --advertise-tags=tag:prod-2
```
```



### File: 1077-secure-server-ubuntu.md

```markdown
# Use UFW to lock down an Ubuntu server

Any server on the public internet is bound to be attacked by bots looking for weak or leaked passwords and unsafely configured services. Even security experts can misconfigure a database, or an unwitting member of the team can accidentally open up a vulnerability, leaving your devices or network open to attack.

If you have an existing server, you can view this bot traffic by running `sudo less /var/log/auth.log`. If your server is like many on the web, you'll see lots of "invalid user admin" or "invalid user test".

Tailscale simplifies network security by letting you keep your servers away from the public web, while keeping it easy to connect.

The best way to secure a server with Tailscale is to accept connections from Tailscale, and ignore any public internet traffic. Since your Tailscale network is invisible, except to those in your network, attackers won't even be able to find it.

## [Prerequisites](#prerequisites)

Before you begin this guide, you'll need an Ubuntu server to secure. This guide assumes you're setting up a [DigitalOcean Ubuntu server](https://www.digitalocean.com/products/linux-distribution/ubuntu), but the steps should be similar for most hosting providers and versions of Ubuntu.

You'll also need a Tailscale network, known as a tailnet. For information about creating a tailnet, see the [Tailscale quickstart](https://tailscale.com/kb/1017/install).

Next, you'll need to install the Tailscale client on your local machine and log in.

[Download Tailscale](https://tailscale.com/download)

We'll follow the same steps on the Ubuntu server next.

## [Step 1: ssh into your new Ubuntu server](#step-1-ssh-into-your-new-ubuntu-server)

After spinning up a new server, ssh into it with your account details.

```shell
ssh <username>@<server host ip>
```

## [Step 2: Install Tailscale on your Ubuntu server](#step-2-install-tailscale-on-your-ubuntu-server)

1.  Install Tailscale using the one-line script below, or read our [detailed install instructions for Ubuntu](https://tailscale.com/download/linux)

    ```shell
    curl -fsSL https://tailscale.com/install.sh | sh
    ```

2.  Authenticate and connect your machine to your Tailscale network

    ```shell
    sudo tailscale up
    ```

3.  (Optional) If you signed in with a custom domain (not a `@gmail.com` address) visit the [admin console](https://login.tailscale.com/admin) and authorize your new endpoint.

4.  (Optional) Disable key expiry for this server


As a security feature, Tailscale requires periodic reauthentication. To prevent getting locked out, you may want to disable expiry on certain endpoints, such as this trusted server. Disable key expiry by following [these instructions](https://tailscale.com/kb/1028/key-expiry).

If you leave key expiry on, be familiar with how to regain server access. For example, DigitalOcean provides access via a [droplet console](https://www.digitalocean.com/docs/droplets/resources/console).

## [Step 3: ssh over Tailscale](#step-3-ssh-over-tailscale)

An important step - since we're about to restrict ssh access to be only over Tailscale, we'll exit the machine and re-ssh with our Tailscale IP.

First, [find and copy your machine's Tailscale IP](https://tailscale.com/kb/1033/ip-and-dns-addresses). The easiest way to do this is to run

```shell
tailscale ip -4
```

And copy the 100.x.y.z shown.

Once you've found it, `exit` your ssh session, and start a new one with your newly copied Tailscale IP.

```shell
ssh <username>@<copied 100.x.y.z address>
```

## [Step 4: Enable UFW](#step-4-enable-ufw)

For this guide, we'll use [UFW](https://help.ubuntu.com/community/UFW) (Uncomplicated Firewall) to restrict non-Tailscale traffic to our server. It comes pre-installed on Ubuntu 18.04, so no installation is needed.

Before we continue editing rules, you'll need to enable UFW if it isn't already enabled.

```shell
sudo ufw enable
```

## [Step 5: Restrict all other traffic](#step-5-restrict-all-other-traffic)

Next, we'll set up rules to reject all incoming non-Tailscale traffic, and allow all outgoing traffic by default.

```shell
sudo ufw default deny incoming
sudo ufw default allow outgoing
```

Now that we've set these defaults check your existing firewall rules you might need to keep.

```shell
sudo ufw status verbose
```

You might see a list of firewall rules, like this:

```shell
To                          Action      From
--                          ------      ----
22/tcp                      ALLOW IN    Anywhere
80/tcp                      ALLOW IN    Anywhere
443/tcp                     ALLOW IN    Anywhere
Anywhere on tailscale0      ALLOW IN    Anywhere
22/tcp (v6)                 ALLOW IN    Anywhere (v6)
80/tcp (v6)                 ALLOW IN    Anywhere (v6)
443/tcp (v6)                ALLOW IN    Anywhere (v6)
Anywhere (v6) on tailscale0 ALLOW IN    Anywhere (v6)
```

If you do not see an `Anywhere on tailscale0` rule, you can create one manually:

```shell
sudo ufw allow in on tailscale0
```

All other connections are denied by default and so not listed above. We want to limit this list to the minimum set needed.

To completely lock down your server while retaining ssh access, you could delete every rule except for the "Anywhere on tailscale0" rule.

For the example above, we'll delete all "22/tcp" rules, which will remove the ability to ssh over regular connections:

```shell
sudo ufw delete 22/tcp
```

Now, only "Anywhere on tailscale0" remains, meaning ssh can only occur over Tailscale.

```shell
To                          Action      From
--                          ------      ----
80/tcp                      ALLOW       Anywhere
443/tcp                     ALLOW       Anywhere
Anywhere on tailscale0      ALLOW IN    Anywhere
80/tcp (v6)                 ALLOW       Anywhere (v6)
443/tcp (v6)                ALLOW       Anywhere (v6)
Anywhere (v6) on tailscale0 ALLOW IN    Anywhere (v6)
```

If you expose a public web service (80/tcp, 443/tcp), you'll want to keep those rules around. For less public services like FTP (21/tcp) or a database, consider connecting devices that rely on those services over Tailscale too.

This guide assumes ssh is running on the default port, port 22. If you've changed your ssh port, you may need to change these instructions as well.

## [Step 6: Restart ufw and ssh](#step-6-restart-ufw-and-ssh)

Once you've set up firewall rules to restrict all non-Tailscale connections, restart ufw and ssh

```shell
sudo ufw reload
sudo service ssh restart
```

Now your server will ignore any ssh requests that don't come from users authenticated to your private Tailscale network.

## [Step 7: Test and verify](#step-7-test-and-verify)

Let's make sure that everything is working as expected.

First, let's `exit` the existing ssh session.

Then, let's try to connect with the public IP address from earlier.

You should see that we're not able to connect, and the operation times out.

```shell
ssh <username>@<server host ip>
ssh: connect to host <server host ip> port 22: Operation timed out
```

Now, let's try to ssh in using the Tailscale IP address (starting with 100.x.y.z) from earlier.

```shell
ssh <username>@<copied 100.x.y.z address>
```

Everything now works as expected. Type `exit` to close the ssh connection again.

This time, quit the Tailscale client on your local machine.

If you try to `ssh` to the Ubuntu server again, you'll see that the operation now times out and we are no longer able to connect.

```shell
ssh <username>@<copied 100.x.y.z address>
ssh: connect to host <copied 100.x.y.z address> port 22: Operation timed out
```

We've now verified that we can only connect when we're successfully authenticated to the Tailscale client running on our local machine.

## [(Optional) enable multifactor authentication (MFA) for all ssh connections](#optional-enable-multifactor-authentication-mfa-for-all-ssh-connections)

Now that your server can only be accessed via Tailscale, you can enforce login rules in using your Tailscale network's [identity provider](https://tailscale.com/kb/1013/sso-providers), knowing they will apply to all your ssh connections too.

For example, you may want to configure your identity provider to [require multifactor authentication (MFA)](https://tailscale.com/kb/1075/multifactor-auth) for every sign-in.

Thanks to _/u/mgozmovies_ whose experimentation and [write-up on /r/tailscale](https://old.reddit.com/r/Tailscale/comments/hwnc0l/restricting_ssh_access_to_tailscale_interface_on) inspired this topic.
```



### File: 1080-cli.md

```markdown
# Tailscale CLI

The Tailscale client includes a built-in command-line interface (CLI) you can use to manage and troubleshoot your device within your Tailscale network (known as a tailnet).

The Tailscale CLI is available for [all plans](https://tailscale.com/pricing).

## [Using the Tailscale CLI](#using-the-tailscale-cli)

The location of the CLI varies depending on your platform:

[Linux](https://tailscale.com/kb/1080/cli?tab=linux)[macOS](https://tailscale.com/kb/1080/cli?tab=macos)[Windows](https://tailscale.com/kb/1080/cli?tab=windows)

On Linux, the CLI is your primary interface to Tailscale. The `tailscale` binary is likely already in your `$PATH`, so you can run commands with:

```shell
tailscale <command>
```

There is no CLI support for iOS and Android.

### [Tab completion](#tab-completion)

The Tailscale CLI supports tab-completion for commands, flags, and arguments. You can configure tab-completion with the [`completion` command](#completion).

```shell
tailscale completion <shell> [--flags] [--descs]
```

Select your shell, then follow the instructions to load Tailscale CLI completions.

[Bash](https://tailscale.com/kb/1080/cli?tab=bash)[Zsh](https://tailscale.com/kb/1080/cli?tab=zsh)[Fish](https://tailscale.com/kb/1080/cli?tab=fish)[PowerShell](https://tailscale.com/kb/1080/cli?tab=powershell)

To load tab-completions for Bash, run the following command.

```shell
source <(tailscale completion bash)
```

Run the following command to load completions for every new session on Linux, then reload your shell.

```shell
tailscale completion bash > /etc/bash_completion.d/tailscale
```

Run the following command to load completions for every new session on macOS, then reload your shell.

```shell
tailscale completion bash > $(brew --prefix)/etc/bash_completion.d/tailscale
```

## [Command Reference](#command-reference)

Common flags for all commands:

-   `--socket=<path>` Path to the tailscaled socket.

### [up](#up)

Connect your device to Tailscale and authenticate if needed.

```shell
tailscale up [flags]
```

Running `tailscale up` without any flags connects to Tailscale.

Common flags:

-   `--accept-routes` Accept [subnet routes](https://tailscale.com/kb/1019/subnets) that other nodes advertise. Linux devices default to not accepting routes.
-   `--advertise-exit-node` Offer to be an [exit node](https://tailscale.com/kb/1103/exit-nodes) for outbound internet traffic from the Tailscale network. Defaults to not offering to be an exit node.
-   `--advertise-routes=<ip>` Expose physical [subnet routes](https://tailscale.com/kb/1019/subnets) to your entire Tailscale network.
-   `--exit-node=<ip|name>` Provide a [Tailscale IP](https://tailscale.com/kb/1033/ip-and-dns-addresses) or [machine name](https://tailscale.com/kb/1098/machine-names) to use as an exit node. To disable the use of an exit node, pass the flag with an empty argument: `--exit-node=`.
-   `--exit-node-allow-lan-access` Allow the client node access to its own LAN while connected to an exit node. Defaults to not allowing access while connected to an exit node.
-   `--force-reauth` Force re-authentication.
-   `--snat-subnet-routes` (Linux only) Disable source NAT. In normal operations, a subnet device sees the traffic originating from the subnet router. This simplifies routing, but does not allow traversing multiple networks. By disabling source NAT, the end machine sees the LAN IP address of the originating machine as the source.
-   `--stateful-filtering` Enable stateful filtering for [subnet routers](https://tailscale.com/kb/1019/subnets) and [exit nodes](https://tailscale.com/kb/1103/exit-nodes). When enabled, inbound packets with another node's destination IP are dropped, unless they are a part of a tracked outbound connection from that node. Defaults to disabled.
-   `--shields-up` [Block incoming connections](https://tailscale.com/kb/1072/client-preferences) from other devices on your Tailscale network. Useful for personal devices that only make outgoing connections.
-   `--ssh` Run a [Tailscale SSH](https://tailscale.com/kb/1193/tailscale-ssh) server, permitting access per the tailnet admin's declared [access policy](https://tailscale.com/kb/1018/acls), or the [default policy](https://tailscale.com/kb/1192/acl-samples#allow-all-default-acl) if none is defined. Defaults to false.

For a complete list of available flags, refer to the [`tailscale up`](https://tailscale.com/kb/1241/tailscale-up) topic.

### [down](#down)

Disconnect from Tailscale. Running this command is the same as choosing to disconnect from or quit a Tailscale client.

```shell
tailscale down
```

When disconnected, you cannot reach devices over Tailscale. To reconnect, re-run `tailscale up` without any flags.

Available flags:

-   `--accept-risk=<risk>` Accept risk and skip confirmation for risk type. This can be either `lose-ssh` or `all`, or an empty string to not accept risk.
-   `--reason="<description>"` Specify the reason (inside quotes) for disconnecting Tailscale when the [system policies](https://tailscale.com/kb/1315/mdm-keys) `AlwaysOn.Enabled` and `AlwaysOn.OverrideWithReason` are enabled. For example, `tailscale down --reason="DNS issues"`.

### [bugreport](#bugreport)

The `bugreport` command is available in Tailscale v1.8 or later. If you don't see this command, consider [updating](https://tailscale.com/kb/1067/update) your Tailscale client.

Generate a bug report with diagnostic information.

The `bugreport` command makes it easier to report bugs to the Tailscale team by marking diagnostic logs with indicators to make triage easier.

If you encounter a connectivity issue, run `tailscale bugreport` on the device experiencing the issue at the time you encounter it. This command prints a random identifier into diagnostic logs, which you can share with our team.

Identifiers look like this:

```shell
$ tailscale bugreport
BUG-1b7641a16971a9cd75822c0ed8043fee70ae88cf05c52981dc220eb96a5c49a8-20210427151443Z-fbcd4fd3a4b7ad94
```

This command shares no personally identifiable information and is unused unless you share the bug identifier with our team.

Available flags:

-   `--diagnose` Prints additional verbose information about the system to the Tailscale logs after generating a `bugreport` identifier, which can then be viewed by our support team. Defaults to `false`.
-   `--record` Pause and then write another `bugreport`. Use this flag to create an initial `bugreport` identifier. During the pause, perform the action that reproduces your issue. Then, press Enter to create a second `bugreport` identifier. Share both bug identifiers with our team. Defaults to `false`.

### [cert](#cert)

Generate Let's Encrypt certificate and key files on the host for [HTTPS certificates](https://tailscale.com/kb/1153/enabling-https) in your tailnet.

If you are trying to serve a folder of files or reverse proxy to an HTTP service, use the [`tailscale serve`](#serve) command instead.

```shell
tailscale cert hostname.tails-scales.ts.net
```

Alternatively, if you want to save the certificate and private key to files, you can use the `--cert-file` and `--key-file` arguments:

```shell
tailscale cert --cert-file=cert.pem --key-file=key.pem hostname.tails-scales.ts.net
```

The certificates provided by Let's Encrypt have a 90-day expiry and require periodic renewal. When a certificate is delivered as files on disk which you then move to an install location, such as when using `tailscale cert`, the [`tailscaled` daemon](https://tailscale.com/kb/1278/tailscaled) doesn't know where to place a renewed certificate or how to install it. As a result, you are responsible for renewing any certificates that you create using `tailscale cert`.

If a certificate is handled without the user initiating any file-based certificate installation (such as when using the [Caddy integration of Tailscale](https://github.com/tailscale/caddy-tailscale)) then the certificate will automatically renew without the user doing anything.

Available flags:

-   `--cert-file=<cert>` Specify the certificate output path.
-   `--key-file=<key>` Specify the private key output path.
-   `--min-validity=<duration>` Request a specified minimum remaining validity on the returned certificate. `duration` can be any value parseable by [`time.ParseDuration()`](https://pkg.go.dev/time#ParseDuration). For example, use `120h` to set the duration to five days.
-   `--serve-demo` Serve on port `:443` using the cert as a demo, instead of writing out the files to disk.

The `--min-validity` flag lets you ensure that the returned certificate is valid for at least the specified duration. If you specify a duration longer than the [certification lifetime set by Let's Encyrpt](https://letsencrypt.org/docs/faq#what-is-the-lifetime-for-let-s-encrypt-certificates-for-how-long-are-they-valid), it uses the maximum lifetime set by Let's Encrypt.

### [dns](#dns)

The `dns` command lets you access [Tailscale DNS settings](https://tailscale.com/kb/1054/dns). It's available in Tailscale v1.74.0 and later.

Subcommands:

-   `status` Print the configuration of the local DNS forwarder and the tailnet-wide [MagicDNS](https://tailscale.com/kb/1081/magicdns) configuration.
-   `query` Perform a DNS query using the local DNS forwarder. It's available in Tailscale v1.76.0 and later.

Available flags for `status`:

-   `--all` Outputs advanced debugging information.

### [drive](#drive)

Share a directory with your tailnet using [Taildrive](https://tailscale.com/kb/1369/taildrive).

```shell
tailscale drive share <name> <path>
tailscale drive rename <oldname> <newname>
tailscale drive unshare <name>
tailscale drive list
```

Subcommands:

-   `share` Create or modify a share.
-   `rename` Rename a share.
-   `unshare` Remove a share.
-   `list` List current shares.

### [completion](#completion)

Configure tab-completion for the Tailscale CLI.

```shell
tailscale completion <subcommand> [flags]
```

Subcommands:

-   `bash` Configure tab-completion for the `bash` shell.
-   `zsh` Configure tab-completion for the `zsh` shell.
-   `fish` Configure tab-completion for the `fish` shell.
-   `powershell` Configure tab-completion for PowerShell.

Available flags:

-   `--flags=<true|false>` Configure whether to suggest flags (in addition to subcommands). Set to `true` by default.
-   `--descs=<true|false>` Configure whether to include descriptions of subcommands in the suggestions. Set to `true` by default.

### [configure](#configure)

Configure resources that you want to include in your tailnet.

```shell
tailscale configure <subcommands>
```

Subcommands:

-   `kubeconfig` (alpha) Configure kubectl to connect to a Kubernetes cluster using Tailscale.
-   `synology` Configure Synology to enable outbound connections needed for Tailscale.
-   `sysext` Activate, deactivate, or manage the state of the Tailscale [system extension](https://tailscale.com/kb/1340/macos-sysext) on the [Standalone variant](https://tailscale.com/kb/1065/macos-variants#standalone-variant) of macOS.
-   `systray` Manage the systray client for Linux.

Available flags for `kubeconfig`:

-   `--http` Use HTTP instead of HTTPS to connect to the auth proxy. Ignored if you include a scheme in the hostname argument.

Available flags for `sysext`:

-   `activate` Register the Tailscale system extension with macOS.
-   `deactivate` Deactivate the Tailscale system extension on macOS.
-   `status` Print the enablement status of the Tailscale system extension.

Available flags for `systray`:

-   `--enable-startup=<init-system>` Install the startup script for the init system. The only currently supported value is `systemd`.

Examples:

-   To configure your local `kubeconfig` file for authentication with a Kubernetes auth proxy:

```shell
tailscale configure kubeconfig <hostname-or-fqdn>
```

-   To configure Synology to enable outbound connections:

```shell
tailscale configure synology
```

### [exit-node](#exit-node)

Get information about [exit-nodes](https://tailscale.com/kb/1103/exit-nodes) in your tailnet.

```shell
tailscale exit-node <subcommands>
```

Available subcommands:

-   `list` Lists the exit nodes in your tailnet.
-   `suggest` Suggests a [recommended exit node](https://tailscale.com/kb/1392/auto-exit-nodes).

Available flags for `list`:

-   `--filter=<country>` Filter exit nodes by country.

### [file](#file)

Access and make files available to [Taildrop](https://tailscale.com/kb/1106/taildrop).

```shell
tailscale file cp <files...> <target>:
tailscale file get <target-directory>
```

Available commands:

-   `cp` Copy files to a host.
-   `get` Move files out of the Tailscale file inbox.

Available flags for `cp`:

-   `--name=<name>` Alternate filename to use, especially useful when `<file>` is `-` (stdin).
-   `--targets` List possible file `cp` targets.
-   `--verbose` Verbose output.

Available flags for `get`:

-   `--conflict=<behavior>` `behavior` when a conflicting (same-named) file already exists in the target directory.
    -   `skip` Skip conflicting files: leave them in the taildrop inbox and print an error. Get any non-conflicting files.
    -   `overwrite` Overwrite existing file.
    -   `rename` Write to a new number-suffixed filename.
-   `--loop` Run get in a loop, receiving files as they come in.
-   `--verbose` Verbose output.
-   `--wait` Wait for a file to arrive if inbox is empty.

### [funnel](#funnel)

Serve content and local servers from your Tailscale node to the internet.

To limit local service access to your tailnet, use the [`serve`](#serve) command.

```shell
tailscale funnel <target>
tailscale funnel <subcommand> [flags] <args>
```

Subcommands:

-   [`status`](https://tailscale.com/kb/1311/tailscale-funnel#view-the-status) Shows the status.
-   [`reset`](https://tailscale.com/kb/1311/tailscale-funnel#reset-tailscale-funnel) Resets the configuration.

For more information, refer to the [`tailscale funnel`](https://tailscale.com/kb/1311/tailscale-funnel) topic.

### [ip](#ip)

Get a device's Tailscale IP address.

```shell
tailscale ip [flags] [<hostname>]
```

By default, this command returns both an [`100.x.y.z` IPv4 address](https://tailscale.com/kb/1033/ip-and-dns-addresses) and an IPv6 address for the current device. You can return only an IPv4 or IPv6 address by passing either the `-4` or `-6` flags.

```shell
$ tailscale ip -4
100.121.112.23
```

You can also find the Tailscale IP for other devices on your network by adding the device hostname after the command. For example:

```shell
$ tailscale ip raspberrypi
100.126.153.111
fd7a:115c:a1e0:ab12:4843:cd96:627e:9975
```

Available flags:

-   `--4` Only return an IPv4 address.
-   `--6` Only return an IPv6 address.
-   `--1` Only return one address, preferring IPv4.

### [licenses](#licenses)

Get open source license information.

```shell
tailscale licenses
```

### [lock](#lock)

Manage [Tailnet Lock](https://tailscale.com/kb/1226/tailnet-lock) for your tailnet.

```shell
tailscale lock <subcommand> [flags] <args>
```

Common subcommands:

-   [`init`](https://tailscale.com/kb/1243/tailscale-lock#lock-init) Initializes Tailnet Lock.
-   [`status`](https://tailscale.com/kb/1243/tailscale-lock#lock-status) Outputs the state of Tailnet Lock.
-   [`add`](https://tailscale.com/kb/1243/tailscale-lock#lock-add) Adds one or more trusted signing keys to Tailnet Lock.
-   [`remove`](https://tailscale.com/kb/1243/tailscale-lock#lock-remove) Removes one or more trusted signing keys from Tailnet Lock.
-   [`sign`](https://tailscale.com/kb/1243/tailscale-lock#lock-sign) Signs a node key and transmits the signature to the coordination server.

Running `tailscale lock` with no subcommand and no arguments is equivalent to running [`tailscale lock status`](https://tailscale.com/kb/1243/tailscale-lock#lock-status).

For a complete list of subcommands and flags, refer to the [`tailscale lock`](https://tailscale.com/kb/1243/tailscale-lock) topic.

### [login](#login)

Log into Tailscale (and add this device to your Tailscale network). For more information about logging in, refer to [fast-user-switching](https://tailscale.com/kb/1225/fast-user-switching).

```shell
tailscale login [flags]
```

Available flags:

-   `--accept-dns` Accept [DNS configuration](https://tailscale.com/kb/1054/dns) from the admin console. Defaults to accepting DNS settings.
-   `--accept-routes` Accept [subnet routes](https://tailscale.com/kb/1019/subnets) that other nodes advertise. Linux devices default to not accepting routes.
-   `--advertise-connector` Offer to be an [app connector](https://tailscale.com/kb/1281/app-connectors) for domain-specific internet traffic for the tailnet.
-   `--advertise-exit-node` Offer to be an [exit node](https://tailscale.com/kb/1103/exit-nodes) for outbound internet traffic from the Tailscale network. Defaults to not offering to be an exit node.
-   `--advertise-routes=<ip>` Expose physical [subnet routes](https://tailscale.com/kb/1019/subnets) to your entire Tailscale network.
-   `--advertise-tags=<tags>` Give tagged permissions to this device. You must be [listed in `"TagOwners"`](https://tailscale.com/kb/1337/policy-syntax#tag-owners) to be able to apply tags.
-   `--auth-key=<key>` Provide an [auth key](https://tailscale.com/kb/1085/auth-keys) to automatically authenticate the node as your user account. For a best practice when handling the `--auth-key` value, refer to [Securely handle an auth key](https://tailscale.com/kb/1595/secure-auth-key-cli).
-   `--client-id` Client ID used to generate [auth keys](https://tailscale.com/kb/1085/auth-keys) via [workload identity federation](https://tailscale.com/kb/1581/workload-identity-federation).
-   `--client-secret` [OAuth Client](https://tailscale.com/kb/1215/oauth-clients) secret used to generate [auth keys](https://tailscale.com/kb/1085/auth-keys); if it begins with `file:`, then it's a path to a file containing the secret.
-   `--exit-node=<ip|name>` Provide a [Tailscale IP](https://tailscale.com/kb/1033/ip-and-dns-addresses) or [machine name](https://tailscale.com/kb/1098/machine-names) to use as an exit node. To disable the use of an exit node, pass the flag with an empty argument: `--exit-node=`.
-   `--exit-node-allow-lan-access` Allow the client node access to its own LAN while connected to an exit node. Defaults to not allowing access while connected to an exit node.
-   `--hostname=<name>` Provide a hostname to use for the device instead of the one provided by the OS. Note that this will change the machine name used in [MagicDNS](https://tailscale.com/kb/1081/magicdns).
-   `--id-token` ID token from the identity provider to exchange with the control server for [workload identity federation](https://tailscale.com/kb/1581/workload-identity-federation); if it begins with `file:`, then it's a path to a file containing the token.
-   `--login-server=<url>` Provide the base URL of a control server instead of `https://controlplane.tailscale.com`. If you are using [Headscale](https://tailscale.com/blog/opensource#the-open-source-coordination-server) for your control server, use your Headscale instance's URL.
-   `--netfilter-mode=<mode>` Netfilter mode (one of `on`, `nodivert`, `off`).
-   `--nickname=<name>` [Nickname](https://tailscale.com/kb/1225/fast-user-switching#setting-a-nickname) for the current account.
-   `--operator=<user>` Provide a Unix username other than `root` to operate `tailscaled`.
-   `--qr` Generate a QR code for the web login URL. Defaults to not showing a QR code.
-   `--qr-format=<format>` QR code formatting: `small` or `large`. Defaults to `small`.
-   `--stateful-filtering` Enable stateful filtering for [subnet routers](https://tailscale.com/kb/1019/subnets) and [exit nodes](https://tailscale.com/kb/1103/exit-nodes). When enabled, inbound packets with another node's destination IP are dropped, unless they are a part of a tracked outbound connection from that node. Defaults to disabled.
-   `--shields-up` [Block incoming connections](https://tailscale.com/kb/1072/client-preferences) from other devices on your Tailscale network. Useful for personal devices that only make outgoing connections.
-   `--snat-subnet-routes` Source NAT traffic to local routes advertised with `--advertise-routes`.
-   `--ssh` Run a [Tailscale SSH](https://tailscale.com/kb/1193/tailscale-ssh) server, permitting access per the tailnet admin's declared [access policy](https://tailscale.com/kb/1018/acls), or the [default policy](https://tailscale.com/kb/1192/acl-samples#allow-all-default-acl) if none is defined. Defaults to false.
-   `--timeout=<duration>` Maximum amount of time to wait for the Tailscale service to initialize. `duration` can be any value parseable by [`time.ParseDuration()`](https://pkg.go.dev/time#ParseDuration). Defaults to `0s`, which blocks forever.
-   `--unattended`(Windows only) Run in [unattended mode](https://tailscale.com/kb/1088/run-unattended) where Tailscale keeps running even after the current user logs out.

### [logout](#logout)

Disconnect from Tailscale and expire the current log in. The next time you run `tailscale up`, you'll need to reauthenticate your device.

```shell
tailscale logout
```

If you run `tailscale logout` on an [ephemeral node](https://tailscale.com/kb/1111/ephemeral-nodes), the node will be removed from your tailnet immediately.

Available flags:

-   `--reason` Reason for the logout, if required by a [system policy](https://tailscale.com/kb/1315/mdm-keys).

### [metrics](#metrics)

Expose and collect [Tailscale client metrics](https://tailscale.com/kb/1482/client-metrics) for use with third-party monitoring systems.

```shell
tailscale metrics
```

Subcommands:

-   `print` Shows client metrics in the current terminal session.
-   `write` Writes metric values to a text file.

### [netcheck](#netcheck)

Get a report on your current physical network conditions. This command is provided to help debug connection troubles.

```shell
tailscale netcheck
```

`netcheck` will output a report like this:

```shell
Report:
  * Time: 2025-03-13T16:35:03.336481Z
  * UDP: true
  * IPv4: yes, <ipv4-address>
  * IPv6: yes, <ipv6-address>
  * MappingVariesByDestIP: false
  * PortMapping:
  * Nearest DERP: Seattle
  * DERP latency:
    - sea: 24.2ms  (Seattle)
    - sfo: 50.5ms  (San Francisco)
    - lax: 57.2ms  (Los Angeles)
    - den: 58.5ms  (Denver)
    - dfw: 63ms    (Dallas)
    - ord: 73.3ms  (Chicago)
```

(In the example output, the list of [DERP servers](https://tailscale.com/kb/1232/derp-servers) is truncated for brevity.)

-   **UDP** shows whether UDP traffic is enabled on the current network. If this is false, it's unlikely Tailscale will be able to make point-to-point connections, and will instead rely on our [encrypted TCP relays (DERP)](https://tailscale.com/kb/1232/derp-servers)
-   **IPv4** and **IPv6** show your network public IP addresses and support for both protocols.
-   **MappingVariesByDestIP** describes whether your device is behind a difficult NAT that varies the device's IP address depending on the destination.
-   **HairPinning** describes whether your router can route connections from endpoints on your LAN back to your LAN using those endpoints' globally-mapped IPv4 addresses/ports.
-   **PortMapping** describes a list of which three port-mapping services exist on your router. Possible values are "UPnP", "NAT-PMP", and "PCP".
-   **DERP latency** and **Nearest DERP** describe latency from our [encrypted TCP relays (DERP)](https://tailscale.com/kb/1232/derp-servers). The lowest latency ("nearest") server is used for traffic.

If any fields are blank, it means Tailscale wasn't able to measure that network property.

All the information from `tailscale netcheck` is also available in the [Machines](https://login.tailscale.com/admin/machines) page of the admin console, by selecting a particular machine.

Available flags:

-   `--every=<duration>` If non-zero, do an incremental report with the given frequency.
-   `--format=<format>` Output format; empty (for human-readable), `json` or `json-line`.
-   `--verbose` Verbose logs.

### [version](#version)

Print the version of Tailscale.

```shell
tailscale version [flags]
```

Available flags:

-   `--daemon` Also print local node's daemon version. Defaults to false.
-   `--json` Return a machine-readable JSON response.
-   `--upstream` Print the latest upstream release version from pkgs.tailscale.com. Defaults to false.

Running `tailscale version` also prints other information, including the Go version. Here's an example of the output:

```shell
tailscale version
1.72.0
  tailscale commit: 9a0f00ea8ed08d1a94b357fb232ac9d44a512664
  other commit: 387e0b40ad87031fb4444372ee80a97156e8deb9
  go version: go1.22.5
```

### [nc](#nc)

Connect to a port on a host, connected to stdin/stdout.

```shell
tailscale nc <hostname-or-IP> <port>
```

### [ping](#ping)

Attempt to ping another device exclusively over Tailscale.

The regular `ping` command often works fine over Tailscale, but `tailscale ping` provides more details about the connection over Tailscale that can be helpful when troubleshooting connectivity.

```shell
tailscale ping <hostname-or-ip>
```

You can call `tailscale ping` using either a [100.x.y.z address](https://tailscale.com/kb/1033/ip-and-dns-addresses) or a [machine name](https://tailscale.com/kb/1098/machine-names).

Available flags:

-   `--c` Maximum number of pings to send. Defaults to 10.
-   `--icmp`, `--icmp=false` Perform an ICMP-level ping (through WireGuard, but not the local host OS stack). Defaults to false.
-   `--peerapi`, `--peerapi=false` Try hitting the peer's PeerAPI HTTP server. Defaults to false.
-   `--size=<size>` Size of the ping message (default pings only). 0 for minimum size.
-   `--tsmp`, `--tsmp=false` Perform a TSMP-level ping (through WireGuard, but not either host's OS stack). Defaults to false.
-   `--timeout=<duration>` Maximum amount of time to wait before giving up on a ping. `duration` can be any value parseable by [`time.ParseDuration()`](https://pkg.go.dev/time#ParseDuration). Defaults to `5s`.
-   `--until-direct`, `--until-direct=false` Stop once a direct path is established. Defaults to true.
-   `--verbose`, `--verbose=false` Show verbose output. Defaults to false.

There are [four types of ping messages](https://tailscale.com/kb/1465/ping-types) supported by the `tailscale ping` command.

### [serve](#serve)

Serve content and local servers from your Tailscale node to your tailnet.

To publicly share the local service to the internet, use the [`funnel`](#funnel) command.

```shell
tailscale serve <target>
tailscale serve <subcommand> [flags] <args>
```

Subcommands:

-   [`status`](https://tailscale.com/kb/1242/tailscale-serve#view-the-status) Shows the status.
-   [`reset`](https://tailscale.com/kb/1242/tailscale-serve#reset-tailscale-serve) Resets the configuration.

For more information, refer to the [`tailscale serve`](https://tailscale.com/kb/1242/tailscale-serve) topic.

### [set](#set)

Change specified preferences.

Unlike [`tailscale up`](#up), this command does not require the complete set of desired settings. It only updates the settings you explicitly set. There are no default values. Note that when using [Fast User Switching](https://tailscale.com/kb/1225/fast-user-switching), changes made are only for the currently connected tailnet.

```shell
tailscale set [flags]
```

Available flags:

-   `--accept-dns` Accept [DNS configuration](https://tailscale.com/kb/1054/dns) from the admin console.
-   `--accept-risk=<risk>` Accept risk and skip confirmation for risk type. This can be either `lose-ssh` or `all`, or an empty string to not accept risk.
-   `--accept-routes`, `--accept-routes=false` Accept [subnet routes](https://tailscale.com/kb/1019/subnets) that other nodes advertise.
-   `--advertise-connector` Offer to be an [app connector](https://tailscale.com/kb/1281/app-connectors) for domain-specific internet traffic for the tailnet.
-   `--advertise-exit-node`, `--advertise-exit-node=false` Offer to be an exit node for internet traffic for the tailnet.
-   `--advertise-routes=<ip>` Expose physical [subnet routes](https://tailscale.com/kb/1019/subnets) to your entire Tailscale network. This is a comma-separated string, such as "10.0.0.0/8,192.168.0.0/24", or an empty string to not advertise routes.
-   `--auto-update`, `--auto-update=false` Enable or disable [auto-updates](https://tailscale.com/kb/1067/update#auto-updates) for the client.
-   `--exit-node=<ip|name>` Provide a [Tailscale IP](https://tailscale.com/kb/1033/ip-and-dns-addresses) or [machine name](https://tailscale.com/kb/1098/machine-names) to use as an exit node. You can also use `--exit-node=auto:any` to track the suggested exit node and automatically switch to it when available exit nodes or network conditions change. To disable the use of an exit node, pass the flag with an empty argument using `--exit-node=`.
-   `--exit-node-allow-lan-access`, `--exit-node-allow-lan-access=false` Allow the client node access to its own LAN while connected to an exit node.
-   `--hostname=<name>` Hostname to use for the device instead of the one provided by the OS. Note that this will change the machine name used in [MagicDNS](https://tailscale.com/kb/1081/magicdns).
-   `--netfilter-mode=<mode>` Netfilter mode (one of `on`, `nodivert`, `off`).
-   `--nickname=<name>` [Nickname](https://tailscale.com/kb/1225/fast-user-switching#setting-a-nickname) for the current account.
-   `--operator=<user>` A Unix username other than `root` to operate `tailscaled`.
-   `--relay-server-port=<port>` Specify a UDP port to accept peer relay connections on. UDP port number (`0` will pick a random unused port) for the relay server to bind to, on all interfaces, or empty string to disable relay server functionality. Refer to [Tailscale Peer Relays](https://tailscale.com/kb/1591/peer-relays) for more information.
-   `--report-posture` Allow management plane to gather [device posture](https://tailscale.com/kb/1288/device-posture) information.
-   `--shields-up`, `--shields-up=false` [Block incoming connections](https://tailscale.com/kb/1072/client-preferences) from other devices on your Tailscale network. Useful for personal devices that only make outgoing connections.
-   `--snat-subnet-routes` Source NAT traffic to local routes advertised with `--advertise-routes`.
-   `--ssh`, `--ssh=false` Run a [Tailscale SSH](https://tailscale.com/kb/1193/tailscale-ssh) server, permitting access per the tailnet admin's declared [access policy](https://tailscale.com/kb/1018/acls), or the [default policy](https://tailscale.com/kb/1192/acl-samples#allow-all-default-acl) if none is defined.
-   `--stateful-filtering` Apply stateful filtering to forwarded packets (subnet routers, exit nodes, and so on).
-   `--update-check` Notify about available Tailscale updates.
-   `--webclient`, `--webclient=false` Expose the [web interface](https://tailscale.com/kb/1325/device-web-interface) to your tailnet persistently in the background on port `:5252.`

### [ssh](#ssh)

Establish a [Tailscale SSH](https://tailscale.com/kb/1193/tailscale-ssh) session to a Tailscale machine.

You can often use the regular `ssh` command or another SSH client to make an SSH session to a Tailscale machine. However, when your local node is in [userspace-networking](https://tailscale.com/kb/1177/kernel-vs-userspace-routers#userspace-netstack-mode) mode and can't make a direct connection, use `tailscale ssh`. This sets up an SSH `ProxyCommand` to connect through the local `tailscaled` daemon. You can also use `tailscale ssh` when your local node is in [kernel](https://tailscale.com/kb/1177/kernel-vs-userspace-routers#kernel-mode) mode.

The `tailscale ssh` command automatically checks the destination server's SSH host key against the node's SSH host key as advertised via the Tailscale coordination server.

```shell
tailscale ssh <args>
```

`<args>` is one of the following forms:

-   `host` The destination server. An interactive session will prompt you for the user name to use for the session.
-   `user@host` The user name for the session and the destination server.

For both forms, `host` can be the destination server's [MagicDNS](https://tailscale.com/kb/1081/magicdns) name (even if `--accept-dns=false` was set on the local node) or the destination server's [Tailscale IP address](https://tailscale.com/kb/1033/ip-and-dns-addresses).

`tailscale ssh` is not available on sandboxed macOS builds-use the regular `ssh` client instead.

### [status](#status)

Get the status of your connections to other Tailscale devices.

```shell
tailscale status
```

This command returns a condensed table of information in human-readable format:

```markup
1           2         3           4         5
100.1.2.3   device-a  apenwarr@   linux     active; direct <ip-port>, tx 1116 rx 1124
100.4.5.6   device-b  crawshaw@   macOS     active; relay <relay-server>, tx 1351 rx 4262
100.7.8.9   device-c  danderson@  windows   idle; tx 1214 rx 50
100.0.1.2   device-d  ross@       iOS       -
```

From left-to-right, these columns represent:

-   Column 1 is a [**Tailscale IP**](https://tailscale.com/kb/1015/100.x-addresses), which you can use to connect to the device.
-   Column 2 is the [**machine name**](https://tailscale.com/kb/1098/machine-names) of the device. If you use [MagicDNS](https://tailscale.com/kb/1081/magicdns), you can also use this name to connect.
-   Column 3 is the **email address** for the owner of the device.
-   Column 4 is the **device OS**.
-   Column 5 shows the current **connection status**.

Connection status (column 5) is shown using three terms:

-   `active` means traffic is currently being sent/received from this device. It also includes the connection type, which can be `direct`, `relay`, or `peer-relay`.
    -   If the connection is `direct`, it includes peer device's IP address.
    -   If the connection is `relay`, it includes the [DERP server](https://tailscale.com/kb/1232/derp-servers)'s city code (`nyc`, `fra`, `tok`, `syd`) for the respective location.
    -   If the connection is [`peer-relay`](https://tailscale.com/kb/1591/peer-relays), it includes the Tailscale IP address of the peer relay and the VNI (virtual network interface) used.
-   `idle` means traffic is not currently being sent/received from this device.
-   `-` means no traffic has ever been sent/received from this device.

`active` and `idle` connection statuses will also include tx/rx values indicating the number of bytes sent (tx) and received (rx) from this device.

Running `tailscale status` with the `--json` flag returns a machine-readable JSON response.

```shell
tailscale status --json
```

Unlike `tailscale status`, using this flag gives a detailed list of peers and users in your tailnet that makes it well-suited for automation tasks. It also includes additional metadata associated with your device.

Combine this with [`jq`](https://stedolan.github.io/jq) to automate data collection about your network. For example, the following command counts and sorts the relay servers your Tailscale peers are connected to.

```shell
tailscale status --json | jq -r '.Peer[].Relay | select(.!="")' | sort | uniq -c | sort -nr
```

Available flags:

-   `--active` Filter output to only peers with active sessions (not applicable to web mode).
-   `--browser` Open a browser in web mode (default `true`).
-   `--header` Show column headers in table format (default `false`).
-   `--json` Output in JSON format (WARNING: format subject to change).
-   `--listen=<address>` Listen address for web mode; use port 0 for automatic (default `127.0.0.1:8384`).
-   `--peers` Show status of peers (default `true`).
-   `--self` Show status of local machine (default `true`).
-   `--web` Run webserver with HTML showing status.

### [switch](#switch)

Switch to a different Tailscale account. For more information about switching accounts, refer to [fast-user-switching](https://tailscale.com/kb/1225/fast-user-switching).

```shell
tailscale switch <account> [flags]
```

Examples:

-   To switch to the [alice@example.com](mailto:alice@example.com) account:

    ```shell
    tailscale switch alice@example.com
    ```

-   To switch to the account that has the [nickname](https://tailscale.com/kb/1225/fast-user-switching#setting-a-nickname) "work":

    ```shell
    tailscale switch work
    ```


Available flags:

-   `--list` Lists available accounts.

Subcommands:

-   `remove <id>` removes a Tailscale account from the local machine. This does not delete the account itself, but it will no longer be available for switching to. You can add it back by logging in again. This command is currently in alpha and may change in the future.

### [syspolicy](#syspolicy)

List system policies, reload system policies, or view errors related to the [system policies](https://tailscale.com/kb/1315/mdm-keys) configured in your tailnet.

```shell
tailscale syspolicy
```

Subcommands:

-   `list` Shows system policies, reload system policies, or view errors related to the [system policies](https://tailscale.com/kb/1315/mdm-keys) configured on the device.
-   `reload` Forces the Tailscale client to reload and reapply system policy settings on the device.

Available flags:

-   `--json` Return a machine-readable JSON response.

### [systray](#systray)

The `systray` command is available on the Linux client, is currently in [beta](https://tailscale.com/kb/1167/release-stages#beta), and is available in Tailscale v1.88 or later.

Run the [system tray (systray) application](https://tailscale.com/kb/1597/linux-systray) for Linux desktop clients to access some common actions like fast user switching and exit node selection.

```shell
tailscale systray
```

Do not run `tailscale systray` as superuser (`sudo tailscale systray`), because systray is not designed to run as superuser and the command will fail.

### [update](#update)

The `update` command is available in Tailscale v1.36 or later for Windows and Ubuntu/Debian Linux, in v1.48.0 or later for the Mac Apple Store version and Synology, and in v1.54.0 or later for QNAP and the [Standalone variant of the macOS application](https://tailscale.com/kb/1065/macos-variants/). If you don't see this command and you are running one of these operating systems, consider [updating your Tailscale client](https://tailscale.com/kb/1067/update/).

Update the Tailscale client version to the latest version, or to a different version.

```shell
tailscale update [flags]
```

Available flags:

-   `--dry-run` Show what update would do, without performing the update and without prompting to start the update.
-   `--track` The track to check for updates, either "stable" or ["unstable"](https://tailscale.com/kb/1083/install-unstable). If not specified, the update uses the track currently in effect for the client.
-   `--version` An explicit version to use for the update or downgrade. You cannot specify both `--track` and `--version`.
-   `--yes` Perform the update without interactive prompts. Defaults to false.

If you downgrade to a version that does not have the `tailscale update` functionality, you won't be able to run `tailscale update` to return to the prior version. You would need to [perform an update](https://tailscale.com/kb/1067/update) without using the Tailscale CLI.

To determine the current version on a client, run [`tailscale version`](#version).

Examples:

Update to the latest version within your current track (stable or unstable, depending on what you're running):

```shell
tailscale update
```

Update to the latest version within your current track without using interactive prompts:

```shell
tailscale update --yes
```

Update to Tailscale v1.34:

```shell
tailscale update --version=1.34.0
```

Update to the latest unstable version:

```shell
tailscale update --track=unstable
```

### [web](#web)

Start a web server for controlling the `tailscaled` daemon. Starting a web server is useful when the CLI or a native app is impractical (such as on NAS devices).

```shell
tailscale web [flags]
```

Available flags:

-   `--cgi=<true|false>` Run the web server as a CGI script. Defaults to false.
-   `--listen=<ip|name>` Set the listen address. Use port `0` for automatic. Defaults to `localhost:8088`.
-   `--origin=<hostname>` Origin at which the web UI is served (if behind a reverse proxy or used with CGI).
-   `--prefix=<string>` Set the URL prefix added to requests (for CGI or reverse proxies).
-   `--readonly` Run the web server in read-only mode.

### [whois](#whois)

Get the machine and user associated with a Tailscale IP.

```shell
tailscale whois ip[:port]
```

For user devices, this command returns:

```markup
Machine:
  Name:
  ID:
  Addresses:
  AllowedIPs:
User:
  Name:
  ID:
Capabilities:
```

For devices that are tagged, this command returns:

```markup
Machine:
  Name:
  ID:
  Addresses:
  AllowedIPs:
  Tags:
Capabilities:
```

For each of these fields:

-   `Machine`, `Name` is the [machine name](https://tailscale.com/kb/1098/machine-names) of the device. If you use [MagicDNS](https://tailscale.com/kb/1081/magicdns), you can also use this name to connect.
-   `Machine`, `ID` is the [node id](https://tailscale.com/kb/1155/terminology-and-concepts#node) of the device.
-   `Machine`, `Addresses` are the [Tailscale IP](https://tailscale.com/kb/1015/100.x-addresses), which you can use to connect to the device.
-   `Machine`, `AllowedIPs` are the subnet routes available to the device.
-   `Machine`, `Tags` are the tags to which the device belongs.
-   `User`, `Name` is the email address for the owner of the device.
-   `User`, `ID` is the unique ID of the user
-   `Capabilities` show the grants for the device.

Running `tailscale whois` with the `--json` flag will return a machine-readable JSON response. (Note that the `--json` option must come before the `ip[:port]` argument.)

```shell
tailscale whois --json ip[:port]
```

Available flags:

-   `--json` Output in JSON format.
-   `--proto=<proto>` Protocol for the WhoIs request; one of `tcp` or `udp`; empty mans both.

### [appc-routes](#appc-routes)

Print the current [app connector](https://tailscale.com/kb/1281/app-connectors) route status.

By default this command prints the domains configured in the app connector configuration and how many routes have been learned for each domain.

```shell
tailscale appc-routes [flags]
```

Available flags:

-   `--all` Print learned domains and routes and extra policy configured routes.
-   `--map` Print the map of learned domains.
-   `--n` Print the total number of routes this node advertises.
```



### File: 1081-magicdns.md

```markdown
# MagicDNS

MagicDNS automatically registers DNS names for devices in your network.

MagicDNS is available for [all plans](https://tailscale.com/pricing).

If you add a new web server called `my-server` to your network, you no longer need to use its Tailscale IP: using the name `my-server` in your browser's address bar or on the command line will work.

![](/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fmagic-dns.791ba793.png&w=3840&q=75)

MagicDNS does not require a [DNS nameserver](https://tailscale.com/kb/1054/dns#tailscale-dns-settings) if running Tailscale v1.20 or later. Otherwise, your network must have **at least one DNS nameserver set** in the [DNS](https://login.tailscale.com/admin/dns) page of the admin console. These nameservers will receive all DNS queries not handled by MagicDNS.

## [Enabling MagicDNS](#enabling-magicdns)

Tailnets created on or after October 20, 2022 have MagicDNS enabled by default.

If not already enabled, you can enable MagicDNS in the [DNS](https://login.tailscale.com/admin/dns) page of the admin console:

![](/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fmagic-dns-toggle.a34b50f9.png&w=1200&q=75)

## [Accessing devices over MagicDNS](#accessing-devices-over-magicdns)

Once MagicDNS is enabled, any device signed in to your network can access other devices by using their [machine name](https://tailscale.com/kb/1098/machine-names). For example, if you have a server named "monitoring":

-   To SSH into it, run `ssh username@monitoring`
-   To ping it, run `ping monitoring`
-   To open it in your browser, type `monitoring` in your address bar.

Some CLI tools on macOS such as `host` or `nslookup` circumvent system DNS resolution, and will not work with MagicDNS. For example, `host johns-iphone-6s` will not work on macOS, even if `ping johns-iphone-6s` will.

Devices that are [shared with you](https://tailscale.com/kb/1084/sharing) are only accessible via MagicDNS on Tailscale v1.4 or later. You must also use the shared device's [full domain name](#fully-qualified-domain-names-vs-machine-names). For example, `ping webserver.example2.ts.net`.

## [Assigning and editing machine names](#assigning-and-editing-machine-names)

MagicDNS automatically uses a device's [machine name](https://tailscale.com/kb/1098/machine-names) as part of the DNS entry. If you change your device's name, the MagicDNS entry will automatically change.

If you have a specific name you'd like to use to reference your device, then [edit the machine name](https://tailscale.com/kb/1098/machine-names#renaming-a-machine) of the device.

## [Fully qualified domain names vs. machine names](#fully-qualified-domain-names-vs-machine-names)

Under the hood, MagicDNS generates a **fully qualified domain name** for every device on your Tailscale network (known as a tailnet). The fully qualified domain name is made up of two parts:

1.  A [**machine name**](https://tailscale.com/kb/1098/machine-names), which you can change.
2.  Your [**tailnet DNS name**](https://tailscale.com/kb/1217/tailnet-name#tailnet-dns-name). You can view your tailnet DNS name in the [DNS](https://login.tailscale.com/admin/dns) page of the admin console.

![monitoring.yak-bebop.ts.net](/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fmagic-dns-naming.d6fd44e4.png&w=3840&q=75)

Previously, you might have used a [tailnet name](https://tailscale.com/kb/1217/tailnet-name) ending in `.beta.tailscale.net`. If so, migrate to the new tailnet name ending in `.ts.net`. Support for the existing `beta.tailscale.net` name ended on **September 13, 2024**.

The table below shows how some example machine names and domains combine to create the full domain name.

Machine Name

Tailnet Name

Fully Qualified Domain Name

monitoring

yak-bebop.ts.net

`   monitoring.yak-bebop.  ts.net   `

johns-iphone-6s

tailab12.ts.net

`   johns-iphone-6s.tailab12.  ts.net   `

free-form

example.ts.net

`   free-form.example.  ts.net   `

Full domain names can be cumbersome to type, so when you enable MagicDNS, Tailscale automatically adds [search domains](https://tailscale.com/kb/1054/dns#tailscale-dns-settings) to your network. With these search domains you only need to type the machine name to access a device.

For the _yak-bebop_ network, **the following two commands are equivalent**:

```shell
ping monitoring
ping monitoring.yak-bebop.ts.net
```

In most situations, you'll want to use the machine name. But for security reasons, accessing [devices shared with you](https://tailscale.com/kb/1084/sharing) requires using the full domain name.

You can see the full domain name of any device in your network by opening its page from the [Machines](https://login.tailscale.com/admin/machines) page of the admin console.

## [Disabling MagicDNS](#disabling-magicdns)

MagicDNS can be disabled for your whole network by toggling the same button you used to enable it in the [DNS](https://login.tailscale.com/admin/dns) page of the admin console.

If you are experiencing trouble with MagicDNS on a particular device and wish to disable it only there, the current solution is to stop accepting network DNS settings in general.

**On Linux**, stop accepting DNS with:

```shell
tailscale set --accept-dns=false
```

**On macOS**, stop accepting DNS by selecting the Tailscale menubar icon. From here, select **Preferences**, and then you can uncheck **Use Tailscale DNS settings** from the menu.

**On Windows**, stop accepting DNS by holding shift while right-clicking on the Tailscale system tray icon, and unchecking **Use Tailscale DNS** from the menu.

In the future, we will have robust enough DNS configuration and resolution logic that disabling MagicDNS separately will never be necessary. At this point, the toggle will disappear.

## [Removing the `beta.tailscale.net` nameserver](#removing-the-betatailscalenet-nameserver)

Support for the legacy `*.beta.tailscale.net` nameserver ended on **September 13, 2024**. If you haven't already, migrate your tailnet to use the [tailnet DNS name](https://tailscale.com/kb/1217/tailnet-name#tailnet-dns-name) format nameserver. If you are no longer using the `beta.tailscale.net` nameserver, you can delete it. Once deleted, you cannot recover it.

You need to be an [Owner, Admin, or IT admin](https://tailscale.com/kb/1138/user-roles) of a tailnet to remove the `beta.tailscale.net` nameserver.

1.  Open the [DNS](https://login.tailscale.com/admin/dns) page of the admin console.
2.  Under **Nameservers**, look for the nameserver whose name ends in `.beta.tailscale.net`, for example, `yak-bebop.beta.tailscale.net`. (If you don't see a `.beta.tailscale.net` nameserver, there is nothing to delete.)
3.  Select the ![ellipsis icon](/files/images/icons/fa-ellipsis-h.svg) menu and then select **Delete**.
4.  Confirm that you want to delete the `beta.tailscale.net` nameserver and then select **Delete**.
```



### File: 1084-sharing.md

```markdown
# Share your machines with other users

Sharing is currently [in beta](https://tailscale.com/kb/1167/release-stages#beta). To try it, follow the steps below to enable it for your network using Tailscale v1.4 or later.

Sharing is available for [all plans](https://tailscale.com/pricing).

You can share access to specific machines with people outside your Tailscale network (known as a tailnet) without exposing them to the public internet. Sharing gives the recipient access to only the shared machine in your tailnet, and nothing else.

Users in your tailnet can access all machines as governed by [access control policies](https://tailscale.com/kb/1393/access-control); sharing a machine is only required for allowing external users to access a machine.

Sharing respects the access control policies and [MagicDNS](#sharing-and-magicdns) settings of both your tailnet and the recipient's tailnet. Sharing strips [tags](https://tailscale.com/kb/1068/tags), [groups](https://tailscale.com/kb/1337/policy-syntax#groups), and [subnet](#sharing--subnets-subnet-routers) information from the recipient tailnet. A shared machine is visible only to the individual recipient user-it is not visible to the recipient user's entire tailnet.

## [Share a machine with another user](#share-a-machine-with-another-user)

You need to be an [Owner, Admin, or IT admin](https://tailscale.com/kb/1138/user-roles) of a tailnet to share a machine.

To share a machine:

1.  Open the [Machines](https://login.tailscale.com/admin/machines) page of the admin console and find the machine you'd like to share.
2.  Send invites [via email](#share-using-email) or [manually via links](#share-using-a-link).
3.  [Wait for the recipient to accept](#wait-for-the-recipient-to-accept).

After the recipient accepts the invite, they can access the shared machine from their Tailscale clients and admin console, as if it was on their own tailnet. For example, the macOS app will display it in the menu bar, and Linux apps will see it from `tailscale status`.

Notes about shared machines:

-   Tailscale [quarantines](#quarantine) shared machines by default. A shared machine can receive incoming connections (from the other user's tailnet) but cannot start connections. This means users can accept shares without exposing their tailnet to risks.
-   As of Tailscale v1.4, shared machines appear in the other tailnet as the sharer, not the owner of the machine. If Ross shares his co-worker Dave's machine to another tailnet, it will appear to be owned by Ross in the new tailnet.
-   Unused invite links expire after 30 days.

A machine cannot be shared with a tag or accessed by tagged machines on another tailnet, as only users can accept machine shares.

### [Share using email](#share-using-email)

When you send invites via email, each specified recipient receives a single-use invite link to your machine. The recipient does not need to have a Tailscale account with the same email address. They can log in and accept the share from any Tailscale account.

1.  Select the ![ellipsis icon](/files/images/icons/fa-ellipsis-h.svg) menu, then select **Share** to open the **Share** dialog.
2.  Select **Share via email** tab.
3.  Add the email address for each user that you want to send invite links.
4.  Select **Share** to send email invitations to each listed email address.

### [Share using a link](#share-using-a-link)

For invite links you plan to share manually, you can choose to make a single-use or reusable invite link. A single-use invite link is a one-time use link. A reusable invite link can be used up to 1,000 times. Unused links expire in 30 days for both single-use and reusable invite links.

1.  Select the ![ellipsis icon](/files/images/icons/fa-ellipsis-h.svg) menu, then select **Share** to open the **Share** dialog.
2.  Select **Copy invite link** tab.
3.  (Optional): Toggle on **Reusable link** for a link that can be accepted more than once.
4.  Select **Copy share link** to create the link and copy it to your clipboard.
5.  Share the copied invite link to your intended recipient. Treat the invite link the way you would a password. It provides the ability to connect to a machine within your tailnet.

### [Wait for the recipient to accept](#wait-for-the-recipient-to-accept)

A recipient needs to be an [Owner, Admin, or IT admin](https://tailscale.com/kb/1138/user-roles) of a tailnet to accept a shared machine invitation.

The recipient can visit the invite link to review your invitation. After they accept, you can see their profile picture and email address in the **Share** dialog. You'll also see an indicator in the **Machines** list on the admin console showing which machines have been shared to external users.

Unused invite links expire after 30 days.

## [Revoke an invite](#revoke-an-invite)

You need to be an [Owner, Admin, or IT admin](https://tailscale.com/kb/1138/user-roles) of a tailnet to revoke a share or share invite.

You can revoke a share or share invite from the [Machines](https://login.tailscale.com/admin/machines) page of the admin console. After you revoke an invite, the recipient user can no longer access the shared machine. To restore access, you must create a new invite and the recipient must accept that new invite.

To revoke an invite:

1.  Go to the [Machines](https://login.tailscale.com/admin/machines) page of the admin console.
2.  Select the **Share** option for the machine.
3.  Select the ![ellipsis icon](/files/images/icons/fa-ellipsis-h.svg) menu > **Revoke invite**.

## [How sharing works](#how-sharing-works)

Sharing a machine exposes that machine to a user on another tailnet. Only that user is able to see and access your machine. It is invisible to other users on that tailnet.

![In this example, only the shared machine from tailnet A and the share recipient's machines in tailnet B can talk across tailnet boundaries.](/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fsharing-access.91254a95.png&w=3840&q=75)

In this example, only the shared machine from tailnet A and the share recipient's machines in tailnet B can talk across tailnet boundaries.

When you accept an invite, Tailscale exposes the minimum set of information possible about your tailnet to that machine. Accepting an invite exposes:

-   The email and avatar of the recipient (required to help confirm invites)
-   Physical machine IPs of machines from your tailnet (required for connections)

### [Quarantine](#quarantine)

Shared machines are quarantined by default. They can respond to incoming connections from the tailnet they're shared to, but cannot initiate connections on their own. Quarantining helps sharing be "secure by default", since you can accept shares with no risk of exposing your tailnet.

### [Sharing and MagicDNS](#sharing-and-magicdns)

[MagicDNS](https://tailscale.com/kb/1081/magicdns) is a per-tailnet setting. If your tailnet has MagicDNS enabled, you can access machines over MagicDNS regardless of the other tailnet's settings.

Shared machines support MagicDNS in Tailscale v1.4 or later. Shared machines can only be reached by using their fully qualified domain name, which looks like `<hostname>.<tailnet-name>.ts.net`.

-   `<hostname>` is the name of a machine.
-   `<tailnet-name>` is the [tailnet name](https://tailscale.com/kb/1217/tailnet-name) of a tailnet.

For example, if your friend shares a machine named `minecraft-server` on the `yak-bebop` tailnet to your tailnet, you can reach it at `minecraft-server.yak-bebop.ts.net`. However, you can't reach it at `minecraft-server` from your tailnet.

Previously, you might have used a tailnet DNS name ending in `.beta.tailscale.net`. If so, migrate to the new tailnet DNS name that ends in `.ts.net`. Support for the `beta.tailscale.net` name ended on **September 13, 2024**.

These restrictions are necessary to prevent MagicDNS names from changing unexpectedly, and to support future features on top of sharing.

### [Sharing and access control policies](#sharing-and-access-control-policies)

When a user accepts a share, the user can make outbound requests to the shared machine, which will adhere to any [access control policies](https://tailscale.com/kb/1393/access-control) defined in the tailnet that owns the shared machine.

By default, the shared machine is quarantined and cannot make outbound requests to the user's machines. However, it's possible to "mutually share" machines, allowing the machines to make outbound connections to each other.

For example, if you have `workstation-1` (owned by `example-company-tailnet`) and `workstation-2` (owned by `sam@example.com`) and you want `workstation-1` and `workstation-2` to have access to each other, you would:

1.  Share workstation-1 with `alice@example.com`.
2.  Share workstation-2 with `alice@example-company.com`.

If you're [having trouble connecting to a shared machine](#troubleshooting), review your tailnet policy file for rules that might be blocking access.

To write [access rules](https://tailscale.com/kb/1337/policy-syntax#acls) that apply to a shared machine, you can use the email address of the recipient. For example, if you invite `alice@example.com` to share a machine at `100.74.78.2`, you can give Alice access to a particular host.

```json
"grants": [
 {
   "src": ["group:admins"],
   "dst": ["*"],
   "ip": ["*"]
 },
 {
   "src": ["alice@example.com"],
   "dst": ["100.74.78.2"],
   "ip": ["*"]
 }
]
```

You can use the [visual policy editor](https://tailscale.com/kb/1550/visual-editor) to manage your tailnet policy file. Refer to the [visual editor reference](https://tailscale.com/kb/1587/visual-editor-reference) for guidance on using the visual editor.

Be careful of rules like `"src": ["*"]`, which apply to everyone who has access to your tailnet, including invited users. Consider making a group that includes all your tailnet users instead of `*`.

You can also write access rules by using the special `autogroup:shared` group. This group automatically includes all users invited to your tailnet, and lets you write rules without knowing email addresses in advance.

For example, to restrict invited users to only access web server ports `80` and `443`, you can write a rule like:

```json
"grants": [
 // Admins can access everything in the tailnet.
 {
   "src": ["group:admins"],
   "dst": ["*"],
   "ip": ["*"]
 },
 // Shared users can only access port 80 and 443 of machines they are invited to.
 {
   "src": ["autogroup:shared"],
   "dst": ["*"],
   "ip": ["80", "443"]
 }
]
```

You can use the [visual policy editor](https://tailscale.com/kb/1550/visual-editor) to manage your tailnet policy file. Refer to the [visual editor reference](https://tailscale.com/kb/1587/visual-editor-reference) for guidance on using the visual editor.

Remember: invited users are only able to access machines you've invited them to share. Access rules further limit what they can access. Although the rule `*:80,443` seems like it allows access to all machines, it only further restricts their access to the ports we've specified.

Sharing does not expose [tag](https://tailscale.com/kb/1068/tags) to the other tailnet. All tag information is stripped and cannot be used in the tailnet policy file of the other tailnet.

### [Sharing and Subnets (subnet routers)](#sharing-and-subnets-subnet-routers)

Shared machines do not advertise [subnets](https://tailscale.com/kb/1019/subnets) to the tailnets they're shared into, while [inviting](https://tailscale.com/kb/1271/invite-any-user) external users into your tailnet will give them access to subnet routers.

### [Sharing and Exit Nodes](#sharing-and-exit-nodes)

Sharing an [exit node](https://tailscale.com/kb/1103/exit-nodes) exposes it to the other tailnet.

To share an exit node, use the following sequence:

1.  [Advertise the machine as an exit node](https://tailscale.com/kb/1103/exit-nodes#advertise-a-device-as-an-exit-node).

2.  If you are not using [`autoApprovers`](https://tailscale.com/kb/1337/policy-syntax#autoapprovers), [allow the exit node from the admin console](https://tailscale.com/kb/1103/exit-nodes#allow-the-exit-node-from-the-admin-console).

3.  Share the machine per the instructions above, allowing the recipient to use it as an exit node. Ensure the **Allow use as an exit node** option is checked.


If a [user is deleted](https://tailscale.com/kb/1145/remove-team-members), the shared machines they manage will be deleted. If a user is suspended, the shared machines they manage will not be able to connect to other machines.

### [Sharing and suspended or deleted users](#sharing-and-suspended-or-deleted-users)

When you [delete a user](https://tailscale.com/kb/1145/remove-team-members), it also deletes the shared machines they manage. If you suspend a user, Tailscale prevents the shared machines they manage from connecting to other machines.

### [Sharing and Tailnet Lock](#sharing-and-tailnet-lock)

A node shared into a tailnet with [Tailnet Lock](https://tailscale.com/kb/1226/tailnet-lock) requires a signature before it is accessible.

To share nodes out of a tailnet with Tailnet Lock, the user who accepts the share invite needs to have their nodes signed in the locked tailnet before they can access the shared node.

### [Sharing and rewards](#sharing-and-rewards)

Every time you share a machine with a unique user, and they accept the invitation, Tailscale increases the device limit on both accounts by two. This applies to every unique domain that accepts a machine you shared. The rewards apply automatically when a user accepts an invitation, and the increased device limit shows on device limits on the [Billing](https://login.tailscale.com/admin/settings/billing) page of the admin console.

### [Troubleshooting](#troubleshooting)

If you can see that a machine that was shared with you, but you can't connect to it:

-   If you're trying to access the machine by [machine name](https://tailscale.com/kb/1098/machine-names) (and not [100.x.y.z](https://tailscale.com/kb/1015/100.x-addresses) address), ensure you have [MagicDNS enabled](https://tailscale.com/kb/1081/magicdns). You can enable MagicDNS from the [DNS](https://login.tailscale.com/admin/dns) page of the admin console.
-   Review your tailnet's [access control policies](https://tailscale.com/kb/1393/access-control) to see if you have any rules that might disallow access. If you don't, it's possible the tailnet that shared it with you is restricting the traffic. Ask them to review their access control policies too.
```



### File: 1085-auth-keys.md

```markdown
# Auth keys

Auth keys are available for [all plans](https://tailscale.com/pricing).

Pre-authentication keys (called auth keys) let you register new nodes without needing to sign in using a web browser. This is most useful when spinning up containers, IoT devices, or using infrastructure-as-code systems like Terraform.

An auth key authenticates a device as the user who generated the key. That is, if Alice generates an auth key, and uses it to add a server to her tailnet, then that device is authenticated with Alice's identity. Think of it as logging into a device.

However, if you use [tags](https://tailscale.com/kb/1068/tags#best-practices) with an auth key, after a device logs in as the user who generated the auth key, the device assumes the identity of the auth key's tags.

As an alternative to directly creating auth keys, consider using an [OAuth client](https://tailscale.com/kb/1215/oauth-clients). You can use an OAuth client and the [Tailscale API](https://tailscale.com/kb/1101/api) to programmatically create auth keys.

## [Types of auth keys](#types-of-auth-keys)

Auth keys can either be:

-   **One-off**, for one-time use. They can only be used to connect a device or server one time. This is meant for situations where you can't authenticate on the device yourself, so using a key is more practical. For example, a cloud server might use a one-off key to connect.
-   **Reusable**, for multiple uses. They can be used to connect multiple devices. For example, multiple instances of an on-premises database might use a reusable key to connect.

**Be very careful with reusable keys!** These can be very dangerous if stolen. They're best kept in a key vault product specially designed for the purpose.

## [Key expiry](#key-expiry)

An auth key automatically expires after the number of days you specified when you generated the key. You can choose the number of days, between 1 and 90 inclusive, for the key expiry. If you don't specify an expiry time, the auth key will expire after the maximum of 90 days. If you want to continue using an auth key after it expires, you need to generate a new key.

You can enable or disable key expiry on a device by using the [Machines](https://login.tailscale.com/admin/machines) page of the admin console and by using the [Update device key](https://tailscale.com/api#tag/devices/POST/device/%7BdeviceId%7D/key) method in the [Tailscale API](https://tailscale.com/kb/1101/api).

If an auth key expires, any device authorized by it remains authorized until its [node key](https://tailscale.com/kb/1028/key-expiry) expires. Each device generates a node key when you log in to Tailscale and uses it to identify itself to the tailnet. By default, node keys automatically expire every 180 days. You can change the default node key expiry from the **Key Expiry** section of the [Device management](https://login.tailscale.com/admin/settings/device-management) page of the admin console.

[Learn more about key management](https://tailscale.com/blog/tailscale-key-management#node-keys).

### [Key expiry for tagged devices](#key-expiry-for-tagged-devices)

Key expiry for [tagged](https://tailscale.com/kb/1068/tags#best-practices) devices is disabled by default. If you change the tags on the device through the admin console, [Tailscale CLI](https://tailscale.com/kb/1080/cli), or [Tailscale API](https://tailscale.com/kb/1101/api), the device's key expiry will not change unless you re-authenticate. That is, if it is enabled, it stays enabled; and if it is disabled, it stays disabled. After you re-authenticate, the device's key expiry will be disabled.

You can find recently revoked or expired keys on the [Keys](https://login.tailscale.com/admin/settings/keys) page of the admin console.

## [Generate an auth key](#generate-an-auth-key)

You must be an [Owner, Admin, IT admin, or Network admin](https://tailscale.com/kb/1138/user-roles) of a tailnet to generate a key.

To generate an auth key:

1.  Open the [Keys](https://login.tailscale.com/admin/settings/keys) page of the admin console.

2.  Select **Generate auth key**.

3.  Fill out the form fields to specify characteristics about the auth key, such as the description, [whether its reusable](#types-of-auth-keys), when it expires, and device settings.

    The device settings section lets you set special characteristic for the auth key:

    -   Enable **Ephemeral** to automatically remove the auth key after the device goes offline.
    -   Enable **Pre-approved** to automatically authorize a device if you have [device approval](https://tailscale.com/kb/1099/device-approval) enabled for your tailnet.
    -   Enable **Tags** to automatically [tag](https://tailscale.com/kb/1068/tags#best-practices) devices that use the auth key.
4.  Select **Generate key**.


## [Register a node with the auth key](#register-a-node-with-the-auth-key)

When you register a node, use the `--auth-key` option in the [`tailscale up`](https://tailscale.com/kb/1241/tailscale-up) command to supply the key and bypass interactive login:

```shell
sudo tailscale up --auth-key=tskey-abcdef1432341818
```

Tailscale-generated auth keys are case-sensitive.

## [Revoke an auth key](#revoke-an-auth-key)

You must be an [Owner, Admin, IT admin, or Network admin](https://tailscale.com/kb/1138/user-roles) of a tailnet to revoke a key. And you can revoke only your own keys. Tailscale automatically revokes [one-off keys](https://tailscale.com/kb/1085/auth-keys#authkey-one-off) after they are used.

To revoke a key:

1.  Open the [Keys](https://login.tailscale.com/admin/settings/keys) page of the admin console.
2.  Locate the key in the table at the bottom, and select **Revoke**.

Revoking a key does not deauthorize nodes using the key. To deauthorize a node, delete it from the [Machines](https://login.tailscale.com/admin/machines) page.

## [Best practices](#best-practices)

Depending on what devices you're authenticating, consider using an auth key that is:

-   **Ephemeral**, for authenticating [ephemeral nodes](https://tailscale.com/kb/1111/ephemeral-nodes) as part of short-lived workloads. Because node keys do not persist when a workload restarts, they reconnect as a different node. Tailscale automatically removes inactive nodes. For example, containers or Lambda functions should use an ephemeral key to connect.
-   **Pre-approved**, for servers. If your tailnet has [device approval](https://tailscale.com/kb/1099/device-approval) enabled, this lets you add a device to your tailnet without further authorization. For example, shared devices, such as servers, should use a pre-approved auth key to connect in a network with device approval.
-   **Pre-signed**, for nodes whose auth keys are signed locally on a [signing node](https://tailscale.com/kb/1226/tailnet-lock#add-a-node-to-a-locked-tailnet), which applies to tailnets with [Tailnet Lock](https://tailscale.com/kb/1226/tailnet-lock) enabled. You can make an auth key (created by any means) pre-signed only by using the [`tailscale lock sign`](https://tailscale.com/kb/1243/tailscale-lock#lock-sign) CLI command.
-   **Tagged**, for servers. You can automatically apply a tag to a device by including the [tag](https://tailscale.com/kb/1068/tags#best-practices) in the auth key. Access control policies restricting the device's permissions based on the tag apply after provisioning the device. For example, shared devices, such as servers, should use a tagged auth key to connect.
```



### File: 1088-run-unattended.md

```markdown
# Keep Tailscale running when I'm not logged in to my computer

On Linux, Tailscale runs as the system, and is available even when no users are logged in.

For other platforms Tailscale runs as the logged in user, not as the system. This means that if a device is restarted, or multiple users are logged in at the same time, Tailscale won't automatically connect.

On Windows, you can solve this by using "Run Unattended" mode. This configures Tailscale to run as the system instead of the currently logged in user. For example, a machine running Windows Server Edition might want to enable this to permit multiple users to connect via RDP at once.

On macOS, there's no ability to run as the system just yet. You can follow [this GitHub issue for updates](https://github.com/tailscale/tailscale/issues/987).
```



### File: 1100-services.md

```markdown
# Viewing the list of endpoints on your network

Tailscale's endpoint collection feature lets you monitor and easily connect to the endpoints running on machines in your Tailscale network.

The endpoint collection view is currently [in alpha](https://tailscale.com/kb/1167/release-stages#alpha).

## [What are endpoints?](#what-are-endpoints)

Endpoints are the network-exposed ports running on each of your Tailscale machines, defined by their `port` and `protocol`. If your network has enabled endpoint collection, each of your machines will share its live list of endpoints with your Tailscale network.

## [Enabling endpoint collection](#enabling-endpoint-collection)

This feature is disabled by default, meaning that endpoint data is never collected or shared between your devices unless you choose to enable endpoint collection. You can change this setting on the [Services](https://login.tailscale.com/admin/services) page of the admin console, after selecting the **Discovered** tab.

![The 'Enable endpoint collection to start' prompt with a 'Enable endpoint collection' button.](/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fenable-services-collection-button.ccdeb183.png&w=1200&q=75)

Although endpoint collection is a global setting for your Tailscale network, endpoints will not be sent from any machines that are [blocking incoming connections](https://tailscale.com/kb/1072/client-preferences).

## [Monitoring your endpoints](#monitoring-your-endpoints)

With endpoint collection enabled, your admin console will display the list of endpoints on your network. We don't currently store endpoints in our database, so the view acts as a monitoring tool for _live_ endpoints. As you start and stop endpoints, you'll see the view reflect those changes.

Below is a preview of the **Discovered** tab on the [Services](https://login.tailscale.com/admin/services) page.

![The Discovered tab of the Services page of the admin console listing example endpoints filtered by 'type:HTTP'.](/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fservices-view.aa352060.png&w=1200&q=75)

An endpoints table is also visible on each machine's details page with just the endpoints exposed by that machine.

![The Machine details page of the admin console with information about the machine's network and a list of endpoints exposed on the tailnet.](/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fmachine-services.7b5a1252.png&w=1200&q=75)

The endpoints tables includes a `type` column. We categorize endpoints into types to help you better identify them. Our categorization rules are basic and will be tuned over time, so note that if you use an uncommon port, we may fallback to "Other" type.

## [Launching endpoints](#launching-endpoints)

From the endpoints tables, you can directly launch certain applications.

-   For SSH, we show a copyable `ssh 100.x.y.z` command.
-   For VNC and [RDP](https://tailscale.com/kb/1095/secure-rdp-windows), we show a one-select **Launch** button to start a remote session.
-   For HTTP and HTTPs, we show a one-select **Open** button to open the web server.

## [Access controls](#access-controls)

You can configure the access for each of your endpoints using [Tailscale access control policies](https://tailscale.com/kb/1393/access-control). If you're interested in knowing who can access each endpoint, hover over the info icon in the **Access Controls** column of the **Endpoints** table.

![The endpoints preview with a tooltip stating 'Who can access this endpoint?'. In this example, 'group:all' and 'group:coop' are listed.](/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fservices-acls.63967316.png&w=1920&q=75)

If someone has [shared](https://tailscale.com/kb/1084/sharing) a machine from another network with you, their machine's shared ports will be visible in your endpoints list. Note that for shared machines you will _only_ see the endpoints that the sharer has given you access to via their network's access control policies.
```



### File: 1101-api.md

```markdown
# Tailscale API

The Tailscale API is available for [all plans](https://tailscale.com/pricing).

Tailscale offers an application programming interface (API) to let you automate various aspects of your network.

[Visit our interactive API documentation →](https://tailscale.com/api)

## [Authentication](#authentication)

You need to be an [Owner, Admin, IT admin, or Network admin](https://tailscale.com/kb/1138/user-roles) of a tailnet to generate an access token.

Requests to the API are authenticated via an access token (sometimes called an API key), which can be generated from the [Keys](https://login.tailscale.com/admin/settings/keys) page of the admin console. You can choose the number of days, between 1 and 90 inclusive, for the key expiry. Also note that Tailscale-generated API access tokens are case-sensitive.

This access token will automatically expire after the chosen number of days. If you want to continue using an access token after this access token expires, you need to generate a new access tokens. Access tokens can also be revoked before their expiration. Recently expired and revoked access token are shown on the [Keys](https://login.tailscale.com/admin/settings/keys) page.

As an alternative to an access token that has full permission to the Tailscale API, use [OAuth clients](https://tailscale.com/kb/1215/oauth-client) to provide delegated fine-grained control to the Tailscale API.

More details about authenticating with the API can be [found in our interactive API docs](https://tailscale.com/api).
```



### File: 1103-exit-nodes.md

```markdown
# Exit nodes (route all traffic)

Exit nodes are available for [all plans](https://tailscale.com/pricing).

By default, Tailscale acts as an overlay network: it only routes traffic between devices running Tailscale, but doesn't touch your public internet traffic, such as when you visit Google or Twitter. The overlay network configuration is ideal for most people who need secure communication between sensitive devices (such as company servers or home computers), but don't need extra layers of [encryption](https://tailscale.com/kb/1504/encryption) or latency for their public internet connection.

![A diagram showing four devices in a Tailscale overlay network. A laptop is making a direct connection to google.com.](/_next/static/media/exit-node-01.0573451b.svg)

However, there might be times when you want Tailscale to route your public internet traffic. For example, you might want to route all your public internet traffic if:

-   You're in a coffee shop with untrusted Wi-Fi.
-   You're traveling overseas and need access to an online service (such as banking) only available in your home country.

![A diagram showing four devices in a Tailscale overlay network where one is highlighted in blue and designated as an exit node. The laptop makes its connection to google.com through the Desktop device designated as an exit node.](/_next/static/media/exit-node-02.0e4f672e.svg)

You can route all your public internet traffic by setting a device on your network as an exit node. When you route all traffic through an exit node, you're effectively using [default routes](https://en.wikipedia.org/wiki/Default_route) (`0.0.0.0/0`, `::/0`), similar to how you would if you were using a typical VPN.

## [Benefits](#benefits)

-   **Secure all traffic**-exit nodes secure all traffic, including traffic to internet sites and applications
-   **Scale globally**-deploy exit nodes around the globe to meet your scale and geographical needs
-   **Increase visibility**-[destination logging](#destination-logging-in-network-flow-logs) provides increased visibility of traffic across the tailnet and forensic analysis during security incidents

## [Use cases](#use-cases)

-   **Traveling workforce**-ensure all internet traffic is secured for your traveling workforce regardless of the physical network they're using
-   **Testing from different geos**-test your applications from different geographies by deploying and selecting exit nodes around the globe
-   **Meet compliance needs**-if you have regulatory or compliance needs that require your workforce to use a VPN, exit nodes can help

## [How it works](#how-it-works)

The exit node feature lets you route all traffic through a specific device on your Tailscale network (known as a tailnet). The device routing your traffic is called an **exit node**. There are many ways to use exit nodes in a tailnet. For example, you can:

-   Route all non-Tailscale traffic through an exit node.
-   Use [suggested exit nodes](https://tailscale.com/kb/1392/auto-exit-nodes) to [automatically use the best exit node](https://tailscale.com/kb/1392/auto-exit-nodes) based on client information, such as location and latency.
-   [Force devices to use an exit node](https://tailscale.com/kb/1413/mandatory-exit-nodes) based on system policies, which you can deploy using mobile device management (MDM) solutions.

For security purposes, you must opt in to exit node functionality. For example:

-   Every device must explicitly opt in to using an exit node.
-   A device must advertise itself as an exit node.
-   An [Owner, Admin, or Network admin](https://tailscale.com/kb/1138/user-roles) must allow a device to be an exit node for the tailnet.

By default, exit nodes capture all your network traffic. You can customize the type of traffic to pass through your exit nodes using [subnet routers](https://tailscale.com/kb/1019/subnets), [app connectors](https://tailscale.com/kb/1281/app-connectors), or [app-based split tunneling](https://tailscale.com/kb/1444/android-app-split-tunneling) on Android.

### [Local network access](#local-network-access)

By default, the device connecting to an exit node won't have access to its local network. If you want to allow the device access to its local network when routing traffic through an exit node, enable exit node local network access.

You can enable the **Allow Local Network Access** setting from the **Exit Nodes** section of your Tailscale client. You can also enable this setting by passing `--exit-node-allow-lan-access` to [`tailscale up`](https://tailscale.com/kb/1241/tailscale-up) or [`tailscale set`](https://tailscale.com/kb/1080/cli#set).

## [Get started](#get-started)

Refer to the [Use exit nodes](https://tailscale.com/kb/1408/quick-guide-exit-nodes) quickstart guide for basic instructions on how to configure and use exit nodes.

To get started with exit nodes:

1.  Understand the [prerequisites](#prerequisites).
2.  [Configure a device to act as an exit node](#configure-an-exit-node).
3.  [Allow the exit node from the admin console](#allow-the-exit-node-from-the-admin-console).
4.  [Configure other devices to use the exit node](#use-the-exit-node).

### [Prerequisites](#prerequisites)

Before you can configure an exit node, you must:

-   [Set up a Tailscale network (known as a tailnet)](https://tailscale.com/kb/1017/install).
-   Ensure both the exit node and devices using the exit node run **Tailscale v1.20 or later**.
-   Ensure the exit node is a Linux, macOS, Windows, Android, or tvOS device.
-   Ensure you allow (intended) users to use the exit node.
    Check your tailnet's [ACLs](https://tailscale.com/kb/1018/acls) and [grants](https://tailscale.com/kb/1324/grants).

If your tailnet is using the [default ACL](https://tailscale.com/kb/1192/acl-samples#allow-all-default-acl), users of your tailnet already have access to any exit nodes that you configure. If you have modified your ACL, ensure you create an [access rule](https://tailscale.com/kb/1337/policy-syntax#acls) that includes exit node uses in the `autogroup:internet`. They do not need access to the exit node itself to use the exit node.

The following example [ACL](https://tailscale.com/kb/1018/acls) lets all users access to the internet through an exit node:

```json
// All users can use exit nodes
// If you are using the default ACL, this rule is not needed because the
// default ACL allows all users access to the internet through an exit node
{ "action": "accept", "src": ["autogroup:member"], "dst": ["autogroup:internet:*"] },
```

You can use the [visual policy editor](https://tailscale.com/kb/1550/visual-editor) to manage your tailnet policy file. Refer to the [visual editor reference](https://tailscale.com/kb/1587/visual-editor-reference) for guidance on using the visual editor.

### [Configure an exit node](#configure-an-exit-node)

Use the following steps to configure an exit node:

1.  [Install the Tailscale client](#install-the-tailscale-client).
2.  [Advertise the device as an exit node](#advertise-a-device-as-an-exit-node).
3.  [Allow the exit node](#allow-the-exit-node-from-the-admin-console).
4.  [Use the exit node](#use-the-exit-node).

You can also [get a suggested exit node](https://tailscale.com/kb/1392/auto-exit-nodes#use-a-suggested-exit-node).

#### [Install the Tailscale client](#install-the-tailscale-client)

[Android](https://tailscale.com/kb/1103/exit-nodes?tab=android)[Linux](https://tailscale.com/kb/1103/exit-nodes?tab=linux)[macOS](https://tailscale.com/kb/1103/exit-nodes?tab=macos)[tvOS](https://tailscale.com/kb/1103/exit-nodes?tab=tvos)[Windows](https://tailscale.com/kb/1103/exit-nodes?tab=windows)

[Download and install Tailscale](https://tailscale.com/download/android) onto the Android device you plan to use as an exit node.

#### [Advertise a device as an exit node](#advertise-a-device-as-an-exit-node)

[Android](https://tailscale.com/kb/1103/exit-nodes?tab=android)[Linux](https://tailscale.com/kb/1103/exit-nodes?tab=linux)[macOS](https://tailscale.com/kb/1103/exit-nodes?tab=macos)[tvOS](https://tailscale.com/kb/1103/exit-nodes?tab=tvos)[Windows](https://tailscale.com/kb/1103/exit-nodes?tab=windows)

Open the Tailscale client on the Android device, go to **Exit Node** and select **Run as exit node**.

### [Allow the exit node from the admin console](#allow-the-exit-node-from-the-admin-console)

You must be an [Admin](https://tailscale.com/kb/1138/user-roles) to allow a device to be an exit node.

If the device is authenticated by a user who can approve exit nodes in [`autoApprovers`](https://tailscale.com/kb/1337/policy-syntax#autoapprovers), the exit node will automatically be approved.

1.  Open the [Machines](https://login.tailscale.com/admin/machines) page of the admin console and locate the exit node.
2.  Locate the **Exit Node** badge in the machines list or use the [`property:exit-node`](https://login.tailscale.com/admin/machines?q=property%3Aexit-node) filter to list all devices advertised as exit nodes.

From the ![ellipsis icon](/files/images/icons/fa-ellipsis-h.svg) menu of the exit node, open the **Edit route settings** panel, and enable **Use as exit node**.

### [Use the exit node](#use-the-exit-node)

Each device must enable the exit node separately. The instructions for enabling an exit node vary depending on the device's operating system.

[Android](https://tailscale.com/kb/1103/exit-nodes?tab=android)[iOS](https://tailscale.com/kb/1103/exit-nodes?tab=ios)[Linux](https://tailscale.com/kb/1103/exit-nodes?tab=linux)[macOS](https://tailscale.com/kb/1103/exit-nodes?tab=macos)[tvOS](https://tailscale.com/kb/1103/exit-nodes?tab=tvos)[Windows](https://tailscale.com/kb/1103/exit-nodes?tab=windows)

1.  Open the Tailscale app on the Android device and go to the **Exit Node** section.
2.  Select the exit node that you want to use. If you want to allow direct access to your local network when routing traffic through an exit node, toggle **Allow LAN access** on.
3.  On the app home screen, confirm that the selected device displays in the **Exit Node** section. When an exit node is being used for the device, the section will turn blue.

To stop a device from using an exit node, go to the **Exit Node** section and select **None**.

The option to use an exit node only displays if there's an available exit node in your tailnet.

You can verify that your traffic is routed by another device by checking your public IP address [using online tools](https://www.whatismyip.com). The exit node's public address displays rather than your local device's IP address.

You can turn off routing through an exit node by selecting **None** from the **Exit Node** drop-down.

## [Destination logging in network flow logs](#destination-logging-in-network-flow-logs)

Destination Logging is available for [Enterprise](https://tailscale.com/pricing).

By default, destination logging is disabled for traffic flowing through an exit node across all tailnets, for privacy, abuse, and security purposes. Tailnets on the Enterprise plan can, however, enable destination logging across the tailnet for increased visibility of traffic across the tailnet and forensic analysis during security incidents. Destinations are logged in [Network flow logs](https://tailscale.com/kb/1219/network-flow-logs).

You must enable [log streaming](https://tailscale.com/kb/1255/log-streaming) before using exit node destination logging.

To enable destination logging for exit nodes:

1.  Open the [Logs](https://login.tailscale.com/admin/logs) page of the admin console.
2.  Select **Network flow logs**.
3.  Select the **Logging Actions** menu, then select **Enable exit node destination logging**.

To disable destination logging for exit nodes:

1.  Open the [Logs](https://login.tailscale.com/admin/logs) page of the admin console.
2.  Select **Network flow logs**.
3.  Select the **Logging Actions** menu, then select **Disable exit node destination logging**.

## [Caveats](#caveats)

[Android](https://tailscale.com/kb/1103/exit-nodes?tab=android)[Linux](https://tailscale.com/kb/1103/exit-nodes?tab=linux)[macOS](https://tailscale.com/kb/1103/exit-nodes?tab=macos)[tvOS](https://tailscale.com/kb/1103/exit-nodes?tab=tvos)[Windows](https://tailscale.com/kb/1103/exit-nodes?tab=windows)

Tailscale support for running exit nodes on Android is still undergoing optimization. Make sure you plug the device into a power source if you plan to use it as an exit node for an extended time. Android exit nodes are limited to userspace routing.

Running an exit node on an Android device is not performant-it may be too slow for most cases.

### [Userspace](#userspace)

On Android, the exit node is implemented in userspace, which differs from the default Linux exit node implementation and is not as mature or fully optimized. For details, refer to [Kernel vs. netstack subnet routing and exit nodes](https://tailscale.com/kb/1177/kernel-vs-userspace-routers).
```



### File: 1106-taildrop.md

```markdown
# Taildrop

Taildrop is currently [in alpha](https://tailscale.com/kb/1167/release-stages#alpha).

Taildrop is available for [all plans](https://tailscale.com/pricing).

Taildrop lets you send files between your personal devices on a Tailscale network (known as a tailnet).

Like all traffic sent over Tailscale, Taildrop transfers files over encrypted peer-to-peer connections, using the fastest available path. This makes it a great solution for sending sensitive or large files without third-party servers in the middle.

Taildrop is in public alpha, with many planned improvements to the user interface and capabilities. To try Taildrop, you must [opt-in for your network](#enable-taildrop-for-your-network).

## [Enable Taildrop for your network](#enable-taildrop-for-your-network)

Because Taildrop is an alpha feature, you must opt-in your tailnet to the feature to use it. You can do so from the [General](https://login.tailscale.com/admin/settings/general) settings page of the admin console, by turning on the **Send Files** feature.

## [Client setup](#client-setup)

Except for network access storage (NAS) devices, Taildrop does not require client setup other than [installing Tailscale](https://tailscale.com/kb/1347/installation).

If you need to set up Taildrop for a NAS device, refer to [Taildrop with NAS devices](https://tailscale.com/kb/1418/taildrop-nas).

## [Send files with Taildrop](#send-files-with-taildrop)

You can transfer any kind of file with Taildrop.

Taildrop is currently limited to sending files between your own personal devices. You cannot send files to devices owned by other users (even users on the same Tailscale network).

Taildrop permits you to share files between devices that you are logged in to, even if access control policies are used to restrict access to the devices. You cannot use Taildrop to send files to and from nodes you have tagged.

Taildrop also requires both devices to be running Tailscale.

[macOS](https://tailscale.com/kb/1106/taildrop?tab=macos)[iOS](https://tailscale.com/kb/1106/taildrop?tab=ios)[Windows](https://tailscale.com/kb/1106/taildrop?tab=windows)[Android](https://tailscale.com/kb/1106/taildrop?tab=android)[Linux](https://tailscale.com/kb/1106/taildrop?tab=linux)

Before using Taildrop for the first time, it must be enabled in **System Settings** > **General** > **Login Items & Extensions** > **Sharing**. Enable sharing for **Tailscale**.

![Enable the Tailscale app in System Settings > General > Login Items & Extensions > Sharing > Enable Tailscale](/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fmacos-extension.066cb1e6.png&w=3840&q=75)

Send files to other devices via the right-click **Share** menu.

![Send files by right-clicking and choosing Share > Tailscale](/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fmacos-send.5c856aa7.png&w=3840&q=75)

### [Resume interrupted transfers](#resume-interrupted-transfers)

If your Taildrop file transfer is interrupted, you can retry the transfer and Taildrop will attempt to resume the transmission where it left off. This is especially useful when transferring large files. In most cases, a transfer can be resumed for up to an hour after it failed. For now, Taildrop can resume transfers on all platforms except when a macOS or iOS device is receiving the file.

## [Receive files with Taildrop](#receive-files-with-taildrop)

[macOS](https://tailscale.com/kb/1106/taildrop?tab=macos)[iOS](https://tailscale.com/kb/1106/taildrop?tab=ios)[Windows](https://tailscale.com/kb/1106/taildrop?tab=windows)[Android](https://tailscale.com/kb/1106/taildrop?tab=android)[Linux](https://tailscale.com/kb/1106/taildrop?tab=linux)

Files received on macOS will be placed in the `~/Downloads` directory.

## [Example: Securely transfer sensitive documents from your computer to mobile device for easier on-the-go access](#example-securely-transfer-sensitive-documents-from-your-computer-to-mobile-device-for-easier-on-the-go-access)

Finding a way to transfer sensitive files (such as medical or tax documents) between your devices can be fairly involved. Cloud-based transfer or file storage solutions carry the security and vulnerability risks of having your documents accessible via the internet. Airdrop works without needing to upload anything to the internet, but only between Apple devices and only when they're close to one another.

Taildrop provides an easy way to share your sensitive files between any of your devices. And no matter where your devices are, the files are sent over encrypted peer-to-peer connections. So, you're guaranteed the only machines that will ever have access to the files during the transfer are the sending and receiving devices.

## [Example: Send family photos from your phone to your computer](#example-send-family-photos-from-your-phone-to-your-computer)

Taildrop lets you share your photos cross-platform without needing to upload them anywhere.

## [Example: Share screenshots to your computer](#example-share-screenshots-to-your-computer)

Ever take screenshots or screen recordings but don't actually need them on the device you captured them on? Here at Tailscale we take a lot of screenshots of our client apps during the development process that we then have to transfer to our computers so we can upload them to a desktop tool such as GitHub or Figma. Taildrop helps you quickly transfer these, so you can seamlessly switch back and forth between working on the sending and receiving devices.

## [Example: Transfer Google Photos albums to a personal photos server](#example-transfer-google-photos-albums-to-a-personal-photos-server)

If you're looking to transfer your photos out of Google Photos and to a personal media server, Taildrop may be able to help you out. The steps below describe how to move an album from Google Photos to a remote personal machine.

**Steps:**

1.  From your computer's browser, go to the Google Photos website and select an album.

2.  In the top right corner, select the rightmost menu item and choose **Download all**.

    ![](/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fgoogle-photos-1.30ca135a.jpg&w=1080&q=75)

3.  This will download a zip file of the album to your computer. If this computer is the end destination that you want your photos on, you can stop here, no need to Taildrop.

4.  But if you want to transfer your photos to a remote device (maybe a device you've dedicated as a media server), you can right-click on the zip file and choose to share with Taildrop.

    ![](/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fgoogle-photos-2.1126f1a3.jpg&w=750&q=75)

5.  From the Taildrop modal, select your media server and the zip file will be transferred to that device.

    ![](/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fgoogle-photos-3.74759702.jpg&w=750&q=75)

    ![](/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fgoogle-photos-4.25987a7f.jpg&w=750&q=75)

6.  After the transfer completes, you can delete the zip file from your original device.
```



### File: 1111-ephemeral-nodes.md

```markdown
# Ephemeral nodes

Ephemeral nodes make it easier to connect and then clean up short-lived devices such as containers, cloud functions, or CI/CD systems that spin up and spin down on a regular basis.

By default, when you add a new device to your Tailscale network, it appears in the [Machines](https://login.tailscale.com/admin/machines) page of the admin console and in Tailscale client apps. However, short-lived devices can make your network difficult to check, as devices remain in the admin console until removed.

Ephemeral nodes differ from regular nodes in a few ways:

-   They are auto-removed from your network after a short period of inactivity. The next time an ephemeral node is created, it will have a new IP address.
-   They are immediately removed from your network if you run [`tailscale logout`](https://tailscale.com/kb/1080/cli#logout).
-   They can only be created using [ephemeral auth keys](https://tailscale.com/kb/1085/auth-keys) (not through the regular authentication flow) or by running the `tailscaled` daemon with the `state=mem:` flag.

To avoid updating [every device's netmap](https://tailscale.com/kb/1087/device-visibility) when an ephemeral device is added to the Tailscale network, consider using an ephemeral [tagged auth key](https://tailscale.com/kb/1068/tags#best-practices), and update [access control policies](https://tailscale.com/kb/1393/access-control) to restrict what tagged devices can access. If you are deploying multiple instances of the same container, use a [reusable auth key](https://tailscale.com/kb/1085/auth-keys) instead of baking the Tailscale node key into the container image to avoid [duplicate devices](https://tailscale.com/kb/1023/troubleshooting#multiple-devices-have-the-same-100x-ip-address).

You can identify ephemeral nodes in the [Machines](https://login.tailscale.com/admin/machines) page of the admin console by looking for an "Ephemeral" badge underneath the device name.

## [Authenticating an ephemeral node](#authenticating-an-ephemeral-node)

### [Step 1: Generate an ephemeral auth key](#step-1-generate-an-ephemeral-auth-key)

To create an ephemeral node, you'll first need to generate an ephemeral auth key from the [Keys](https://login.tailscale.com/admin/settings/keys) of the admin console.

![The Settings page of the admin console with the 'Generate auth key' dialog. The setting for ephemeral keys toggled on.](/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fephemeral-keys.de85b7fd.png&w=750&q=75)

**Be careful with auth keys!** These can be very dangerous if stolen. They're best kept in a key vault product specially designed for the purpose.

The **Pre-approved** option will only display in the dialog if [device approval](https://tailscale.com/kb/1099/device-approval) is enabled in your Tailscale network.

### [Step 2: Configure your infrastructure to use the key](#step-2-configure-your-infrastructure-to-use-the-key)

The simplest way to do this is to update your usual scripts to use the new auth key:

```shell
sudo tailscale up --auth-key=<your ephemeral key>
```

Instructions vary by platform. Refer to our guides on setting up common platforms:

-   [Tailscale on Heroku](https://tailscale.com/kb/1107/tailscale-on-heroku)
-   [Tailscale on Google Cloud Run](https://tailscale.com/kb/1108/tailscale-on-gcr)
-   [Tailscale on GitHub Actions](https://tailscale.com/blog/2021-05-github-actions-and-tailscale)
-   [Tailscale on AWS Lambda](https://tailscale.com/kb/1113/tailscale-on-aws-lambda)
-   [Tailscale on Kubernetes](https://tailscale.com/kb/1185/kubernetes)

### [Step 3: Trigger a build](#step-3-trigger-a-build)

The next time your infrastructure spins up a new device, it appears in the [Machines](https://login.tailscale.com/admin/machines) page of the admin console as an ephemeral node. It will be able to connect to your network, and will be auto-removed shortly after going offline.

### [FAQ](#faq)

#### [Can an ephemeral device remove itself from my tailnet?](#can-an-ephemeral-device-remove-itself-from-my-tailnet)

Yes. Run the [`tailscale logout`](https://tailscale.com/kb/1080/cli#logout) command on an ephemeral device to remove it from your tailnet immediately. For example, you can add `tailscale logout` as a last step in your ephemeral node deployment script to immediately remove it from your tailnet when the script completes.

Another way is if you created an ephemeral device by running `tailscaled` with the `--state=mem:` flag. If the device is running Tailscale v1.30 or later, when the device exits, the `tailscaled` daemon itself performs `tailscale logout` which immediately removes the device from your tailnet.

#### [How long before ephemeral devices are auto-removed?](#how-long-before-ephemeral-devices-are-auto-removed)

Ephemeral devices are auto-removed anywhere from 30 minutes to 48 hours after the last activity. This timeframe is subject to change as we learn more about what works best for Tailscale users. If you want to remove an ephemeral device immediately, run [`tailscale logout`](https://tailscale.com/kb/1080/cli#logout) as described above.

#### [Can I create an ephemeral node without an auth key?](#can-i-create-an-ephemeral-node-without-an-auth-key)

Yes, running Tailscale v1.22 or later. You can run `tailscaled` with the `--state=mem:` flag. `tailscaled` is the Tailscale daemon that runs on devices that have installed the Tailscale client. The `--state=mem:` flag registers the node as an ephemeral node so that the daemon stores state in memory, instead of writing it to disk.
```



### File: 1114-pi-hole.md

```markdown
# Block ads on all your devices from anywhere using a Raspberry Pi

Online ads slow down browsing, reduce privacy, and create security risks. They can track activity without consent, carry malicious code, and many consume extra data and battery life with large images, animations, and videos. Ads can also interrupt the experience with pop-ups and auto-playing content. Blocking ads can help stop trackers, speed up browsing, save data, and make websites cleaner and easier to use.

One method to block ads on devices in a network is to install [Pi-hole](https://pi-hole.net) software on a Raspberry Pi device. Pi-hole acts as your network's DNS server and filters requests to ad and tracking servers before they reach devices, providing protection across the network without requiring additional software on the devices themselves.

Combining Pi-hole with Tailscale provides the same protection beyond a home network. Tailscale creates a secure, private network that lets users remotely use the Pi-hole DNS server anywhere, enabling consistent ad blocking and privacy benefits at home, on public Wi-Fi, or while traveling.

The benefits of blocking ads using a Raspberry Pi and Pi-hole with a Tailscale network (known as a tailnet) include:

-   Ad blocking on your devices, whether you're at home or away.
-   A Raspberry Pi is a cost-effective hardware solution.
-   A Raspberry Pi consumes very little power, so you can always leave it on and connected.
-   Pi-hole is a free and open source software.
-   Tailscale is free with the Personal plan that supports up to three users and 100 devices.

While the instructions in this topic describe how to configure Pi-hole as the DNS server for blocking ads in your tailnet, you can also configure your router's DNS settings to point to the Raspberry Pi to use Pi-hole ad blocking across your entire network.

## [Prerequisites](#prerequisites)

To follow this guide, you need:

-   A device, such as a phone or laptop, to log in and create the tailnet. Tailscale runs on most operating systems, including Linux, Windows, macOS, iOS, and Android.
-   An email account that uses a [single sign-on (SSO) identity provider](https://tailscale.com/kb/1013/sso-providers), such as Apple, Google, or Microsoft.
-   A Raspberry Pi Model B or later, with a minimum of 2 GB of free space and 512 MB of RAM.
-   Raspberry Pi OS (latest version) installed on your Raspberry Pi.
-   Access to the Raspberry Pi OS command line interface (CLI). If you want to use the Raspberry Pi OS desktop, you can use the Terminal application. If you want to access the Raspberry Pi from another computer in your network, you'll need access to the CLI using a terminal client or command prompt on your computer.

## [Step 1: Install and configure Pi-hole](#step-1-install-and-configure-pi-hole)

To install Pi-hole directly from the Raspberry Pi OS desktop, open the Terminal application. If you want to access the Raspberry Pi from another computer in your network, you can access the CLI from a terminal client or command prompt using the command `ssh <username>@<ip-address>`, where `<username>` is the user name and `<ip-address>` is the local IP address for the Raspberry Pi.

Make sure your Raspberry Pi software packages are up to date:

```shell
sudo apt update
sudo apt upgrade -y
```

Now download and install Pi-hole:

```shell
curl -sSL https://install.pi-hole.net | bash
```

Attackers can exploit `curl` with `| bash`. Review the code contained in this script before installing. You can do so by visiting the `https://install.pi-hole.net` URL from a web browser. Alternatively, you can install Pi-hole using [another method](https://docs.pi-hole.net/main/basic-install/).

An installer displays in the terminal session, where you can configure the basic Pi-hole settings. Configure the initial setup for Pi-hole and access the Pi-hole web admin interface.

-   Select **OK** to proceed.
-   In the **Static IP Address** section, select **Yes** to use the current IP address for the Raspberry Pi, and select **Continue**. This ensures the Raspberry Pi always has the same address and devices can reach the Pi-hole DNS server consistently and reliably. Alternatively, you can select **Skip** and configure a static IP address for the Raspberry Pi in your router's DHCP settings.
-   In the **Select Upstream DNS Provider** section, select a common DNS provider, then select **OK**. Pi-hole only blocks ads for the lists of sites that are configured in its settings. If Pi-hole does not recognize the site, it passes the request to the DNS server that you specify here.
-   In the **Blocklists** section, select **Yes** to use the [Steven Black unified host list](https://github.com/StevenBlack/hosts). This is a reliable and community-maintained block list that combines many ad, tracker, and malware lists into one single list for broad protection.
-   In the **Web Admin Interface** section, select **Yes** to install the GUI interface that lets you manage all the Pi-hole settings.
-   In the **Web Server** section, select **Yes**, as this is necessary to use the web admin interface.
-   In the **Enable Query Logging** section, select whether you want Pi-hole to record every DNS request your devices make. You can use this information to modify the settings in Pi-hole to suite your needs.
-   In the **Select a privacy mode for FTL**, select the level of detail that Pi-hole logs collect, then select **Continue**. The installer returns you to the command line.

Before you access the Pi-hole web admin interface, change your Pi-hole password from the default, which is blank. To do this, use the following command, then enter and re-enter your new password:

```shell
pihole -a -p
```

After the initial setup is complete, go to `http://<raspberry-pi>/admin`, where `<raspberry-pi>` is the IP address for the Raspberry Pi and enter the new password.

When a device connects to a tailnet, it's assigned a `100.x.x.x` IP address on the `tailscale0` interface, in addition to the existing local IP address, such as `192.168.x.x` on interface `eth0`. So you need to configure Pi-hole to listen on the Tailscale interface.

In the Pi-hole web admin interface, go to **Settings**, then **DNS**, and in the upper right-hand corner, toggle the **Basic** button to **Expert** to display advanced settings. Within the **Interface settings** section, check the **Permit all origins** box.

If you enable **Permit all origins**, ensure:

-   Your Raspberry Pi is behind a firewall.
-   You secure the Pi-hole web admin interface with a strong password to reduce security risks.

Next, you'll create your personal tailnet.

## [Step 2: Create your tailnet](#step-2-create-your-tailnet)

To create a tailnet, [download](https://tailscale.com/download) and install the client on a device such as a phone or laptop, and log in using your existing identity provider. Choose the **Personal** option and follow the remaining instructions to complete the process. Your personal tailnet is now configured and ready to use.

![Select a type of tailnet.](/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fwelcome-page.f3b91c91.png&w=1080&q=75)

Now go to the [Machines](https://login.tailscale.com/admin/machines) page of the admin console to confirming it's connected to your tailnet. The admin console is where you can manage the users, devices, and permissions for your tailnet.

![Machines page of the admin console.](/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fmachines-page.4014fd44.png&w=1080&q=75)

Next, you'll install and configure Tailscale on your Raspberry Pi.

## [Step 3: Install Tailscale on your Raspberry Pi](#step-3-install-tailscale-on-your-raspberry-pi)

To install the Tailscale client, open a terminal session or use the same one from the previous section if it's still open. Then use the following command to download and install the Tailscale package:

```shell
curl -fsSL https://tailscale.com/install.sh | sh
```

Now enable the Tailscale client and instruct the Raspberry Pi not to automatically use the DNS settings for your tailnet, since the Raspberry Pi is the DNS server.

```shell
sudo tailscale up --accept-dns=false
```

When you run the [`tailscale up`](https://tailscale.com/kb/1241/tailscale-up) command for the first time, a URL displays in the terminal. Paste the URL into a web browser and log in with the same email address you used to set up our tailnet. You can do this from any device you want, such as a phone or a laptop. Once logged in, go to the [Machines](https://login.tailscale.com/admin/machines) page of the admin console and locate the Raspberry Pi in the list to confirm that it's added to your tailnet.

Devices in a tailnet are occasionally required to re-authenticate to keep your network secure. To avoid DNS interruptions, go to the [Machines](https://login.tailscale.com/admin/machines) page of the admin console, select the ![ellipsis icon](/files/images/icons/fa-ellipsis-h.svg) button next to the Raspberry Pi, then select **Disable key expiry**.

Next, you'll configure your tailnet DNS settings to point to the Raspberry Pi.

## [Step 4: Set Raspberry Pi as the DNS server for your tailnet](#step-4-set-raspberry-pi-as-the-dns-server-for-your-tailnet)

To configure the Raspberry Pi as the DNS server for your tailnet, go to the [DNS](https://login.tailscale.com/admin/dns) page of the admin console, and in the **Nameservers** section, select **Add nameserver**, then **Custom**. Then enter the IP address for the Raspberry Pi, select **Save**, and enable the **Override DNS servers** toggle.

![Configure a custom DNS server in the admin console.](/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fconfigure-dns.a3d7f209.gif&w=1080&q=75)

When your devices connect to the tailnet, they use the Raspberry Pi as the DNS server to block most ads. When they're not connected to the tailnet, they use the DNS server set up on the local network, such as your home router.

To verify that your device is using Pi-hole for ad blocking, visit a website that you know contains ads, and they will not display for most sites. You can also try turning the Tailscale client off to make the ads re-appear, then re-enable the Tailscale client.

You can also configure your router's DNS settings to point to the Raspberry Pi to use Pi-hole ad blocking across your entire network.

## [Conclusion](#conclusion)

In this guide, you set up a Raspberry Pi with Pi-hole and connected it to your tailnet using Tailscale. This configuration gives you an always-on way to block ads and stop trackers, whether you're at home, on public Wi-Fi, or traveling. By routing DNS requests through your Pi-hole, you maintain a cleaner, faster, and more private browsing experience across all your devices, wherever you are.

The Pi-hole application is highly configurable, so be sure to browse the settings and choose what's best suited for your needs. For information, refer to the official [Pi-hole documentation](https://docs.pi-hole.net/main/).

## [Further exploration](#further-exploration)

-   [Add additional devices](https://tailscale.com/kb/1316/device-add) to your tailnet.
-   [Invite other users](https://tailscale.com/kb/1271/invite-any-user) to your tailnet to let them route their device traffic.
-   Configure your Raspberry Pi to [route your tailnet traffic](https://tailscale.com/kb/1408/quick-guide-exit-nodes) for secure browsing wherever you are.
-   Configure your Raspberry Pi as a [subnet router](https://tailscale.com/kb/1406/quick-guide-subnets) to let you remotely access home network devices that don't have Tailscale installed, such as printers or smart home devices.
-   Use [Control D](https://tailscale.com/kb/1403/control-d) or [NextDNS](https://tailscale.com/kb/1218/nextdns) as an alternative for ad blocking in your tailnet.
```



### File: 1115-high-availability.md

```markdown
# Set up high availability

When using [subnet routers](https://tailscale.com/kb/1019/subnets) or [app connectors](https://tailscale.com/kb/1281/app-connectors) in large networks, you may want to set up high availability to ensure users of your network can continue to access resources if one routing device goes offline, or to increase performance across a global workforce. Tailscale offers two methods of building redundancy into a network.

## [Failover](#failover)

Failover is available for [the Personal, Personal Plus, Starter, Premium, and Enterprise plans](https://tailscale.com/pricing).

Failover lets customers deploy _overlapping connectors_ (that is, app connectors that advertise the same apps, or subnet routers that advertise the same routes). In a failover scheme, one connector is used at a time by all clients. If it goes offline another connector is used. Connector selection occurs in the order of the dates when you added the connectors to the tailnet. The oldest connector is the "primary", and failover occurs in oldest-first order. Failover can take up to ~15 seconds after a primary connector goes offline.

Failover is the default behavior: overlapping connectors will automatically exhibit this behavior, which is available on all plans.

## [Regional routing](#regional-routing)

Regional routing is available for [the Premium and Enterprise plans](https://tailscale.com/pricing).

Regional routing lets customers deploy a global fleet of _overlapping connectors_ (that is, app connectors that advertise the same apps, or subnet routers that advertise the same routes). Overlapping connectors are grouped into regions that map to Tailscale's [DERP regions](https://tailscale.com/kb/1232/derp-servers).

Upon connecting to Tailscale, client devices identify which regional routing group is closest to them by finding the closest DERP server. This works by having clients report their latencies to the nearest active DERP servers, after which clients are assigned a regional routing group. Each client is then instructed to send traffic bound to a given applicable destination directly to the closest connector. The client re-evaluates its choice of regional routing group periodically. If a region no longer has available connectors, another region is used, giving the network global high availability and improved performance for a global workforce.

If multiple overlapping connectors exist within a region, the specific connector used within that region depends on one of two behaviors:

### [In-region load balancing (default)](#in-region-load-balancing-default)

Within a [DERP region](https://tailscale.com/kb/1232/derp-servers), if multiple overlapping connectors exist, then load is spread evenly across the connectors on a best-effort basis. The algorithm is as follows: each client has a stable pseudorandom order of routing preference for the set of nodes in a region. If the top preferred node is unavailable the client is directed to the next most preferred node. As a side effect, this behavior creates a "stickiness": clients will be routed to a specific connector within a region, unless that connector is unavailable.

### [In-region failover](#in-region-failover)

An admin can request to disable in-region load balancing and instead opt for in-region failover when regional routing is enabled. To disable in-region load balancing while regional routing is enabled, [contact support](https://tailscale.com/contact/support) and request in-region failover when using regional routing. Failover exhibits the behavior described in [Failover](#failover), limited to the scope of a single DERP region.

### [Enabling regional routing for your tailnet](#enabling-regional-routing-for-your-tailnet)

1.  Open the [General](https://login.tailscale.com/admin/settings/general) settings page of the admin console.
2.  Enable the **Regional Routing** option.

The traffic for Tailscale clients will automatically be routed to the nearest region with an active overlapping connector. This is a global preference; all overlapping connectors will exhibit the same tailnet-wide settings.

### [Example use cases for regional routing](#example-use-cases-for-regional-routing)

#### [On-ramping remote employees to transit backbones](#on-ramping-remote-employees-to-transit-backbones)

You can use subnet routers in conjunction with regional routing to on-ramp remote employee traffic to transit gateways such as AWS Transit Gateway, Google Cloud Interconnect, Azure ExpressRoute, and other virtual private transit providers. By placing a subnet router in front of each network on-ramp point, regional routing will automatically route device traffic on to the transit provider as quickly as possible.

#### [Connecting to a globally replicated application or VPC](#connecting-to-a-globally-replicated-application-or-vpc)

You can use subnet routers in conjunction with regional routing to connect to applications or VPCs that are globally replicated across your cloud provider's regions, or across multiple cloud providers. By placing a subnet router in front of each application or VPC, regional routing will automatically route device traffic on to the nearest version of that application or VPC. When using this methodology, the application must be available from the same set of IP addresses within the same high availability subnet route. In this way, you can easily deploy and connect to a globally distributed application, with multi-cloud failover built right in.

#### [Connecting to a SaaS app for a global workforce](#connecting-to-a-saas-app-for-a-global-workforce)

You can use app connectors alongside regional routing to connect to SaaS apps from a globally distributed workforce to increase performance for your entire organization, while maintaining necessary [access controls](https://tailscale.com/kb/1393/access-control). By placing an app connector near each office or branch, regional routing will automatically route device traffic on to the nearest app connector, and out to the target SaaS app. In this way you can deploy and connect to SaaS, with performance and reliability built right in.

## [App connector high availability](#app-connector-high-availability)

### [Step 1: Set up multiple app connectors](#step-1-set-up-multiple-app-connectors)

Follow [our guide to configure app connectors](https://tailscale.com/kb/1281/app-connectors), assigning all app connectors to the same [tag](https://tailscale.com/kb/1068/tags). For example, to create multiple app connectors on the `tag:connector`, you'll want to run a command like this on 2+ machines.

```shell
sudo tailscale up --advertise-connector --advertise-tags="tag:connector"
```

### [Step 2: Assign an app to the app connectors](#step-2-assign-an-app-to-the-app-connectors)

Follow [our guide to configure app connectors](https://tailscale.com/kb/1281/app-connectors), assigning an app to multiple app connectors by using the same `tag:connector` [tag](https://tailscale.com/kb/1068/tags).

### [Step 3: Done](#step-3-done)

Once you have 2+ app connectors exposing the same apps on the same network, the Tailscale control server will automatically manage the failover between the different connectors. In failover mode, if an app connector is disconnected from the control plane for more than 15 seconds, traffic will be routed to another app connector. In regional routing mode, if the connectors are in different regions, clients will be assigned to each based on their closest available DERP region.

## [Subnet router high availability](#subnet-router-high-availability)

### [Step 1: Set up multiple subnet routers](#step-1-set-up-multiple-subnet-routers)

Follow [our guide to configure subnet routers](https://tailscale.com/kb/1019/subnets), exposing the same routes on the same network on 2+ devices. For example, to expose `10.0.0.0/24,10.1.0.0/24`, you'll want to run a command like this on 2+ devices.

```shell
sudo tailscale set --advertise-routes=10.0.0.0/24,10.1.0.0/24
```

You can configure as many subnet routers as you want to act as a failover.

Only _matching_ advertised routes will be configured for failover. Route prefixes are not expanded for failover.

For example, if multiple subnet routers are configured with `--advertise-routes=10.0.0.0/24,10.0.100.0/24`, both routes can be used for failover, whereas one subnet router configured with `--advertise-routes=10.0.0.0/24,10.0.100.0/24` and another configured with `--advertise-routes=10.0.0.0/16` will not be used for failover.

Subnet routers can advertise matching but disparate routes and be used for failover for the matching routes, but in practice this is not recommended.

When setting up subnet routers for high availability (HA), be careful with the `--accept-routes` flag. If you turn on `--accept-routes` for subnet routers that share the same routes in the same region, the standby router will accept its own advertised routes from the primary router.

This leads to an inefficient routing path. The standby router will send traffic for its directly connected subnet through the primary router instead. For example, if both subnet routers advertise and accept the same route, such as `192.168.1.0/24`, the standby router will send all `192.168.1.0/24` traffic through the primary router, even though it is directly connected to that network.

For most HA subnet router setups, use the `--advertise-routes` flag alone. Avoid using `--accept-routes` unless you specifically need that routing behavior.

### [Step 2: Activate the subnet routers in the admin console](#step-2-activate-the-subnet-routers-in-the-admin-console)

Open the [Machines](https://login.tailscale.com/admin/machines) page of the admin console, locate your subnet router and using the ![ellipsis icon](/files/images/icons/fa-ellipsis-h.svg) menu at the end of the table, select **Review subnet routes**. This will open up the Subnet settings.

Select **Enable** on your routes so that Tailscale distributes the subnet routes to the rest of the nodes on your Tailscale network.

You may want to disable key expiry on your server to avoid having to periodically reauthenticate. Refer to [key expiry](https://tailscale.com/kb/1028/key-expiry) for more information about machine keys and how to disable their expiry.

### [Step 3: Done](#step-3-done-1)

Once you have 2+ subnet routers exposing the same route on the same network, the Tailscale control server will automatically manage the failover between the different routers. In failover mode, if a subnet router is disconnected from the control plane for more than 15 seconds, traffic will be routed to another subnet router. In regional routing mode, if the subnet routers are in different regions, clients will be assigned to each based on their closest available DERP region.

## [Limitations](#limitations)

-   Regional routing does not use [custom DERP servers](https://tailscale.com/kb/1118/custom-derp-servers). Refer to [issue #12993](https://github.com/tailscale/tailscale/issues/12993) for updates.
```



### File: 1151-what-is-tailscale.md

```markdown
# What is Tailscale?

Tailscale is a mesh VPN (Virtual Private Network) service that streamlines connecting devices and services securely across different networks. It enables encrypted point-to-point connections using the open source [WireGuard](https://www.wireguard.com) protocol, which means only devices on your private network can communicate with each other.

Unlike traditional VPNs, which tunnel all network traffic through a central gateway server, Tailscale creates a peer-to-peer mesh network (known as a tailnet). However, you can still use Tailscale like a traditional VPN by routing all traffic through an [exit node](https://tailscale.com/kb/1103/exit-node).

![A user in Charleston connecting to a computer in New York City through a gateway in San Diego. This results in high latency because the gateway is on the opposite coast.](/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Ftraditional-vpn.0e10936c.png&w=3840&q=75)

Figure 1(a). The central gateway may or may not be close to users, thus resulting in higher latency. Because traffic is centralized, it can also act as a bottleneck, slowing down connections further.

![The same user in Charleston connecting to the New York City computer directly, thanks to Tailscale.](/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Ftailscale.4c5aa989.png&w=3840&q=75)

Figure 1(b). With Tailscale, each device is connected to the other directly, resulting in lower latency.

The Tailscale approach avoids centralization where possible, resulting in both [higher throughput](https://tailscale.com/blog/more-throughput) and lower latency as network traffic can flow directly between devices. Additionally, decentralization improves stability and reliability by reducing single points of failure.

## [The benefits](#the-benefits)

Some [key advantages of Tailscale](https://tailscale.com/why-tailscale) include secure and private connections between devices, a flexible network topology, and a streamlined setup. Tailscale is also cross-platform, infrastructure agnostic, highly configurable, and has a collection of [features](https://tailscale.com/features) and [integrations](https://tailscale.com/integrations).

### [Streamlined setup](#streamlined-setup)

Although Tailscale is highly configurable, it's easy to get started. Unlike traditional VPNs that require extensive configuration, server setup, and networking expertise, you can deploy a Tailscale network (known as a tailnet) in minutes. After you create an account, authenticating two or more devices automatically creates a tailnet with a sensible set of [default access policies](https://tailscale.com/kb/1192/acl-samples#allow-all-default-acl).

Connections between tailnet devices work seamlessly across firewalls and [Network Address Translation (NAT)](https://tailscale.com/blog/how-nat-traversal-works) without requiring port forwarding or complex firewall rules. This "zero config" approach dramatically reduces the technical barriers to implementing secure networking, making it accessible to technical and non-technical users.

### [Security and privacy](#security-and-privacy)

The [Tailscale security model](https://tailscale.com/security) is built on modern, proven technologies and best practices such as end-to-end [encryption](https://tailscale.com/kb/1504/encryption) and a [zero-trust architecture](https://tailscale.com/kb/1123/zero-trust). At its core, Tailscale uses WireGuard, a state-of-the-art VPN protocol known for its security and performance. This foundation is enhanced by Tailscale's commitment to [compliance](https://tailscale.com/security#compliance-and-certifications), [security policies](https://tailscale.com/security-policies), and [security features](https://tailscale.com/security#security-features) such as [access control policies](https://tailscale.com/kb/1393/access-control) and [Tailnet Lock](https://tailscale.com/kb/1226/tailnet-lock).

### [Scalability and adaptability](#scalability-and-adaptability)

Tailscale's [flexible](https://tailscale.com/why-tailscale#flexible-topology) architecture is designed to grow seamlessly with your organization's needs. Whether you're scaling from a small team to a large enterprise or expanding across multiple geographic locations, Tailscale maintains its [performance](https://tailscale.com/blog/more-throughput) and security characteristics at scale. The distributed nature of its architecture means that adding new devices or users doesn't create bottlenecks that typically plague traditional VPN solutions.

## [Who's it for?](#whos-it-for)

With its low barrier to getting started, versatility, and powerful capabilities, Tailscale seamlessly scales from personal use to [enterprise](https://tailscale.com/enterprise) deployments. Developers can use it to share work-in-progress features with their team, home lab enthusiasts can use it to [access their media servers remotely](https://tailscale.com/use-cases/homelab), and businesses can use it to [secure their distributed workforce](https://tailscale.com/use-cases/zero-trust-networking)-all without the hassle and overhead of traditional VPN setup and maintenance.

To learn more, take a deep-dive into [how Tailscale works](https://tailscale.com/blog/how-tailscale-works), learn about [Tailscale use cases](https://tailscale.com/kb/1377/use-cases), or check out [what people say about Tailscale](https://tailscale.com/customers).

## [Get started](#get-started)

Getting started is as simple as creating an account, installing the Tailscale client, and logging into two or more devices. Visit the [quickstart guide](https://tailscale.com/kb/1017/install) to learn more.

To stay in touch, [sign up for our newsletter](https://tailscale.com/blog#blog-newsletter). You can also follow us on [Twitter](https://twitter.com/tailscale), [Hachyderm](https://hachyderm.io/@tailscale), or [YouTube](https://www.youtube.com/@Tailscale).
```



### File: 1153-enabling-https.md

```markdown
# Enabling HTTPS

Connections between Tailscale nodes are secured with end-to-end [encryption](https://tailscale.com/kb/1504/encryption). Browsers, web APIs, and products like Visual Studio Code are not aware of that, however, and can warn users or disable features based on the fact that HTTP URLs to your tailnet services look unencrypted since they're not using TLS certificates, which is what those tools are expecting.

To protect a website with an HTTPS URL, you need a TLS certificate from a public Certificate Authority (CA).

This feature uses the active [tailnet name](https://tailscale.com/kb/1217/tailnet-name) for your tailnet.

## [Configure HTTPS](#configure-https)

To be able to provision TLS certificates for devices in your tailnet, you need to:

1.  Open the [DNS](https://login.tailscale.com/admin/dns) page of the admin console.
2.  Enable [MagicDNS](https://tailscale.com/kb/1081/magicdns#enabling-magicdns) if not already enabled for your tailnet.
3.  Under **HTTPS Certificates**, select **Enable HTTPS**.
4.  Acknowledge that your machine names and your tailnet DNS name will be published on a public ledger.
5.  For each machine you are provisioning with a TLS certificate, run `tailscale cert` on the machine to obtain a certificate.

### [Machine names in the public ledger](#machine-names-in-the-public-ledger)

All TLS certificates on the web are recorded in the [Certificate Transparency](https://en.wikipedia.org/wiki/Certificate_Transparency) (CT) append-only public ledger, which anyone can access to verify the validity of public certificates. Notably, this includes the fully qualified domain name of your devices. To avoid publicizing your organization name, such as your corporate domain, email address, or GitHub username, Tailscale provides you with a [tailnet name](https://tailscale.com/kb/1217/tailnet-name). Each tailnet has a [tailnet DNS name](https://tailscale.com/kb/1217/tailnet-name#tailnet-dns-name) like **tail_NNNN_.ts.net** or **tailnet-_NNNN_.ts.net**, but you can also [generate and select a randomized tailnet DNS name](https://tailscale.com/kb/1217/tailnet-name#generate-a-new-tailnet-dns-name) generated by Tailscale, like **yak-bebop.ts.net**.

TLS certificates are issued based in your tailnet name. Right now, we don't permit changing your tailnet name (other than between your default tailnet DNS name and your randomly generated tailnet name).

Although the certificate domain obscures the owner of the tailnet, the machine names are still published in the public ledger. **Do not enable the HTTPS feature if any of your machine names contain sensitive information.** You can [edit your machine name](https://tailscale.com/kb/1098/machine-names/#renaming-a-machine) before obtaining a certificate.

The public ledger only provides information about the names of the TLS certificates; access to your devices is still restricted by Tailscale as normal. Additionally, only devices where you run `tailscale cert` will have their certificate in the public ledger.

To summarize, the domain name that gets published on the public ledger is composed as follows:

![monitoring.yak-bebop.ts.net where 'monitoring' is the machine-name and 'yak-bebop.ts.net' is the tailnet name](/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fhttps-naming.f9bb79de.png&w=3840&q=75)

[MagicDNS](https://tailscale.com/kb/1081/magicdns) automatically registers DNS names for devices in your network, using their machine name. If the machine name changes, the MagicDNS entry will change. You can [edit your machine name](https://tailscale.com/kb/1098/machine-names#renaming-a-machine) to set it to a specific name.

You cannot obtain an HTTPS URL to go to a bare hostname, such as `https://machine-name`. If you obtain a TLS certificate for a node using MagicDNS, it will be accessible at both `https://machine-name.tailNNNN.ts.net`, using HTTPS, and also at `http://machine-name`, without HTTPS but using MagicDNS as a DNS nameserver.

### [Provision TLS certificates for your devices](#provision-tls-certificates-for-your-devices)

Using [`tailscale cert`](https://tailscale.com/kb/1080/cli#cert) (with `sudo` as needed), Tailscale will automatically request a certificate for this machine on this domain, using [Let's Encrypt](https://letsencrypt.org). Tailscale creates a `*.ts.net` DNS TXT record for your nodes to complete their [DNS-01 challenges](https://letsencrypt.org/docs/challenge-types/#dns-01-challenge). If you're using Go, the [`tailscale.com/client/tailscale.LocalClient.GetCertificate`](https://pkg.go.dev/tailscale.com/client/tailscale#LocalClient.GetCertificate) method implements the [`tls.Config.GetCertificate`](https://pkg.go.dev/crypto/tls#Config.GetCertificate) callback to [do it all automatically](https://github.com/tailscale/tailscale/blob/main/client/tailscale/example/servetls/servetls.go). Your certificate's private key and your LetsEncrypt (ACME) account's private key are generated and stored locally on your machine and Tailscale never sees them.

It is possible to frequently request a new certificate and exceed Let's Encrypt's rate limits. As a result, you may find yourself waiting 34 hours until you can try again. For more information, refer to Let's Encrypt's [rate limits documentation](https://letsencrypt.org/docs/rate-limits/).

The certificates provided by Let's Encrypt have a 90 day expiry and require periodic renewal. When a certificate is delivered as files on disk which you then move to an install location, such as when using `tailscale cert`, the [`tailscaled` daemon](https://tailscale.com/kb/1278/tailscaled) doesn't know where to place a renewed certificate nor how to install it. So for any certificates that you create using `tailscale cert`, you are responsible for renewing the certificate.

If a certificate is handled without the user initiating any file-based certificate installation, such as when using the [Caddy integration of Tailscale](https://github.com/tailscale/caddy-tailscale), then the certificate will automatically be renewed without the user doing anything.

### [Using other TLS certificates](#using-other-tls-certificates)

In addition to Let's Encrypt, [Caddy](https://caddyserver.com) provides a way to use certificates for your tailnet machines. For details, refer to [Caddy certificates on Tailscale](https://tailscale.com/kb/1190/caddy-certificates).

If you are manually installing a certificate from another certificate provider, consult their documentation for how to configure the machine and how to renew the certificate.

## [Disable HTTPS](#disable-https)

You can disable HTTPS for your tailnet, but this will break all links and connections that relied on HTTPS.

To disable HTTPS for your tailnet:

1.  Open the [DNS](https://login.tailscale.com/admin/dns) page of the admin console.
2.  Under **HTTPS Certificates**, select **Disable HTTPS**.

If HTTPS is disabled, the certificates for your machines are not revoked. This is so that you can re-enable the feature again for your tailnet if needed. You also cannot invalidate a certificate for a single machine.

If you want to re-enable HTTPS, it will be enabled with the active [tailnet DNS name](https://tailscale.com/kb/1217/tailnet-name#tailnet-dns-name) for your tailnet.

## [Check certificate status](#check-certificate-status)

Within the Tailscale admin console, you can check the TLS certificate status for any machine in your network, provided the machine is:

-   online for your tailnet
-   running Tailscale v1.56 or later

To check the certificate status:

1.  Open the [Machines](https://login.tailscale.com/admin/machines) page of the admin console.
2.  Find the machine whose certificate status you want to check. You can use the [search bar](https://tailscale.com/kb/1176/filter-devices#filter-with-the-search-bar) or [filters](https://tailscale.com/kb/1176/filter-devices) to find a machine.
3.  Select the machine.
4.  Check the certificate status in the **TLS certificate** section of the machine page.

If a machine is offline, Tailscale will not be able to report its certificate status.

The following statuses can be reported for a machine's certificate:

-   Valid
-   Invalid
-   Certificate expired
-   No certificate found
-   Upgrade client to check status
```



### File: 1155-terminology-and-concepts.md

```markdown
# Terminology and concepts

## [Access control lists](#access-control-lists)

An [access control list](https://tailscale.com/kb/1018/acls) (ACL) manages system access using rules in the [tailnet policy file](#tailnet-policy-file). You can use ACLs to filter traffic and enhance security by managing who and what can use which resources.

## [tags](#tags)

A [tag](https://tailscale.com/kb/1068/tags) lets you assign an [identity](#identity-provider) (that's separate from human users) to [devices](#device). You can use tags in your [access rules](https://tailscale.com/kb/1018/acls) to restrict access.

## [Admin console](#admin-console)

The admin console is the central location to manage your Tailscale network (known as a [tailnet](#tailnet)). You can manage devices on your network, users and their permissions, and settings such as key expiry. The admin console also informs you if an update to the Tailscale client is available for your device. When you make changes from the admin console, the [coordination server](https://tailscale.com/kb/1508/control-data-planes#coordination-server) updates the changes to your tailnet immediately.

You can access the admin console at [admin console](https://login.tailscale.com/admin).

## [API](#api)

API is an acronym for application programming interface. APIs define a set of rules to interact with an application or service programmatically. The [Tailscale API](https://tailscale.com/api) lets you manage your Tailscale account and tailnet.

## [CLI](#cli)

CLI is an acronym for command line interface. The Tailscale [CLI](https://tailscale.com/kb/1080/cli) includes a robust set of commands with functionality that GUI applications might not have. The Tailscale CLI is installed automatically when you install Tailscale on Linux, macOS, or Windows.

## [Client](#client)

The Tailscale client is a software application that runs on a device so the device can join and participate in a [tailnet](#tailnet). The client uses the [WireGuard](#wireguard) protocol to create encrypted peer-to-peer connections. The client is available for multiple operating systems. Much of the client code is [open source](https://tailscale.com/opensource).

## [Coordination server](#coordination-server)

A [coordination server](https://tailscale.com/kb/1508/control-data-planes#coordination-server) is a central server that maintains a connection to all devices in your [Tailscale network](#tailnet). It manages [encryption](https://tailscale.com/kb/1504/encryption) keys, network changes, access policy changes, and maintains a connection to all devices in your Tailscale network. The coordination server is part of the [control plane](https://tailscale.com/kb/1508/control-data-planes#control-plane), not the [data plane](https://tailscale.com/kb/1508/control-data-planes#data-plane). It avoids being a performance bottleneck by not relaying traffic between devices.

## [Device](#device)

A device is anything other than a user. It can be physical or virtual and sends, receives, or processes data on your Tailscale network.

## [Device key](#device-key)

A device key is a unique public and private key pair for a specific [device](#device). More than one user can use a device key, but each device can only have one device key. The combination of a specific user with a device key represents a unique device.

## [Firewall](#firewall)

A firewall limits what network traffic can pass between two points. Firewalls can be hardware-based or software-based. Tailscale includes a built-in firewall, defined by the domain's [access rules](https://tailscale.com/kb/1018/acls).

## [Full tunnel](#full-tunnel)

With a traditional virtual private network (VPN), full tunnel describes a configuration where all traffic from a client is sent through the VPN, including internet-bound traffic. With Tailscale, you can route all internet-bound traffic by setting a device on your network as an [exit node](https://tailscale.com/kb/1103/exit-nodes). If your clients are configured to use an exit node and also have routes or connectivity to other Tailscale [devices](#device), [subnet routers](https://tailscale.com/kb/1019/subnets), or [app connectors](https://tailscale.com/kb/1342/app-connectors-setup), then Tailscale will still operate as a [split tunnel](#split-tunnel) VPN, routing traffic directly to each endpoint without routing traffic through the exit node first.

## [Identity Provider](#identity-provider)

An identity provider is a method for users to authenticate to a [tailnet](https://tailscale.com/kb/1136/tailnet). Examples of [identity providers](https://tailscale.com/kb/1013/sso-providers) include Google, Okta, and Microsoft. Tailscale is not an identity provider but relies other identity providers for authentication.

## [Key expiry](#key-expiry)

Key expiry is the end of the validity period for a cryptographic key. An expired key can no longer encrypt or decrypt data, nor authenticate a device to a Tailscale network.

Using Tailscale means you never have to manage [encryption](https://tailscale.com/kb/1504/encryption) keys directly. Tailscale automatically expires keys and requires them to be regenerated at regular intervals. You can disable key expiry for long-lived devices from the admin console.

## [MagicDNS](#magicdns)

[MagicDNS](https://tailscale.com/kb/1081/magicdns) automatically registers memorable hostnames for devices in your Tailscale network. It also extends and improves DNS functionality.

## [NAT traversal](#nat-traversal)

NAT is an acronym for [network address translation](https://en.wikipedia.org/wiki/Network_address_translation). [NAT traversal](https://tailscale.com/blog/how-nat-traversal-works) is a way to connect devices across the internet through barriers such as firewalls. Most internet devices can't talk to each other because of firewalls and devices that do network address translation. [NAT traversal works](https://tailscale.com/blog/how-tailscale-works#the-control-plane-key-exchange-and-coordination) around these barriers, allowing [data to traverse the network](#nat-traversal).

## [Network topology](#network-topology)

A network topology is an arrangement of devices in a network. It shows the connections between them. Examples of network topologies include star, bus, hub-and-spoke, mesh, and hybrid.

Traditional virtual private networks (VPNs) use a [hub-and-spoke topology](https://tailscale.com/blog/how-tailscale-works#hub-and-spoke-networks). Each device communicates with another in this setup by sending all traffic through a central gateway device. Tailscale operates as a [mesh topology](https://tailscale.com/blog/how-tailscale-works#mesh-networks) where each device can talk directly to others using [NAT traversal](#nat-traversal).

## [Node](#node)

A node is a combination of a user and a [device](#device).

## [Overlay network](#overlay-network)

An overlay network is a virtual network built on top of the [underlay](#underlay-network) network, where nodes communicate using logical addresses and encrypted tunnels independent of the underlay's addressing or topology. Tailscale forms an overlay network (the [tailnet](#tailnet)) that gives each node a stable identity and IP address, regardless of how the underlay changes.

## [Peer](#peer)

A peer is another [node](#node) that your device is trying to talk to. A peer might or might not be in the same domain.

## [Relay](#relay)

A relay is an intermediary server that passes data between two or more devices in a network. Tailscale uses a special type of globally distributed relay server called [Designated Encrypted Relay for Packets (DERP)](https://tailscale.com/kb/1232/derp-servers). DERP relay servers function as a fallback to connect devices when NAT traversal fails.

## [Split tunnel](#split-tunnel)

Split tunnel, as opposed to [full tunnel](#full-tunnel), describes a VPN configuration where only some traffic (specific IP ranges, domains, or subnets) is sent through the VPN, while all other traffic goes directly to the internet via the device's local internet gateway. In Tailscale, this means only traffic destined for other Tailscale [devices](#device), [subnet routers](https://tailscale.com/kb/1019/subnets), or [app connectors](https://tailscale.com/kb/1342/app-connectors-setup) uses the tailnet, leaving general internet traffic untouched.

## [SSO](#sso)

SSO is an acronym for [single sign-on](https://tailscale.com/kb/1013/sso-providers). Single sign-on lets users log in to one site using the identity of another.

## [Tailnet](#tailnet)

A [tailnet](https://tailscale.com/kb/1136/tailnet) is another term for a Tailscale network, which is an interconnected collection of users, devices, and resources. The network has a [control plane](https://tailscale.com/kb/1508/control-data-planes#control-plane) and a [data plane](https://tailscale.com/kb/1508/control-data-planes#data-plane) that work in unison to manage access and send data between devices.

There are personal and organization tailnets. A personal tailnet is a shared domain single-user tailnet (like `gmail.com`). An organization tailnet is a custom domain tailnet (like `example.com`),

## [Tailnet policy file](#tailnet-policy-file)

The tailnet policy file stores your Tailscale network's access rules, along with other tailnet configuration items. It uses [human JSON (HuJSON)](https://github.com/tailscale/hujson) and conforms to the [Tailscale policy syntax](https://tailscale.com/kb/1337/policy-syntax).

## [Tailscalar](#tailscalar)

A Tailscalar is a Tailscale employee.

## [Tailscale IP address](#tailscale-ip-address)

A [Tailscale IP address](#tailscale-ip-address) is a [unique IP address](https://tailscale.com/kb/1033/ip-and-dns-addresses) assigned to each device in your Tailscale network. It's always in the form `100.x.y.z` (for example, `100.101.102.103`). It stays the same even when switching between your home internet connection, cellular networks, or coffee shop Wi-Fi networks.

## [Tunnel](#tunnel)

In networking, a tunnel is an encapsulated connection between one or more points in a network. It lets users, devices, or resources communicate securely over a public data network.

## [Underlay network](#underlay-network)

An underlay network is the physical or existing IP network over which Tailscale runs, such as your home Wi-Fi, office LAN, or your cloud or data center's internet connection. Tailscale uses this underlay for actual packet transport, creating an [overlay network](#overlay-network) on top of the underlay that handles encryption, NAT traversal, access controls, and many more features.

## [WireGuard](#wireguard)

[WireGuard](https://www.wireguard.com) is the underlying cryptographic protocol that Tailscale uses.
```



### File: 1166-vscode-ipad.md

```markdown
# Code on iPad using Visual Studio Code, Caddy, and code-server

[Visual Studio Code](https://code.visualstudio.com) (VS Code) has quickly become the text editor many people use for their day-to-day work. Its cross-platform compatibility, speed, and vast library of extensions make it a popular choice.

Coder.com's [code-server](https://github.com/cdr/code-server) lets you run VS Code on a server and access it on any device, including an iPad. However, [code-server isn't safe to expose over the public internet](https://github.com/coder/code-server/blob/main/docs/guide.md#expose-code-server), which usually leads to installing a public-facing SSH proxy or an HTTP reverse proxy like nginx in front of it. Tailscale eliminates all that, giving you a fast, private connection no matter where you are.

In this guide you'll set up code-server and use Tailscale to connect to it securely from an iPad. When you're done, you'll have a secure development environment you can access anywhere.

## [Prerequisites](#prerequisites)

To complete this guide, you'll need the following:

-   A Tailscale account. [Create a free Personal account](https://login.tailscale.com/start) if you don't have one already.
-   A server to host code-server. This guide assumes you're using an Ubuntu 24.04 server and you have `sudo` access to install and run services. You can also install code-server on other platforms
-   The Tailscale client installed and running on your server so you can connect to it securely. Follow the [Install Tailscale on Linux](https://tailscale.com/kb/1031/install-linux) instructions if you're using Ubuntu, or [download and install Tailscale](https://tailscale.com/download) manually.
-   An iPad with Tailscale installed and running to access your VS Code server through a web browser. [Download and install Tailscale](https://tailscale.com/download) on your device. You can also use an Android tablet or a laptop as long as they're running Tailscale.
-   [MagicDNS](https://tailscale.com/kb/1081/magicdns) enabled on your tailnet, so you can use your server's MagicDNS hostname and use HTTPS certificates.

## [Step 1: Verify your Tailscale setup](#step-1-verify-your-tailscale-setup)

Before you set up code-server, confirm you can connect to your server on your tailnet. Start by getting [your machine's Tailscale IP address](https://tailscale.com/kb/1033/ip-and-dns-addresses).

If you're logged into your server already, you can find the Tailscale IP address with the following command:

```shell
tailscale ip --4
```

Copy the 100.x.y.z address. After you've found it, type `exit` to end your session.

Now start a new session that uses your Tailscale IP address:

```shell
ssh <username>@<copied 100.x.y.z address>
```

After you connect successfully, you can set up code-server.

## [Step 2: Install and secure code-server](#step-2-install-and-secure-code-server)

To use code-server with Tailscale, you'll install it on your server and then change its settings so it's only available to devices on your tailnet.

You can install code-server with a script or download pre-built binaries from their [GitHub releases page](https://github.com/cdr/code-server/releases). For this guide, you'll use the script.

On your server, run the following one-line command to install code-server:

```shell
curl -fsSL https://code-server.dev/install.sh | sh
```

The installation program runs, eventually presenting the following output to indicate it's installed:

```markup
To have systemd start code-server now and restart on boot:
  sudo systemctl enable --now code-server@$USER
Or, if you don't want/need a background service you can run:
  code-server

Deploy code-server for your team with Coder: https://github.com/coder/coder
```

Configure code-server to start on boot by running the following command:

```shell
sudo systemctl enable --now code-server@$USER
```

The command completes with the following message:

```markup
Created symlink /etc/systemd/system/default.target.wants/code-server@your-user.service → /usr/lib/systemd/system/code-server@.service.
```

code-server is now running on your local machine on port `8080`.

By default, code-server only accepts connections from the local device (`127.0.0.1`) and restricts access with a password. Because you'll only be accessing code-server over Tailscale, and Tailscale already uses your existing single sign-on (SSO) identity provider, there's no need for password-based authentication. You can already trust that you're authorized if you can even access the server. To do this, you'll update code-server's configuration to change how authentication works and the IP address code-server uses.

Open the code-server configuration file at `~/.config/code-server/config.yaml` using `nano` or another text editor:

```shell
nano ~/.config/code-server/config.yaml
```

The configuration file looks like the following example, with a `bind-address` set to the local device and password authentication:

```yaml
bind-addr: 127.0.0.1:8080
auth: password
password: <random-password>
cert: false
```

Update the `auth` field to `none`, remove the `password` field, and make the service available only on your Tailscale IP address by changing the `bind-addr` field to your Tailscale IP address:

```yaml
bind-addr: <100.x.y.z address>:8080
auth: none
cert: false
```

Save the file and exit your editor.

Apply the changes by restarting code-server:

```shell
sudo systemctl restart code-server@$USER
```

The service is now listening, but only on the Tailscale IP address.

On your iPad, ensure you've connected to your tailnet and that your server appears in the Tailscale application's list of devices.

Open a browser and access your server by visiting `http://100.x.y.z:8080/`, using your IP address.

![The code-server UI running on your tailnet.](/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fcode-server-runing.50fe3d66.png&w=3840&q=75)

You've got a working environment, but you can't use all of its features until you enable HTTPS support.

## [Step 3: Use HTTPS with Caddy](#step-3-use-https-with-caddy)

code-server's basic features work well over plain HTTP. Your connection is secure as long as you're connecting over an encrypted and authenticated Tailscale link. However, some features, like using the system clipboard, will be unavailable because web browsers require HTTPS for them to work. To make code-server fully functional, you'll need to set up an HTTPS connection with certificates.

Caddy automatically recognizes and uses certificates for your Tailscale network (`*.ts.net`), and can use Tailscale's HTTPS certificates.

First, [ensure you've enabled HTTPS certificates for your tailnet](https://tailscale.com/kb/1153/enabling-https).

Then, on your server, request a Let's Encrypt certificate. To do this, you need your machine name and your [tailnet name](https://tailscale.com/kb/1217/tailnet-name). You can find your tailnet DNS name in the [DNS](https://login.tailscale.com/admin/dns) page of the admin console. You can also run the `tailscale cert` command without arguments, and it will tell you the domain to use:

```shell
tailscale cert
```

The usage message gives you the details you need:

```markup
Usage: tailscale cert [flags] <domain>
For domain, use "machine-name.tailnet-name.ts.net".
```

Run `tailscale cert` with `sudo` and provide the domain:

```shell
sudo tailscale cert machine-name.tailnet-name.ts.net
```

The command displays the following output, indicating it created the certificate files:

```markup
Wrote public cert to machine-name.tailnet-name.ts.net.crt
Wrote private key to machine-name.tailnet-name.ts.net.key
```

Then, install Caddy on the server running code-server. On Ubuntu, install Caddy with the following commands:

```shell
sudo apt install -y debian-keyring debian-archive-keyring apt-transport-https curl
curl -1sLf 'https://dl.cloudsmith.io/public/caddy/stable/gpg.key' | sudo gpg --dearmor -o /usr/share/keyrings/caddy-stable-archive-keyring.gpg
curl -1sLf 'https://dl.cloudsmith.io/public/caddy/stable/debian.deb.txt' | sudo tee /etc/apt/sources.list.d/caddy-stable.list
chmod o+r /usr/share/keyrings/caddy-stable-archive-keyring.gpg
chmod o+r /etc/apt/sources.list.d/caddy-stable.list
sudo apt update
sudo apt install caddy
```

This installs Caddy's dependencies, adds Caddy's official package repository to your package manager sources, and installs Caddy as a service.

Now configure Caddy to use your Tailscale domain name. Edit `/etc/caddy/Caddyfile` with a text editor:

```shell
sudo nano /etc/caddy/Caddyfile
```

Replace the contents of the file with the following, using your domain name and your Tailscale IP address:

```markup
machine-name.tailnet-name.ts.net {
  reverse_proxy 100.x.y.z:8080
}
```

This defines a reverse proxy which forwards requests on to your code-server instance.

Save the file and exit the editor.

Installing Caddy on Ubuntu using the official scripts runs the Caddy server under the `caddy` user. For Tailscale to work with Caddy, you have to tell `tailscaled` to allow the `caddy` user to get the certificate.

Open the file `/etc/default/tailscaled` with your text editor:

```shell
sudo nano /etc/default/tailscaled
```

Add the following line to the file to allow the `caddy` user access to fetch certificates:

```markup
TS_PERMIT_CERT_UID=caddy
```

Review the [tailscaled](https://tailscale.com/kb/1278/tailscaled) documentation for more information on its configuration options.

Save the file. Now restart the `tailscaled` service to apply the changes:

```shell
sudo systemctl reload tailscaled
```

Reload Caddy to apply the configuration changes you made:

```shell
sudo systemctl reload caddy
```

Visit `https://machine-name.domain-alias.ts.net` on your iPad to connect to code-server. This time, all features that require a valid HTTP certificate work as expected.

## [Conclusion](#conclusion)

You can now access your VS Code instance from anywhere. You can code from a café near your home or from the other side of the world. And it's only accessible over Tailscale.

Since you'll be developing on this device, it'll have access to sensitive information such as private code or private data. To keep things even more secure, you may want to restrict all access to the server to only be over Tailscale.

For more information on how to further lock down a server, [read our guide on Ubuntu and ufw](https://tailscale.com/kb/1077/secure-server-ubuntu).
```



### File: 1167-release-stages.md

```markdown
# Release stages

Tailscale's features can go through multiple release stages: Alpha, Beta, and General Availability (GA). Use of these features is subject to our [Terms of Service](https://tailscale.com/terms).

## [Release stages](#release-stages)

### [Alpha](#alpha)

The feature is available for testing. Alpha releases may be public or private. The feature may have changing requirements and scope, and needs feedback. Alpha releases are not necessarily feature-complete, may not work on all platforms, may not have full functionality in the UI, CLI, or API, and may not be documented. Alpha releases have no technical support obligations.

### [Beta](#beta)

The feature is publicly available for testing environments. The feature needs refinement and broader testing to know it meets users' needs. Beta releases are documented, including any known gaps in functionality or platform support. Beta releases have no technical support obligations.

### [General availability (GA)](#general-availability-ga)

The feature is publicly available, and ready for production use. Technical support obligations apply to GA features.

## [Comparison matrix](#comparison-matrix)

**Alpha**

**Beta**

**GA**

Availability

May be public or private

Public

Public

Breaking changes

Yes

Yes, but with some warning

No

Known issues

Major

Minor

Bugs

Platform support

May only work on one platform

Works on all supported platforms by default. Any limitations are documented with the intent they will be addressed in a future update.

Works on all intended platforms

UI/CLI/API support

May have limited UX

May have limited UX

Works in all intended UX

Documentation

Not publicly, or very limited

Yes, but may be incomplete

Yes

Service Warranties

Covered under [existing Terms of Service](https://tailscale.com/terms)

Not applicable

Not applicable

On by default

No

May be for new tailnets

May be for new and existing tailnets

## [Alpha and beta release stage indicators](#alpha-and-beta-release-stage-indicators)

### [Tailscale admin console](#tailscale-admin-console)

Within the Tailscale [admin console](https://tailscale.com/kb/1155/terminology-and-concepts#admin-console), for a feature that is in alpha or beta, the UI displays a release stage indicator.

![Release stage indicator for a feature.](/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Frelease-stage-indicator-admin-console.a876d145.png&w=1080&q=75)

### [Tailscale CLI](#tailscale-cli)

Within the [Tailscale CLI](https://tailscale.com/kb/1080/cli), for a command or subcommand that is in alpha or beta, the `--help` text displays the release stage.

### [Tailscale documentation](#tailscale-documentation)

Within the [Tailscale Documentation](https://tailscale.com/docs) for a feature that is in alpha or beta, the topic displays text that shows the release stage.

![Release stage indicator within documentation for a feature.](/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Frelease-stage-indicator-docs.5c927cb1.png&w=1080&q=75)

Documentation for a Tailscale CLI command or subcommand that is in alpha or beta also shows the release stage.

## [Tailscale Community Projects](#tailscale-community-projects)

[Tailscale Community Projects](https://tailscale.com/kb/1531/community-projects) is a curated collection of community-supported open source projects built on Tailscale's platform. These projects showcase the breadth of how you can use Tailscale's networking and identity primitives to build secure, private tools for organizations and communities.

For information about supportability of projects in the Tailscale Community Projects [catalog](https://tailscale.com/community/community-projects), refer to the [Tailscale Community Projects](https://tailscale.com/special-terms#community-projects) section in our Special Terms.
```



### File: 1168-versions.md

```markdown
# Tailscale client versions and release tracks

This topic explains Tailscale's client version numbering methodology and the client release tracks we offer. These concepts are helpful for understanding which client to [install](https://tailscale.com/kb/1347/installation) and the process for [updating](https://tailscale.com/kb/1067/update) the client.

## [Client version numbers](#client-version-numbers)

Tailscale uses an alternating version numbering scheme based on the [Semantic Versioning](https://semver.org) method. Version numbering varies between build release tracks.

-   Stable builds are identified by even minor version numbers such as 1.70.0, 1.72.0, and 1.74.0. This can also include patch releases such as 1.72.1, 1.72.2, and 1.72.3.
-   Release candidate builds are identified by even minor version numbers with a patch version, such as 1.70.1, 1.70.2, and 1.70.3.
-   Unstable builds are identified by odd numbers such as 1.71.0, 1.73.0, and 1.75.0.

## [Client release tracks](#client-release-tracks)

A release track indicates the readiness and reliability of a client build.

### [Stable track](#stable-track)

Stable track builds are the latest supported and tested version. These builds are considered the most reliable and are included in the [changelog](https://tailscale.com/changelog#client).

Stable builds are available from the following locations:

-   The Tailscale [Download](https://tailscale.com/download) page.
-   The [user interface of an installed client](https://tailscale.com/kb/1067/update#manual-updates) where an update option is available, including Windows and macOS.
-   The [Tailscale CLI](https://tailscale.com/kb/1080/cli) command [`tailscale update`](https://tailscale.com/kb/1080/cli#update) where CLI functionality is available, including Linux, Windows, and macOS.
-   The app stores for the platforms that we support, such as Apple App Store, Google Play, and Amazon Appstore.
-   The Tailscale Packages [stable track](https://pkgs.tailscale.com/stable/) page of the [Tailscale Packages](https://pkgs.tailscale.com/) site. The availability of specific platforms varies because not all platforms are updated simultaneously.
    -   Typically, updates are concurrent for Linux, Windows, and macOS. Updates for NAS platforms such as Synology and QNAP are released less frequently.
    -   Stable builds for iOS and tvOS are exclusively available on the Apple App Store.
    -   For macOS, we refer to this as the Standalone variant and recommended this above all other variants. For more information, refer to [Three ways to run Tailscale on macOS](https://tailscale.com/kb/1065/macos-variants).

We release stable builds about every four weeks.

### [Release candidate track](#release-candidate-track)

Release candidate track builds are offered exclusively on the Tailscale Packages [Release candidates track](https://pkgs.tailscale.com/release-candidate) page of the [Tailscale Packages](https://pkgs.tailscale.com/) site. These are subsequent patch versions of the current stable release being tested in preparation for the stable track. For example, 1.72.1.

When the patch release candidate is deemed stable, it will be moved from this section and added to the stable track. Release candidates are not made available for minor releases, such as version 1.72.0.

We release client builds on an as-needed basis for patch release testing.

### [Unstable track](#unstable-track)

Unstable track builds are offered exclusively on the [unstable track](https://pkgs.tailscale.com/unstable/) page of the [Tailscale Packages](https://pkgs.tailscale.com/) site. Unstable builds are the very latest versions available for testing, updated the most frequently, and are not recommended for production environments. For more information, refer to [Install unstable Tailscale clients](https://tailscale.com/kb/1083/install-unstable).

We release unstable builds about every few days.
```



### File: 1192-acl-samples.md

```markdown
# ACL policy examples

Tailscale now secures access to resources using [grants](https://tailscale.com/kb/1324/grants), a next-generation access control policy syntax. Grants provide [all original ACL functionality plus additional capabilities](https://tailscale.com/kb/1467/grants-vs-acls).

ACLs will continue to work **indefinitely**; Tailscale will not remove support for this first-generation syntax from the product. However, Tailscale recommends [migrating to grants](https://tailscale.com/kb/1542/grants-migration) and using grants for all new tailnet policy file configurations because ACLs will not receive any new features.

You can use the [visual policy editor](https://tailscale.com/kb/1550/visual-editor) to manage your tailnet policy file. Refer to the [visual editor reference](https://tailscale.com/kb/1587/visual-editor-reference) for guidance on using the visual editor.

This topic provides example [access controls (ACLs)](https://tailscale.com/kb/1018/acls) for common scenarios. For information about the syntax, refer to the [tailnet policy syntax](https://tailscale.com/kb/1337/policy-syntax).

**Example**

**Description**

**Uses**

[Allow all](#allow-all-default-acl)

The default tailnet policy that allows all devices within the tailnet to access other devices in the tailnet.

[ACLs](https://tailscale.com/kb/1018/acls), [SSH](https://tailscale.com/kb/1337/policy-syntax#ssh)

[Deny all](#deny-all)

Deny all connections.

[ACLs](https://tailscale.com/kb/1018/acls)

[Users can access their own devices](#users-can-access-their-own-devices)

All tailnet users can access devices they own unless another policy prevents it.

[ACLs](https://tailscale.com/kb/1018/acls), [SSH](https://tailscale.com/kb/1337/policy-syntax#ssh)

[Resource-level access policies](#resource-level-access-policies)

Allow specific devices to access specific resources within the tailnet.

[ACLs](https://tailscale.com/kb/1018/acls), [hosts](https://tailscale.com/kb/1337/policy-syntax#hosts)

[Restrict based on purpose (tags)](#restrict-based-on-purpose-tags)

Allow specific devices to access specific resources within the tailnet using tags.

[ACLs](https://tailscale.com/kb/1018/acls)

[Restrict based on group](#restrict-based-on-group)

Manage access to resources using autogroups, custom groups, and provisioned groups.

[ACLs](https://tailscale.com/kb/1018/acls), [groups](https://tailscale.com/kb/1337/policy-syntax#groups)

[Restrict based on individual users](#restrict-based-on-individual-user)

Manage access to resources for specific users.

[ACLs](https://tailscale.com/kb/1018/acls)

[Starter plan ACL](#starter-plan-acl)

Use a basic starter plan that allows employees to access their own devices and devices tagged with `corp` and lets admins access devices tagged with `corp` or `prod`.

[ACLs](https://tailscale.com/kb/1018/acls), [tag owners](https://tailscale.com/kb/1337/policy-syntax#tag-owners)

[Access to an internal application (VPN)](#access-to-an-internal-application-vpn)

Manage user access applications based on their job role.

[ACLs](https://tailscale.com/kb/1018/acls), [groups](https://tailscale.com/kb/1337/policy-syntax#groups), [tag owners](https://tailscale.com/kb/1337/policy-syntax#tag-owners)

[Access to an internal application (VPN) with synced groups](#access-to-an-internal-application-vpn-with-synced-groups)

Manage access to internal resources using groups synced to an identity provider.

[ACLs](https://tailscale.com/kb/1018/acls), [groups](https://tailscale.com/kb/1337/policy-syntax#groups), [tag owners](https://tailscale.com/kb/1337/policy-syntax#tag-owners)

[Remote access to a production environment](#remote-access-to-production-environment)

Manage user access to the production environment based on their job role.

[ACLs](https://tailscale.com/kb/1018/acls), [groups](https://tailscale.com/kb/1337/policy-syntax#groups), [tag owners](https://tailscale.com/kb/1337/policy-syntax#tag-owners), [tests](https://tailscale.com/kb/1337/policy-syntax#tests)

[VPC access (VPC peering)](#vpc-access-vpc-peering)

Manage access to a virtual private cloud using access control lists.

[ACLs](https://tailscale.com/kb/1018/acls), [groups](https://tailscale.com/kb/1337/policy-syntax#groups), [tag owners](https://tailscale.com/kb/1337/policy-syntax#tag-owners), [auto approvers](https://tailscale.com/kb/1337/policy-syntax#autoapprovers)

[Share access with a contractor](#share-access-with-a-contractor)

Allow a third-party contractor to access shared resources in the development environment.

[ACLs](https://tailscale.com/kb/1018/acls), [groups](https://tailscale.com/kb/1337/policy-syntax#groups), [tag owners](https://tailscale.com/kb/1337/policy-syntax#tag-owners)

[Remote development](#remote-development)

Manage access to a remote development environment.

[ACLs](https://tailscale.com/kb/1018/acls), [groups](https://tailscale.com/kb/1337/policy-syntax#groups), [tag owners](https://tailscale.com/kb/1337/policy-syntax#tag-owners)

[Pair programming](#pair-programming)

Create a paired programming environment multiple engineers can connect to using SSH.

[ACLs](https://tailscale.com/kb/1018/acls), [tag owners](https://tailscale.com/kb/1337/policy-syntax#tag-owners)

[CI/CD deployment pipeline](#cicd-deployment-pipeline)

Manage access to resources based on job roles.

[ACLs](https://tailscale.com/kb/1018/acls), [groups](https://tailscale.com/kb/1337/policy-syntax#groups), [tag owners](https://tailscale.com/kb/1337/policy-syntax#tag-owners)

[Monitoring access to applications](#monitoring-access-to-applications)

Allow a monitoring server to access all applications on common ports.

[ACLs](https://tailscale.com/kb/1018/acls), [groups](https://tailscale.com/kb/1337/policy-syntax#groups), [tag owners](https://tailscale.com/kb/1337/policy-syntax#tag-owners)

[Application peering](#application-peering)

Allow multiple cloud providers or applications to access each other.

[ACLs](https://tailscale.com/kb/1018/acls), [groups](https://tailscale.com/kb/1337/policy-syntax#groups), [tag owners](https://tailscale.com/kb/1337/policy-syntax#tag-owners)

[Network microsegmentation](#network-microsegmentation)

Allow access to network microsegements, but deny access between them.

[ACLs](https://tailscale.com/kb/1018/acls), [groups](https://tailscale.com/kb/1337/policy-syntax#groups), [tag owners](https://tailscale.com/kb/1337/policy-syntax#tag-owners), [tests](https://tailscale.com/kb/1337/policy-syntax#tests)

## [Allow all (default ACL)](#allow-all-default-acl)

**Prefer grant examples**

Grants provide all the capabilities of ACLs plus application-layer permissions. For modern access control patterns, refer to the [grant examples](https://tailscale.com/kb/1458/grant-examples).

[Plan availability](https://tailscale.com/pricing)

Features

All plans

[ACLs](https://tailscale.com/kb/1337/policy-syntax), [SSH](https://tailscale.com/kb/1337/policy-syntax#ssh), [autogroups](https://tailscale.com/kb/1337/policy-syntax#autogroups)

When you first create your Tailscale network (known as a tailnet), Tailscale initializes it with a default _allow all_ access policy to make it easy to connect to and use Tailscale without restricting any traffic in your network.

You can reset your ACL policy file to the original default by deleting the existing policy file contents and selecting **Reset to default**. Policy file changes can also be [reverted](https://tailscale.com/kb/1338/edit-policies#revert-changes) from the [Configuration logs](https://login.tailscale.com/admin/logs) page of the admin console.

Here's a breakdown of what the default policy does:

-   Allows all devices in the tailnet access all other devices in the tailnet.
-   Allows all users to establish a [Tailscale SSH](https://tailscale.com/kb/1193/tailscale-ssh) session to their own devices using [check mode](https://tailscale.com/kb/1193/tailscale-ssh#configure-tailscale-ssh-with-check-mode), as either root or non-root.
-   If you have a [subnet router initialized with `--snat-subnet-routes=false`](https://tailscale.com/kb/1023/troubleshooting#disable-subnet-route-masquerading) (Linux only), then any devices on the same local network as the subnet router can also access all devices in the tailnet.
-   If you have a [device shared from another network](https://tailscale.com/kb/1084/sharing#sharing-and-access-control-lists-acls) in your tailnet, that device cannot access any devices in the tailnet. The device [can only respond to incoming connections](https://tailscale.com/kb/1084/sharing#quarantine) from the tailnet.

```json
{
  "acls": [
    {
      "action": "accept",
      "src": [
        "*"
      ],
      "dst": [
        "*:*"
      ]
    }
  ],
  "ssh": [
    {
      "action": "check",
      "src": [
        "autogroup:member"
      ],
      "dst": [
        "autogroup:self"
      ],
      "users": [
        "autogroup:nonroot",
        "root"
      ]
    }
  ],
}
```

Omitting the `acls` field from the tailnet policy file is equivalent to the default allow all policy. To deny all connections, [use an empty object for the `acls` field](#deny-all) in your policy file.

```json
{} // Tailscale applies the default allow all policy if the acls section is empty.
```

In the default ACL, the `ssh` rule uses `autogroup:self` for the `dst` field and`autogroup:nonroot` in the `users` field. If you change the `dst` field from`autogroup:self` to some other destination, such as an [ACL tag](https://tailscale.com/kb/1068/acl-tags/), also consider replacing `autogroup:nonroot` in the `users` field. If you don't remove`autogroup:nonroot` from the `users` field, then anyone permitted by the `src` setting will be able to SSH in as any nonroot user on the `dst` device.

## [Deny all](#deny-all)

**Prefer grant examples**

Grants provide all the capabilities of ACLs plus application-layer permissions. For modern access control patterns, refer to the [grant examples](https://tailscale.com/kb/1458/grant-examples).

[Plan availability](https://tailscale.com/pricing)

Features

All plans

[ACLs](https://tailscale.com/kb/1337/policy-syntax)

You can deny all connections in your tailnet by using an empty option for the `acls` field in your policy file. This configuration prevents all devices from communicating with each other. This configuration is not recommended for general use because nothing in the tailnet will work.

```json
{
  "acls": []
}
```

Omitting the `acls` field from the tailnet policy file is not the equivalent of a "deny all" policy. Instead, Tailscale applies the [default allow all policy](#allow-all-default-acl), which allows all devices within the tailnet to access other devices in the tailnet.

## [Users can access their own devices](#users-can-access-their-own-devices)

**Prefer grant examples**

Grants provide all the capabilities of ACLs plus application-layer permissions. For modern access control patterns, refer to the [grant examples](https://tailscale.com/kb/1458/grant-examples).

[Plan availability](https://tailscale.com/pricing)

Features

All plans

[ACLs](https://tailscale.com/kb/1018/acls), [tags](https://tailscale.com/kb/1068/tags), [tag owners](https://tailscale.com/kb/1337/policy-syntax#tag-owners)

This example allows all users to access their own devices. It is suitable for many use cases where you want to allow users to access their own devices, but not other devices in the tailnet.

```json
{
  "acls": [
    {
      "action": "accept",
      "src": [
        "autogroup:member"
      ],
      "dst": [
        "autogroup:self:*"
      ]
    }
  ],
}
```

## [Resource-level access policies](#resource-level-access-policies)

**Prefer grant examples**

Grants provide all the capabilities of ACLs plus application-layer permissions. For modern access control patterns, refer to the [grant examples](https://tailscale.com/kb/1458/grant-examples).

[Plan availability](https://tailscale.com/pricing)

Features

All plans

[ACLs](https://tailscale.com/kb/1018/acls), [hosts](https://tailscale.com/kb/1337/policy-syntax#hosts)

You can enable connectivity from one device or network to another using their IP addresses. Additionally, the [`hosts`](https://tailscale.com/kb/1337/policy-syntax#hosts) section lets you define a human-friendly name for an IP address or CIDR range, to make access rules more readable.

What this example does:

-   The device with the IP address `100.101.102.104` can access the device with the IP address `100.101.102.103`.
-   The device with the IP address `100.101.102.104` can access devices in the subnet `192.0.2.0/24` through a [subnet router](https://tailscale.com/kb/1019/subnets).
-   The device with the hostname `frontend-server-01` can access devices in the subnet `192.0.2.0/24`.
-   The device with the hostname `frontend-server-01` can access the device with the hostname `dev-network-01`.

```json
{
  "acls": [
    {
      "action": "accept",
      "src": [
        "100.101.102.104"
      ],
      "dst": [
        "100.101.102.103:*"
      ]
    },
    {
      "action": "accept",
      "src": [
        "100.101.102.104"
      ],
      "dst": [
        "192.0.2.0/24:*"
      ]
    },
    {
      "action": "accept",
      "src": [
        "frontend-server-01"
      ],
      "dst": [
        "192.0.2.0/24:*"
      ]
    },
    {
      "action": "accept",
      "src": [
        "frontend-server-01"
      ],
      "dst": [
        "dev-network-01:*"
      ]
    }
  ],
  "hosts": {
    "frontend-server-01": "100.101.102.103",
    "dev-network-01": "203.0.113.0/24"
  }
}
```

## [Restrict based on purpose (tags)](#restrict-based-on-purpose-tags)

**Prefer grant examples**

Grants provide all the capabilities of ACLs plus application-layer permissions. For modern access control patterns, refer to the [grant examples](https://tailscale.com/kb/1458/grant-examples).

[Plan availability](https://tailscale.com/pricing)

Features

All plans

[ACLs](https://tailscale.com/kb/1018/acls), [tags](https://tailscale.com/kb/1068/tags)

[Tags](https://tailscale.com/kb/1068/tags) let you assign an identity to a device that is separate from human users, and use that identity as part of an ACL to restrict access. Tags should be used when adding servers to your Tailscale network, so that their access is based on their purpose, not based on which member of your operations team enrolled them.

What this example does:

-   Devices tagged with `tag:frontend` can access devices tagged with `tag:backend`.
-   Devices tagged with `tag:backend` can access devices tagged with `tag:logging`.

```json
{
  "acls": [
    {
      "action": "accept",
      "src": [
        "tag:frontend"
      ],
      "dst": [
        "tag:backend:*"
      ]
    },
    {
      "action": "accept",
      "src": [
        "tag:backend"
      ],
      "dst": [
        "tag:logging:*"
      ]
    }
  ]
}
```

## [Restrict based on group](#restrict-based-on-group)

**Prefer grant examples**

Grants provide all the capabilities of ACLs plus application-layer permissions. For modern access control patterns, refer to the [grant examples](https://tailscale.com/kb/1458/grant-examples).

You can enable access to resources in your tailnet with [autogroups](#with-autogroups), [custom groups](#with-custom-groups), or [groups provisioned from supported identity providers](#with-provisioned-groups).

### [With autogroups](#with-autogroups)

**Prefer grant examples**

Grants provide all the capabilities of ACLs plus application-layer permissions. For modern access control patterns, refer to the [grant examples](https://tailscale.com/kb/1458/grant-examples).

[Plan availability](https://tailscale.com/pricing)

Features

All plans

[ACLs](https://tailscale.com/kb/1018/acls), [autogroups](https://tailscale.com/kb/1337/policy-syntax#autogroups), [tags](https://tailscale.com/kb/1068/tags)

[Autogroups](https://tailscale.com/kb/1337/policy-syntax#autogroups) are built-in groups that automatically include users, destinations, or usernames with the same properties.

What this example does:

-   All tailnet members `autogroup:member` can access devices tagged with `tag:frontend`.
-   All Tailscale [Admins](https://tailscale.com/kb/1138/user-roles) (`autogroup:admin`) can access devices tagged with `tag:backend` or `tag:logging`.

```json
{
  "acls": [
    {
      "action": "accept",
      "src": [
        "autogroup:member"
      ],
      "dst": [
        "tag:frontend:*"
      ]
    },
    {
      "action": "accept",
      "src": [
        "autogroup:admin"
      ],
      "dst": [
        "tag:backend:*",
        "tag:logging:*"
      ]
    }
  ]
}
```

### [With custom groups](#with-custom-groups)

**Prefer grant examples**

Grants provide all the capabilities of ACLs plus application-layer permissions. For modern access control patterns, refer to the [grant examples](https://tailscale.com/kb/1458/grant-examples).

[Plan availability](https://tailscale.com/pricing)

Features

Personal, Personal Plus, Premium, and Enterprise

[ACLs](https://tailscale.com/kb/1018/acls), [groups](https://tailscale.com/kb/1337/policy-syntax#groups), [autogroups](https://tailscale.com/kb/1337/policy-syntax#autogroups), [tags](https://tailscale.com/kb/1068/tags)

[Custom groups](https://tailscale.com/kb/1337/policy-syntax#groups) let you define a shorthand for a group of users, which you can then use in access rules instead of listing users out explicitly.

What this example does:

-   The Engineering team `group:engineering` consists of `alice@example.com` and `bob@example.com`.
-   The DevOps team `group:engineering` consists of `amelie@example.com` and `carl@example.com`.
-   The Engineering team `group:engineering` can access devices tagged with `tag:frontend` or `tag:backend`.
-   The DevOps team `group:devops` can access devices tagged with `tag:frontend`, `tag:backend`, or `tag:logging`.

```json
{
  "groups": {
    "group:engineering": [
      "alice@example.com",
      "bob@example.com"
    ],
    "group:devops": [
      "amelie@example.com",
      "carl@example.com"
    ]
  },
  "acls": [
    {
      "action": "accept",
      "src": [
        "group:engineering"
      ],
      "dst": [
        "tag:frontend:*",
        "tag:backend:*"
      ]
    },
    {
      "action": "accept",
      "src": [
        "group:devops"
      ],
      "dst": [
        "tag:frontend:*",
        "tag:backend:*",
        "tag:logging:*"
      ]
    }
  ]
}
```

### [With provisioned groups](#with-provisioned-groups)

**Prefer grant examples**

Grants provide all the capabilities of ACLs plus application-layer permissions. For modern access control patterns, refer to the [grant examples](https://tailscale.com/kb/1458/grant-examples).

You can use [group provisioning from supported identity providers](https://tailscale.com/kb/1290/user-group-provisioning) and avoid maintaining custom groups in your ACLs.

```json
{
  "acls": [
    {
      "action": "accept",
      "src": [
        "group:engineering@example.com"
      ],
      "dst": [
        "tag:frontend:*",
        "tag:backend:*"
      ]
    },
    {
      "action": "accept",
      "src": [
        "group:devops@example.com"
      ],
      "dst": [
        "tag:frontend:*",
        "tag:backend:*",
        "tag:logging:*"
      ]
    }
  ]
}
```

## [Restrict based on individual user](#restrict-based-on-individual-user)

**Prefer grant examples**

Grants provide all the capabilities of ACLs plus application-layer permissions. For modern access control patterns, refer to the [grant examples](https://tailscale.com/kb/1458/grant-examples).

[Plan availability](https://tailscale.com/pricing)

Features

Personal, Personal Plus, Premium, and Enterprise

[ACLs](https://tailscale.com/kb/1018/acls), [tags](https://tailscale.com/kb/1068/tags)

You can enable access to resources based on individual users.

What this example does:

-   User Alice can access devices tagged with `tag:frontend`.
-   User Bob can access devices tagged with `tag:backend`.

```json
{
  "acls": [
    {
      "action": "accept",
      "src": [
        "amelie@example.com"
      ],
      "dst": [
        "tag:frontend:*"
      ]
    },
    {
      "action": "accept",
      "src": [
        "bob@example.com"
      ],
      "dst": [
        "tag:backend:*"
      ]
    }
  ]
}
```

## [Starter plan ACL](#starter-plan-acl)

**Prefer grant examples**

Grants provide all the capabilities of ACLs plus application-layer permissions. For modern access control patterns, refer to the [grant examples](https://tailscale.com/kb/1458/grant-examples).

[Plan availability](https://tailscale.com/pricing)

Features

All plans

[ACLs](https://tailscale.com/kb/1018/acls), [autogroups](https://tailscale.com/kb/1337/policy-syntax#autogroups), [tags](https://tailscale.com/kb/1068/tags), [tag owners](https://tailscale.com/kb/1337/policy-syntax#tag-owners)

This example provides remote access to corp and prod devices. It is suitable for many Starter plan use cases.

Your team can use Tailscale to access remote devices. In this scenario, all users can access their own remote devices, as well as any common corporate devices, such as servers, that are tagged. Only Tailscale [Admins](https://tailscale.com/kb/1138/user-roles) can access production devices. Admins can configure which devices are tagged. No corporate or production devices can access each other, and no shared users can access devices.

What this example does:

-   All employees can access their own devices.
-   All employees can access corporate devices tagged with `tag:corp`.
-   All Tailscale [Admins](https://tailscale.com/kb/1138/user-roles) (`autogroup:admin`) can access devices tagged with `tag:prod`.
-   All Tailscale [Admins](https://tailscale.com/kb/1138/user-roles) can manage which devices are tagged with `tag:corp` and `tag:prod`.

```json
{
  "acls": [
    {
      "action": "accept",
      "src": [
        "autogroup:member"
      ],
      "dst": [
        "autogroup:self:*"
      ]
    },
    {
      "action": "accept",
      "src": [
        "autogroup:member"
      ],
      "dst": [
        "tag:corp:*"
      ]
    },
    {
      "action": "accept",
      "src": [
        "autogroup:admin"
      ],
      "dst": [
        "tag:prod:*"
      ]
    }
  ],
  "tagOwners": {
    "tag:corp": [
      "autogroup:admin"
    ],
    "tag:prod": [
      "autogroup:admin"
    ]
  }
}
```

## [Access to an internal application (VPN)](#access-to-an-internal-application-vpn)

**Prefer grant examples**

Grants provide all the capabilities of ACLs plus application-layer permissions. For modern access control patterns, refer to the [grant examples](https://tailscale.com/kb/1458/grant-examples).

[Plan availability](https://tailscale.com/pricing)

Features

Personal, Personal Plus, Premium, and Enterprise

[ACLs](https://tailscale.com/kb/1018/acls), [groups](https://tailscale.com/kb/1337/policy-syntax#groups), [tags](https://tailscale.com/kb/1068/tags), [tag owners](https://tailscale.com/kb/1337/policy-syntax#tag-owners)

You can use Tailscale to allow users to access internal applications, including both custom internal applications and third-party applications hosted internally. In this scenario, users in your tailnet can access applications based on their job role. The IT team can set up internal applications.

What this example does:

-   Members of the engineering team `group:engineering` can access the devices tagged with `tag:engineering`.
-   Members of the finance team `group:finance` can access the devices tagged with `tag:finance`.
-   Members of the legal team `group:legal` can access the devices tagged with `tag:legal`.
-   All employees can access the devices tagged with `tag:internal`.
-   All Tailscale [Admins](https://tailscale.com/kb/1138/user-roles) (`autogroup:admin`) (such as the IT team) can manage which devices are tagged with `tag:engineering`, `tag:finance`, `tag:legal`, and `tag:internal`.

```json
{
  "groups": {
    "group:engineering": [
      "alice@example.com"
    ],
    "group:finance": [
      "bob@example.com"
    ],
    "group:legal": [
      "carl@example.com"
    ]
  },
  "acls": [
    {
      "action": "accept",
      "src": [
        "group:engineering"
      ],
      "dst": [
        "tag:engineering:*"
      ]
    },
    {
      "action": "accept",
      "src": [
        "group:finance"
      ],
      "dst": [
        "tag:finance:*"
      ]
    },
    {
      "action": "accept",
      "src": [
        "group:legal"
      ],
      "dst": [
        "tag:legal:*"
      ]
    },
    {
      "action": "accept",
      "src": [
        "autogroup:member"
      ],
      "dst": [
        "tag:internal:*"
      ]
    }
  ],
  "tagOwners": {
    "tag:engineering": [
      "autogroup:admin"
    ],
    "tag:finance": [
      "autogroup:admin"
    ],
    "tag:legal": [
      "autogroup:admin"
    ],
    "tag:internal": [
      "autogroup:admin"
    ]
  }
}
```

### [Access to an internal application (VPN) with synced groups](#access-to-an-internal-application-vpn-with-synced-groups)

**Prefer grant examples**

Grants provide all the capabilities of ACLs plus application-layer permissions. For modern access control patterns, refer to the [grant examples](https://tailscale.com/kb/1458/grant-examples).

[Plan availability](https://tailscale.com/pricing)

Features

Enterprise

[ACLs](https://tailscale.com/kb/1018/acls), [groups](https://tailscale.com/kb/1337/policy-syntax#groups), [autogroups](https://tailscale.com/kb/1337/policy-syntax#autogroups), [tags](https://tailscale.com/kb/1068/tags), [tag owners](https://tailscale.com/kb/1337/policy-syntax#tag-owners)

You can use [user and group provisioning](https://tailscale.com/kb/1290/user-group-provisioning) to include groups synced from your identity provider in access rules. Tailscale treats synced group names as lowercase. They can include spaces, but not the `@` symbol.

What this example does:

-   Members of the engineering team in the synced group `group:engineering@example.com` can access the devices tagged with `tag:engineering`.
-   Members of the finance team in the synced group `group:finance team@example.com` can access the devices tagged with `tag:finance`.
-   Members of the legal team in the synced group `group:Legal@example.com` can access the devices tagged with `tag:legal`.
-   All employees can access the devices tagged with `tag:internal`.
-   All Tailscale [Admins](https://tailscale.com/kb/1138/user-roles) (`autogroup:admin`) (such as the IT team) can manage which devices are tagged with `tag:engineering`, `tag:finance`, `tag:legal`, and `tag:internal`.

```json
{
  "groups": {},
  "acls": [
    {
      "action": "accept",
      "src": [
        "group:engineering@example.com"
      ],
      "dst": [
        "tag:engineering:*"
      ]
    },
    {
      "action": "accept",
      "src": [
        "group:finance team@example.com"
      ],
      "dst": [
        "tag:finance:*"
      ]
    },
    {
      "action": "accept",
      "src": [
        "group:legal@example.com"
      ],
      "dst": [
        "tag:legal:*"
      ]
    },
    {
      "action": "accept",
      "src": [
        "autogroup:member"
      ],
      "dst": [
        "tag:internal:*"
      ]
    }
  ],
  "tagOwners": {
    "tag:engineering": [
      "autogroup:admin"
    ],
    "tag:finance": [
      "autogroup:admin"
    ],
    "tag:legal": [
      "autogroup:admin"
    ],
    "tag:internal": [
      "autogroup:admin"
    ]
  }
}
```

## [Remote access to production environment](#remote-access-to-production-environment)

**Prefer grant examples**

Grants provide all the capabilities of ACLs plus application-layer permissions. For modern access control patterns, refer to the [grant examples](https://tailscale.com/kb/1458/grant-examples).

[Plan availability](https://tailscale.com/pricing)

Features

Personal, Personal Plus, Premium, and Enterprise

[ACLs](https://tailscale.com/kb/1018/acls), [groups](https://tailscale.com/kb/1337/policy-syntax#groups), [autogroups](https://tailscale.com/kb/1337/policy-syntax#autogroups), [tags](https://tailscale.com/kb/1068/tags), [tag owners](https://tailscale.com/kb/1337/policy-syntax#tag-owners), [tests](https://tailscale.com/kb/1337/policy-syntax#tests)

You can modify this example to work on the Starter plan by using `autogroup:member` instead of a custom group (`group:dev`).

Your DevOps, infrastructure, or SRE team can use Tailscale to access their sensitive and highly protected production environment. In this scenario, a DevOps team might be able to access the production environment, whereas other developers might only be able to access resources in a development environment. All developers are able to access monitoring tools, such as [Grafana](https://tailscale.com/blog/grafana-auth).

What this example does:

-   All employees can access their own devices (such as remote workstations).
-   Members of the development team `group:dev` can access the devices tagged with `tag:dev` (such as license servers).
-   All Tailscale [Admins](https://tailscale.com/kb/1138/user-roles) (`autogroup:admin`) (such as members of the DevOps team) can access the devices tagged with `tag:prod` (such as the production environment).
-   All employees can access devices tagged with `tag:monitoring` on ports `80` and `443` (such as monitoring dashboards).
-   All Tailscale [Admins](https://tailscale.com/kb/1138/user-roles) (`autogroup:admin`) can manage which devices are tagged with `tag:dev`, `tag:prod`, and `tag:monitoring`
-   [Tests](https://tailscale.com/kb/1337/policy-syntax#tests) ensure that if ACLs change:
    -   Carl will still be able to access devices tagged with `tag:prod` on port `80`.
    -   Alice will still be able to access devices tagged with `tag:dev` (but not devices tagged with `tag:prod`) on port `80`.

```json
{
  "groups": {
    "group:dev": [
      "alice@example.com",
      "bob@example.com"
    ]
  },
  "acls": [
    {
      "action": "accept",
      "src": [
        "autogroup:member"
      ],
      "dst": [
        "autogroup:self:*"
      ]
    },
    {
      "action": "accept",
      "src": [
        "group:dev"
      ],
      "dst": [
        "tag:dev:*"
      ]
    },
    {
      "action": "accept",
      "src": [
        "autogroup:admin"
      ],
      "dst": [
        "tag:prod:*"
      ]
    },
    {
      "action": "accept",
      "src": [
        "autogroup:member"
      ],
      "dst": [
        "tag:monitoring:80,443"
      ]
    }
  ],
  "tagOwners": {
    "tag:monitoring": [
      "autogroup:admin"
    ],
    "tag:dev": [
      "autogroup:admin"
    ],
    "tag:prod": [
      "autogroup:admin"
    ]
  },
  "tests": [
    {
      "src": "carl@example.com",
      "accept": [
        "tag:prod:80"
      ]
    },
    {
      "src": "alice@example.com",
      "accept": [
        "tag:dev:80"
      ],
      "deny": [
        "tag:prod:80"
      ]
    }
  ]
}
```

## [VPC access (VPC peering)](#vpc-access-vpc-peering)

**Prefer grant examples**

Grants provide all the capabilities of ACLs plus application-layer permissions. For modern access control patterns, refer to the [grant examples](https://tailscale.com/kb/1458/grant-examples).

[Plan availability](https://tailscale.com/pricing)

Features

Personal, Personal Plus, Premium, and Enterprise

[ACLs](https://tailscale.com/kb/1018/acls), [groups](https://tailscale.com/kb/1337/policy-syntax#groups), [autogroups](https://tailscale.com/kb/1337/policy-syntax#autogroups), [tags](https://tailscale.com/kb/1068/tags), [tag owners](https://tailscale.com/kb/1337/policy-syntax#tag-owners), [auto approvers](https://tailscale.com/kb/1337/policy-syntax#autoapprovers)

You can modify this example to work on the Starter plan by using `autogroup:member` instead of a custom group (`group:dev`).

Your DevOps team can use Tailscale to allow developers to access existing internal applications running in a Virtual Private Cloud (VPC) on a private or hosted cloud provider. In this scenario, developers can access resources in the VPC, and the DevOps team is able to manage access to the VPC. VPCs can be peered to each other if they don't have [overlapping IP ranges](https://tailscale.com/kb/1201/4via6-subnets). To connect an existing subnet to your Tailscale network without installing Tailscale on every device, you can use a [subnet router](https://tailscale.com/kb/1019/subnets). Run a subnet router in the subnet, and advertise the routes so that Tailscale can route traffic for the subnet to the device for forwarding. For devices on a subnet to connect to devices in your tailnet, [disable subnet route masquerading](https://tailscale.com/kb/1023/troubleshooting#disable-subnet-route-masquerading). You can also use [auto approvers](https://tailscale.com/kb/1337/policy-syntax#autoapprovers) to automatically approve routes.

What this example does:

-   All Tailscale [Admins](https://tailscale.com/kb/1138/user-roles) (`autogroup:admin`) (such as the IT team) can access the devices tagged with `tag:vpc-peering` (for maintenance).
-   Members of the development team `group:dev` can access devices in the subnets `192.0.2.0/24` and `198.51.100.0/24`.
-   The subnet `192.0.2.0/24` can access the subnet `198.51.100.0/24` and vice versa (if [subnet route masquerading is disabled](https://tailscale.com/kb/1023/troubleshooting#disable-subnet-route-masquerading)).
-   All Tailscale [Admins](https://tailscale.com/kb/1138/user-roles) (`autogroup:admin`) (such as the IT team) can manage which devices are tagged with `tag:vpc-peering`.
-   All Tailscale [Admins](https://tailscale.com/kb/1138/user-roles) (`autogroup:admin`) and devices tagged with `tag:vpc-peering` can auto-approve routes for `192.0.2.0/24` and `198.51.100.0/24`.

```json
{
  "groups": {
    "group:dev": [
      "alice@example.com",
      "bob@example.com"
    ]
  },
  "acls": [
    {
      "action": "accept",
      "src": [
        "autogroup:admin"
      ],
      "dst": [
        "tag:vpc-peering:*"
      ]
    },
    {
      "action": "accept",
      "src": [
        "group:dev",
        "192.0.2.0/24",
        "198.51.100.0/24"
      ],
      "dst": [
        "192.0.2.0/24:*",
        "198.51.100.0/24:*"
      ]
    }
  ],
  "tagOwners": {
    "tag:vpc-peering": [
      "autogroup:admin"
    ]
  },
  "autoApprovers": {
    "routes": {
      "192.0.2.0/24": [
        "tag:vpc-peering",
        "autogroup:admin"
      ],
      "198.51.100.0/24": [
        "tag:vpc-peering",
        "autogroup:admin"
      ]
    }
  }
}
```

## [Share access with a contractor](#share-access-with-a-contractor)

**Prefer grant examples**

Grants provide all the capabilities of ACLs plus application-layer permissions. For modern access control patterns, refer to the [grant examples](https://tailscale.com/kb/1458/grant-examples).

[Plan availability](https://tailscale.com/pricing)

Features

Personal, Personal Plus, Premium, and Enterprise

[ACLs](https://tailscale.com/kb/1018/acls), [groups](https://tailscale.com/kb/1337/policy-syntax#groups), [autogroups](https://tailscale.com/kb/1337/policy-syntax#autogroups), [tags](https://tailscale.com/kb/1068/tags), [tag owners](https://tailscale.com/kb/1337/policy-syntax#tag-owners)

You can modify this example to work on the Starter plan by using `autogroup:member` instead of a custom group (`group:dev`).

Your development team can use Tailscale to share access to specific resources, such as a database or a hosted code repository, with a contractor. In this scenario, developers can access internal development resources. Specific devices can be [shared](https://tailscale.com/kb/1084/sharing) with a contractor as part of their job.

What this example does:

-   All employees can access their own devices.
-   Members of the development team `group:dev` can access devices tagged with `tag:dev` (such as package registries and databases)
-   Contractors who have accepted a share invite can access devices tagged with `tag:dev` (that have been shared with them).

```json
{
  "groups": {
    "group:dev": [
      "alice@example.com",
      "bob@example.com"
    ]
  },
  "acls": [
    {
      "action": "accept",
      "src": [
        "autogroup:member"
      ],
      "dst": [
        "autogroup:self:*"
      ]
    },
    {
      "action": "accept",
      "src": [
        "group:dev",
        "autogroup:shared"
      ],
      "dst": [
        "tag:dev:*"
      ]
    }
  ],
  "tagOwners": {
    "tag:dev": [
      "group:dev"
    ]
  }
}
```

## [Remote development](#remote-development)

**Prefer grant examples**

Grants provide all the capabilities of ACLs plus application-layer permissions. For modern access control patterns, refer to the [grant examples](https://tailscale.com/kb/1458/grant-examples).

[Plan availability](https://tailscale.com/pricing)

Features

Personal, Personal Plus, Premium, and Enterprise

[ACLs](https://tailscale.com/kb/1018/acls), [groups](https://tailscale.com/kb/1337/policy-syntax#groups), [autogroups](https://tailscale.com/kb/1337/policy-syntax#autogroups), [tags](https://tailscale.com/kb/1068/tags), [tag owners](https://tailscale.com/kb/1337/policy-syntax#tag-owners)

You can modify this example to work on the Starter plan by using `autogroup:member` instead of a custom group (`group:dev`).

Your development team can use Tailscale as part of their remote development setup. In this scenario, a developer might have a local device, like a laptop, and use it to access a remote workstation, hosted in the cloud or hosted on another device in their network. This is useful if you're accessing a workstation with more processing power, for example, for machine learning or for building. You might also use a remote code environment like [GitHub Codespaces](https://tailscale.com/kb/1160/github-codespaces), [Gitpod](https://tailscale.com/kb/1161/gitpod), or [Coder](https://tailscale.com/kb/1163/coder). From your development environment, you might access a license server, a package registry, a production database, or another development or build resource. You might also access a self-hosted or private code repository.

What this example does:

-   All employees can access their own devices.
-   Members of the development team `group:dev` can access devices tagged with `tag:dev` (such as package registries and databases).
-   The development team `group:dev` can manage which devices are tagged with `tag:dev`.

```json
{
  "groups": {
    "group:dev": [
      "alice@example.com",
      "bob@example.com"
    ]
  },
  "acls": [
    {
      "action": "accept",
      "src": [
        "autogroup:member"
      ],
      "dst": [
        "autogroup:self:*"
      ]
    },
    {
      "action": "accept",
      "src": [
        "group:dev"
      ],
      "dst": [
        "tag:dev:*"
      ]
    }
  ],
  "tagOwners": {
    "tag:dev": [
      "group:dev"
    ]
  }
}
```

## [Pair programming](#pair-programming)

**Prefer grant examples**

Grants provide all the capabilities of ACLs plus application-layer permissions. For modern access control patterns, refer to the [grant examples](https://tailscale.com/kb/1458/grant-examples).

[Plan availability](https://tailscale.com/pricing)

Features

Personal, Personal Plus, Premium, and Enterprise

[ACLs](https://tailscale.com/kb/1018/acls), [tags](https://tailscale.com/kb/1068/tags), [tag owners](https://tailscale.com/kb/1337/policy-syntax#tag-owners)

You can modify this example to work on the Starter plan by using `autogroup:member` and `autogroup:admin` instead of named users.

Your development team can use Tailscale to pair program on the same device remotely. In this scenario, two or more developers can use SSH to connect to a corporate device, such as a virtual machine (VM), and share a terminal (such as a `tmux` session).

What this example does:

-   Users Alice and Bob can access the corporate device tagged `tag:pair-programming` on port `22` (for SSH).
-   Bob can manage which devices are tagged `tag:pair-programming`.

```json
{
  "acls": [
    {
      "action": "accept",
      "src": [
        "alice@example.com",
        "bob@example.com"
      ],
      "dst": [
        "tag:pair-programming:22"
      ]
    }
  ],
  "tagOwners": {
    "tag:pair-programming": [
      "bob@example.com"
    ]
  }
}
```

## [CI/CD deployment pipeline](#cicd-deployment-pipeline)

**Prefer grant examples**

Grants provide all the capabilities of ACLs plus application-layer permissions. For modern access control patterns, refer to the [grant examples](https://tailscale.com/kb/1458/grant-examples).

[Plan availability](https://tailscale.com/pricing)

Features

Personal, Personal Plus, Premium, and Enterprise

[ACLs](https://tailscale.com/kb/1018/acls), [groups](https://tailscale.com/kb/1337/policy-syntax#groups), [tags](https://tailscale.com/kb/1068/tags), [tag owners](https://tailscale.com/kb/1337/policy-syntax#tag-owners)

Your DevOps or infrastructure team can use Tailscale to restrict access to your deployment pipeline. In this scenario, developers can access your development tools, such as your code repository. Then, an automated CI/CD pipeline builds and deploys code. The DevOps team can access the deployment pipeline and production environment.

What this example does:

-   Members of the development team `group:dev` can access the devices tagged with `tag:dev` (such as code repositories and license servers).
-   Members of the DevOps team `group:devops` can access the devices tagged with `tag:ci` (such as the build tooling) and `tag:prod` (such as the production environment).
-   The DevOps team `group:devops` can manage which devices are tagged with `tag:dev`, `tag:ci`, and `tag:prod`.
-   The tag `tag:ci` can manage which device are tagged with `tag:prod` and `tag:dev` (to apply tags as part of the deployment pipeline).

```json
{
  "groups": {
    "group:dev": [
      "alice@example.com",
      "bob@example.com"
    ],
    "group:devops": [
      "carl@example.com"
    ]
  },
  "acls": [
    {
      "action": "accept",
      "src": [
        "group:dev"
      ],
      "dst": [
        "tag:dev:*"
      ]
    },
    {
      "action": "accept",
      "src": [
        "group:devops"
      ],
      "dst": [
        "tag:ci:*",
        "tag:prod:*"
      ]
    }
  ],
  "tagOwners": {
    "tag:ci": [
      "group:devops"
    ],
    "tag:dev": [
      "group:devops",
      "tag:ci"
    ],
    "tag:prod": [
      "group:devops",
      "tag:ci"
    ]
  }
}
```

## [Monitoring access to applications](#monitoring-access-to-applications)

**Prefer grant examples**

Grants provide all the capabilities of ACLs plus application-layer permissions. For modern access control patterns, refer to the [grant examples](https://tailscale.com/kb/1458/grant-examples).

[Plan availability](https://tailscale.com/pricing)

Features

Personal, Personal Plus, Premium, and Enterprise

[ACLs](https://tailscale.com/kb/1018/acls), [groups](https://tailscale.com/kb/1337/policy-syntax#groups), [tags](https://tailscale.com/kb/1068/tags), [tag owners](https://tailscale.com/kb/1337/policy-syntax#tag-owners)

You can modify this example to work on the Starter plan by using `autogroup:member` instead of a custom group (`group:devops`).

Your DevOps team can use Tailscale to query logs from services in your network and report these as part of your monitoring tooling. In this scenario, your monitoring server (such as Prometheus) can access all applications in your network on common ports.

What this example does:

-   Devices tagged with `tag:monitoring` can access services on ports `80`, `443`, `9100`.
-   Devices tagged with `tag:monitoring` can access services tagged `tag:logging`.
-   The DevOps team `group:devops` can access devices tagged with `tag:monitoring` and `tag:logging`.
-   The DevOps team `group:devops` can manage which devices are tagged with `tag:monitoring` and `tag:logging`.

```json
{
  "groups": {
    "group:devops": [
      "carl@example.com"
    ]
  },
  "acls": [
    {
      "action": "accept",
      "src": [
        "tag:monitoring"
      ],
      "dst": [
        "*:80,443,9100",
        "tag:logging:*"
      ]
    },
    {
      "action": "accept",
      "src": [
        "group:devops"
      ],
      "dst": [
        "tag:monitoring:*",
        "tag:logging:*"
      ]
    }
  ],
  "tagOwners": {
    "tag:monitoring": [
      "group:devops"
    ],
    "tag:logging": [
      "group:devops"
    ]
  }
}
```

## [Application peering](#application-peering)

**Prefer grant examples**

Grants provide all the capabilities of ACLs plus application-layer permissions. For modern access control patterns, refer to the [grant examples](https://tailscale.com/kb/1458/grant-examples).

[Plan availability](https://tailscale.com/pricing)

Features

Personal, Personal Plus, Premium, and Enterprise

[ACLs](https://tailscale.com/kb/1018/acls), [groups](https://tailscale.com/kb/1337/policy-syntax#groups), [tags](https://tailscale.com/kb/1068/tags), [tag owners](https://tailscale.com/kb/1337/policy-syntax#tag-owners)

You can modify this example to work on the Starter plan by using `autogroup:member` instead of a custom group (`group:infra`).

Your infrastructure team can use Tailscale to connect applications or services running in multiple cloud providers or SaaS applications together. In this scenario, one application can connect with another application in your network, for example, to stream from one database to another, such as with [Materialize](https://materialize.com/introducing-tailscale-materialize).

What this example does:

-   Devices tagged with `tag:database` can access other devices tagged with `tag:database`.
-   Devices tagged with `tag:gcp` and `tag:aws` can access devices tagged with `tag:database`, but not vice versa.
-   The infrastructure team `group:infra` can manage which devices are tagged with `tag:database`, `tag:gcp`, and `tag:aws`.

```json
{
  "groups": {
    "group:infra": [
      "carl@example.com"
    ]
  },
  "acls": [
    {
      "action": "accept",
      "src": [
        "tag:database",
        "tag:gcp",
        "tag:aws"
      ],
      "dst": [
        "tag:database:*"
      ]
    }
  ],
  "tagOwners": {
    "tag:database": [
      "group:infra"
    ],
    "tag:gcp": [
      "group:infra"
    ],
    "tag:aws": [
      "group:infra"
    ]
  }
}
```

## [Network microsegmentation](#network-microsegmentation)

**Prefer grant examples**

Grants provide all the capabilities of ACLs plus application-layer permissions. For modern access control patterns, refer to the [grant examples](https://tailscale.com/kb/1458/grant-examples).

[Plan availability](https://tailscale.com/pricing)

Features

Personal, Personal Plus, Premium, and Enterprise

[ACLs](https://tailscale.com/kb/1018/acls), [groups](https://tailscale.com/kb/1337/policy-syntax#groups), [tags](https://tailscale.com/kb/1068/tags), [tag owners](https://tailscale.com/kb/1337/policy-syntax#tag-owners), [tests](https://tailscale.com/kb/1337/policy-syntax#tests)

[Network microsegmentation](https://tailscale.com/learn/network-microsegmentation) is a security technique that divides network devices, access, and communications into unique logical units. There are many use cases for this-segmenting data centers, virtual networks, customer deployments, and others. Each microsegment is a logical unit that cannot access other microsegments. In some cases, you might still need a support team or tagged devices that can access all segments.

What this example does:

-   Members of the support team `group:support` can access devices tagged `tag:segment-abc` and `tag:segment-xyz` on port `443`.
-   Devices tagged with `tag:support` can access devices tagged `tag:segment-abc` and `tag:segment-xyz` on port `443`.
-   [Tests](https://tailscale.com/kb/1337/policy-syntax#tests) ensure that if ACLs change:
    -   Members of the support team `group:support` will still be able to access devices tagged `tag:segment-abc` and `tag:segment-xyz` on port `443`.
    -   Devices tagged with `tag:support` will still be able to access devices tagged `tag:segment-abc` and `tag:segment-xyz` on port `443`.
    -   Devices tagged with `tag:segment-abc` are denied access to devices tagged `tag:segment-xyz` on port `443`.
    -   Devices tagged with `tag:segment-xyz` are denied access to devices tagged `tag:segment-abc` on port `443`.

```json
{
  "acls": [
    {
      "action": "accept",
      "src": [
        "group:support"
      ],
      "dst": [
        "tag:segment-abc:443",
        "tag:segment-xyz:443"
      ]
    },
    {
      "action": "accept",
      "src": [
        "tag:support"
      ],
      "dst": [
        "tag:segment-abc:443",
        "tag:segment-xyz:443"
      ]
    }
  ],
  "tests": [
    {
      "src": "group:support",
      "accept": [
        "tag:segment-abc:443",
        "tag:segment-xyz:443"
      ]
    },
    {
      "src": "tag:support",
      "accept": [
        "tag:segment-abc:443",
        "tag:segment-xyz:443"
      ]
    },
    {
      "src": "tag:segment-abc",
      "deny": [
        "tag:segment-xyz:443"
      ]
    },
    {
      "src": "tag:segment-xyz",
      "deny": [
        "tag:segment-abc:443"
      ]
    }
  ],
  "groups": {
    "group:support": [
      "alice@example.com",
      "bob@example.com"
    ]
  },
  "tagOwners": {
    "tag:support": [
      "autogroup:admin"
    ]
  }
}
```
```



### File: 1193-tailscale-ssh.md

```markdown
# Tailscale SSH

Tailscale SSH lets Tailscale manage the authentication and authorization of SSH connections in your tailnet.

Tailscale SSH is available for [the Personal, Personal Plus, Premium, and Enterprise plans](https://tailscale.com/pricing).

## [Why it matters](#why-it-matters)

With Tailscale SSH, you can:

-   **SSH as normal**, using Tailscale for authentication. With Tailscale SSH, Tailscale takes over port `22` for SSH connections incoming from the Tailscale network. Tailscale will authenticate and encrypt the connection over WireGuard, using Tailscale node keys. The SSH client and server will still create an encrypted SSH connection, but it will not be further authenticated.
-   **Verify high-risk connections with check mode**. Optionally require certain connections, or connections as certain users (for example, `root`), to re-authenticate before connecting. This lets the user access these high-risk applications for the next 12 hours or for a specified check period before re-authenticating again.

Your SSH config (`/etc/ssh/sshd_config`) and keys (`~/.ssh/authorized_keys`) files will not be modified, which means that other SSH connections to the same host, not made over Tailscale, will still work.

This video explains some of the features of Tailscale SSH and how to use them.

## [Benefits](#benefits)

-   **Reduce management of SSH keys**-Tailscale SSH uses WireGuard keys that are automatically generated and expire after a session ends.
-   **Enforce access by leveraging Tailscale access controls**-give access only to users and groups that need SSH and enforce it with check mode.
-   **Record SSH sessions with SSH recording**-enforce [SSH recording](https://tailscale.com/kb/1246/tailscale-ssh-session-recording) for audit, troubleshooting, and compliance requirements.

## [Use cases](#use-cases)

-   **SSH access to infrastructure**-ensure all SSH traffic is routed over the tailnet.
-   **Reduce usage of other tools**-consolidate tooling for managing SSH access.
-   **Meet compliance needs**-meet workforce regulatory and compliance requirements for SSH.

## [How is Tailscale SSH different?](#how-is-tailscale-ssh-different)

Historically, to secure an SSH connection, you generate a key pair on the machine you are connecting from (known as the client), with the private key stored on the client, and the public key distributed to the device you want to connect to (known as the server). This lets the server authenticate communication from the client.

With Tailscale, you can already connect machines in your network, and encrypt communications end-to-end from one point to another-and this includes, for example, SSH-ing from your work laptop to your work desktop. Tailscale also knows your identity, since that's how you connected to your tailnet. When you enable Tailscale SSH, Tailscale claims port `22` for the Tailscale IP address (that is, only for traffic coming from your tailnet) on the devices for which you have enabled Tailscale SSH. This routes SSH traffic for the device from the Tailscale network to an SSH server run by Tailscale, instead of your standard SSH server. With Tailscale SSH, based on the access control policies in your tailnet, you can allow devices to connect over SSH and rely on Tailscale instead of public keys for authentication.

SSH

Tailscale SSH

IP addresses

Works with IP addresses.

Works with IP addresses.

[MagicDNS](https://tailscale.com/kb/1081/magicdns)

Works with MagicDNS names.

Works with MagicDNS names.

DNS Limitations

Does not require DNS if using IP addresses.

Uses a custom `known_hosts` file with hostnames. If DNS cannot resolve, this can cause errors.

Access Controls

Works with Access Controls.

Uses centralized policy management based on Tailscale identities.

SSH recording

Works with SSH recording.

macOS

Available.

Requires use of [open source `tailscaled` variant](https://tailscale.com/kb/1065/macos-variants#open-source-tailscaled-variant).

For additional information, refer to [Limitations](#limitations).

## [How does it work?](#how-does-it-work)

Compared to using SSH keys, using Tailscale SSH changes how authentication of your connections, key generation and distribution, and user revocation work.

### [Authentication and authorization](#authentication-and-authorization)

Normally, to establish an SSH connection, the local SSH client you use will connect to the SSH server on the machine you're trying to reach.

With Tailscale SSH, Tailscale will authenticate and encrypt the connection over WireGuard, using Tailscale node keys. The SSH client and server will still create an SSH connection, but during the SSH protocol's authentication phase, the Tailscale SSH server already knows who the remote party is and takes over, not requiring the SSH client to provide further proof (using the SSH authentication type `none`).

Tailscale will only authorize the two devices to connect if the access control policies in the tailnet permit it. Tailscale uses `netstack` port interception and just-in-time automatic configuration of the client `known_hosts` file to make `ssh myhost` work without any new binary or config file. Tailscale implements the SSH File Transfer Protocol (SFTP) which lets SCP and SFTP work for newer SSH clients.

### [Encryption](#encryption)

With Tailscale SSH, in addition to encryption provided by the SSH protocol, Tailscale encrypts the connection end-to-end using WireGuard, which also includes integrity.

### [Key management and distribution](#key-management-and-distribution)

Tailscale already manages and distributes [node keys and machine keys](https://tailscale.com/blog/tailscale-key-management) for devices in your tailnet. Tailscale uses the node key for authentication, authorization, and encryption of the SSH connection.

With Tailscale SSH, Tailscale also distributes public SSH host keys. The private key is stored locally, and the public key is shared with the Tailscale control plane for distribution. This host key means that the SSH client recognizes the host it is connecting to. Once the host is recognized, Tailscale stores the host key to avoid presenting the user with an "unknown host" error message.

Based on an [access control policy](https://tailscale.com/kb/1018/access-control), if two devices are permitted to connect, then Tailscale's control plane will share their public node keys for discovery, which lets these devices generate an end-to-end encrypted WireGuard connection. If also permitted by the access control policy, Tailscale will share their public SSH host keys, which lets these devices be recognized as part of an SSH connection. If a key is compromised, the device can [remove the keys on the device, re-install Tailscale](https://tailscale.com/kb/1069/uninstall), and re-authenticate to generate and distribute new node and SSH host keys.

### [User revocation](#user-revocation)

[Access control policies](https://tailscale.com/kb/1018/access-control) determine which devices, and which users, are authorized for an SSH connection. Unlike with SSH keys which need to be purged, to remove a user's ability to SSH to a device, the access control policy can be updated to restrict a user's access. Once the access control policy is saved, clients respond to the new rules within seconds. This **will** stop existing SSH connections the user has established.

### [Check mode](#check-mode)

Optionally, connections over Tailscale SSH can require a user to re-authenticate before establishing an SSH connection. This requires the user to sign in again with their identity provider. A user will not need to re-authenticate for other connections in check mode for the next 12 hours, or a specified check period.

## [Configure Tailscale SSH](#configure-tailscale-ssh)

### [Prerequisites](#prerequisites)

Tailscale SSH's server component is only available on:

-   Linux
-   macOS open source [`tailscale` + `tailscaled` CLI devices](https://github.com/tailscale/tailscale/wiki/Tailscaled-on-macOS)

You can connect from any device running Tailscale, regardless of platform. Tailscale SSH's server component requires Tailscale v1.24 or later.

To enable Tailscale SSH, you must:

-   Advertise Tailscale SSH from the destination to which you want to connect.
-   Ensure an access control policy exists that grants the source with access to the destination on port `22`.
    -   This is not necessary if you haven't modified the [access control policies](https://tailscale.com/kb/1018/access-control) in your account, as the [default access control policy](https://tailscale.com/kb/1192/acl-samples#allow-all-default-acl) grants access to all devices in the tailnet.
    -   This may require modifying the tailnet policy file to include SSH. You need to be an [Admin or Network admin](https://tailscale.com/kb/1138/user-roles) to modify the tailnet policy file.
-   Ensure an access control policy exists that lets the source use SSH to connect to the destination machine using Tailscale SSH.
    -   This is not necessary if you haven't modified the [access control policies](https://tailscale.com/kb/1018/access-control) in your account, as the [SSH access rules in the default access control policy](#ssh-access-rules-in-default-acl) grant SSH access to all devices.
    -   This will require modifying the tailnet policy file to include SSH policies. You need to be an [Admin or Network admin](https://tailscale.com/kb/1138/user-roles) to modify the tailnet policy file.

### [Advertise SSH on the host](#advertise-ssh-on-the-host)

On the host being connected to, you need to advertise that Tailscale is managing SSH connections which originate from the Tailscale network to this host. To do so, run:

```shell
tailscale set --ssh
```

Running `tailscale set --ssh` will cause any existing SSH connections you have to the host's Tailscale IP to hang.

This generates a host key pair, shares its public half with the Tailscale control plane for distribution to clients, and configures `tailscaled` to intercept all traffic from your tailnet that is routed to port `22` on the Tailscale IP address. This SSH initialization only needs to be done once per host.

### [Ensure Tailscale SSH is permitted in access control policies](#ensure-tailscale-ssh-is-permitted-in-access-control-policies)

Before you can use Tailscale SSH, you have to tell Tailscale which users are allowed to SSH to which devices. Since Tailscale automatically manages the authorization and authentication for you, you need to explicitly define these connections.

SSH access rules are defined in the tailnet policy file, which you can edit through the [Access controls](https://login.tailscale.com/admin/acls) page of the admin console, or through the Tailscale [API](https://tailscale.com/kb/1101/api).

For a connection to be permitted, the tailnet policy file must contain rules permitting both network access and SSH access:

1.  An allowed connection from the source to the destination. This is used to allow any connections in Tailscale (including SSH connections), to distribute keys for WireGuard.
2.  An allowed SSH connection from the source to the destination and the given SSH users. This is used for Tailscale SSH, to distribute keys for authenticating SSH connections.

Each SSH access rule looks like this:

```json
{
  "action": "check", // "accept" or "check"
  "src": [list-of-sources],
  "dst": [list-of-destinations],
  "users": [list-of-ssh-users],
  "checkPeriod": "20h", // optional, only for check actions. default 12h
  "acceptEnv": [ "GIT_EDITOR", "GIT_COMMITTER_*", "CUSTOM_VAR_V?" ] // optional, allowlists environment variables that can be forwarded from clients to the host
},
```

You can use the [visual policy editor](https://tailscale.com/kb/1550/visual-editor) to manage your tailnet policy file. Refer to the [visual editor reference](https://tailscale.com/kb/1587/visual-editor-reference) for guidance on using the visual editor.

#### [`action`](#action)

Specifies whether to accept the connection or to perform additional checks on it.

-   `accept` accepts connections from users already authenticated in the tailnet.
-   `check` requires users to periodically reauthenticate according to the `checkPeriod`.

#### [`src`](#src)

The source where a connection originates from. This can be a user, group, tag, `user:*@<domain>`, or [`autogroup`](https://tailscale.com/kb/1337/policy-syntax#autogroups).

This cannot be a bare wildcard `*`.

Granting access to `autogroup:members` also grants access to [external invited users](https://tailscale.com/kb/1271/invite-any-user) if the destination node is [shared](https://tailscale.com/kb/1084/sharing) with them, even if they have no nodes in your tailnet.

#### [`dst`](#dst)

The destination where the connection goes. This can be a user, tag, or autogroup.

Unlike ACLs, a port cannot be specified. Only port `22` is allowed, and does not need to be specified as it is used by default.

This cannot be a bare wildcard `*`.

#### [`users`](#users)

The set of allowed usernames on the host. Like other SSH clients, Tailscale will only use user accounts that already exist on the host, not create new accounts.

-   Specify `autogroup:nonroot` to allow any user that is not `root`.
-   Specify `localpart:*@<domain>` to allow the user on the host whose name matches the [local-part](https://datatracker.ietf.org/doc/html/rfc2822#section-3.4.1) of the user's login, if and only if the user's login email is in `<domain>`. Tailscale does not do any special processing on the local-part. For example, if the login is `dave+sshuser@example.com`, Tailscale will map this to the SSH user `dave+sshuser`.

#### [`checkPeriod`](#checkperiod)

When `action` is `check`, `checkPeriod` specifies the time period for which to allow a connection before requiring a check. This can be specified in minutes or hours, with a minimum of one minute and a maximum of 168 hours (one week).

-   If not specified, the default is 12 hours.
-   You may also specify `always` to require check mode on every connection. Choosing to always require check mode may cause unexpected behavior with automation tools that open many SSH connections in a short time span, like [Ansible](https://www.ansible.com).

#### [`acceptEnv`](#acceptenv)

The host must be running Tailscale v1.76.0 or later to use `acceptEnv`.

Specifies the set of allowlisted environment variable names that clients can send to the host using [`SendEnv`](https://man.openbsd.org/ssh_config#SendEnv) or [`SetEnv`](https://man.openbsd.org/ssh_config#SetEnv).

Values can contain `*` and `?` wildcard characters. `*` matches zero or more characters and `?` matches a single character.

##### [`acceptEnv` examples](#acceptenv-examples)

`acceptEnv`

Permitted

Rejected

`*`

`FOO_A` `FOO_B` `FOO_OTHER` `BAZ`

`FOO_*`

`FOO_A` `FOO_B` `FOO_OTHER`

`BAZ`

`FOO_?`

`FOO_A` `FOO_B`

`FOO_OTHER` `BAZ`

`FOO_A`

`FOO_A`

`FOO_B` `FOO_OTHER` `BAZ`

#### [Order of evaluation](#order-of-evaluation)

SSH access rules are evaluated considering the most restrictive policies first:

-   Check policies
-   Accept policies

For example, if you have an access rule allowing the user `alice@example.com` to access a resource with an `accept` rule, and a rule allowing `group:devops` which `alice@example.com` belongs to, to access a resource with a `check` rule, then the `check` rule applies.

The only kinds of connections that are allowed are:

-   From a user to their own devices, as any user including `root`.
-   From a user to a tagged device, as any user including `root`.
-   From a user to a [shared](https://tailscale.com/kb/1084/sharing) tagged device, as any user including `root`.
-   From a tagged device to another tagged device, for any tags. An SSH access rule from a tagged device cannot be in [check mode](https://tailscale.com/kb/1193/tailscale-ssh#configure-tailscale-ssh-with-check-mode).

That is, the broadest policy allowed would be:

```json
{
  "grants": [
    {
      "src": ["*"],
      "dst": ["*"],
      "ip": ["*"]
    }
  ],
  "ssh": [
    {
      "action": "accept",
      "dst": ["autogroup:self"],
      "src": ["autogroup:member"],
      "users": ["root", "autogroup:nonroot"]
    },
    {
      "action": "accept",
      "dst": ["tag:prod"],
      "src": ["autogroup:member"],
      "users": ["root", "autogroup:nonroot"]
    },
    {
      "action": "accept",
      "dst": ["tag:prod"],
      "src": ["tag:logging"],
      "users": ["root", "autogroup:nonroot"]
    }
  ]
}
```

You can use the [visual policy editor](https://tailscale.com/kb/1550/visual-editor) to manage your tailnet policy file. Refer to the [visual editor reference](https://tailscale.com/kb/1587/visual-editor-reference) for guidance on using the visual editor.

#### [SSH access rules in default access control policy](#ssh-access-rules-in-default-access-control-policy)

By default, new tailnets or existing tailnets that have not modified their access control policies have a usable but conservative Tailscale SSH access rule. To facilitate connectivity, Tailscale SSH is configured with a [default policy](https://tailscale.com/kb/1192/acl-samples#allow-all-default-acl) that lets the user access their own devices using check mode, as either `root` or non-`root`:

```json
"ssh": [
  {
    // any user can use Tailscale SSH to connect to their own devices
    // in check mode as a root or non-root user
    "action": "check",
    "src": ["autogroup:member"],
    "dst": ["autogroup:self"],
    "users": ["autogroup:nonroot", "root"]
  },
]
```

You can use the [visual policy editor](https://tailscale.com/kb/1550/visual-editor) to manage your tailnet policy file. Refer to the [visual editor reference](https://tailscale.com/kb/1587/visual-editor-reference) for guidance on using the visual editor.

You still need to opt in a destination device.

Modifying the access control policy for SSH overrides this default configuration, and removing it disables Tailscale SSH in your tailnet.

**Important note about `autogroup:nonroot`**

In the default ACL, the `ssh` rule uses `autogroup:self` for the `dst` field and`autogroup:nonroot` in the `users` field. If you change the `dst` field from`autogroup:self` to some other destination, such as an [ACL tag](https://tailscale.com/kb/1068/acl-tags/), also consider replacing `autogroup:nonroot` in the `users` field. If you don't remove`autogroup:nonroot` from the `users` field, then anyone permitted by the `src` setting will be able to SSH in as any nonroot user on the `dst` device.

#### [SSH access rule examples](#ssh-access-rule-examples)

To allow a user to only SSH to their own devices, as non-`root`:

```json
{
  "grants": [
    {
      "src": ["*"],
      "dst": ["*"],
      "ip": ["*"]
    }
  ],
  "ssh": [
    {
      "action": "accept",
      "dst": ["autogroup:self"],
      "src": ["autogroup:member"],
      "users": ["autogroup:nonroot"]
    }
  ]
}
```

You can use the [visual policy editor](https://tailscale.com/kb/1550/visual-editor) to manage your tailnet policy file. Refer to the [visual editor reference](https://tailscale.com/kb/1587/visual-editor-reference) for guidance on using the visual editor.

To allow `group:sre` to access devices in the production environment tagged `tag:prod`:

```json
{
  "grants": [
    {
      "src": ["group:sre"],
      "dst": ["tag:prod"],
      "ip": ["*"]
    }
  ],
  "groups": {
    "group:sre": ["alice@example.com", "bob@example.com"]
  },
  "ssh": [
    {
      "action": "accept",
      "dst": ["tag:prod"],
      "src": ["group:sre"],
      "users": ["ubuntu", "root"]
    }
  ],
  "tagOwners": {
    "tag:prod": ["group:sre"]
  }
}
```

You can use the [visual policy editor](https://tailscale.com/kb/1550/visual-editor) to manage your tailnet policy file. Refer to the [visual editor reference](https://tailscale.com/kb/1587/visual-editor-reference) for guidance on using the visual editor.

It may be useful to match host users with login emails. For example, you can allow `dave@example.com` to authenticate as the host user `dave`. To allow any tailnet member in the login domain `example.com` to access devices in the production environment tagged `tag:prod`, as a user that matches their login email local-part:

```json
{
  "grants": [
    {
      "src": ["user:*@example.com"],
      "dst": ["tag:prod"],
      "ip": ["*"]
    }
  ],
  "ssh": [
    {
      "action": "accept",
      "dst": ["tag:prod"],
      "src": ["user:*@example.com"],
      "users": ["localpart:*@example.com"]
    }
  ]
}
```

You can use the [visual policy editor](https://tailscale.com/kb/1550/visual-editor) to manage your tailnet policy file. Refer to the [visual editor reference](https://tailscale.com/kb/1587/visual-editor-reference) for guidance on using the visual editor.

### [Connect over SSH](#connect-over-ssh)

Now that your access control policy permits SSH, and the destination host has Tailscale configured with SSH, you should be able to use Tailscale SSH.

To connect to a host named `device` in your tailnet:

```shell
ssh device
```

This example uses the [MagicDNS](https://tailscale.com/kb/1081/magicdns) hostname.

The MagicDNS hostname is automatically generated from the machine's name. You can [edit the machine name](https://tailscale.com/kb/1098/machine-names#renaming-a-machine) if you want to use a different name.

To use a user different from the local user, specify the user, for example, `ubuntu`:

```shell
ssh ubuntu@device
```

You can also connect over SSH to a node that is tagged and has been [shared](https://tailscale.com/kb/1084/sharing) with you, as long as the destination host has Tailscale configured with SSH and the destination's access control policy lets you connect over SSH.

In addition to hostnames, it is also possible to use [Tailscale IP addresses](https://tailscale.com/kb/1015/100.x-addresses) as SSH destinations. Tailscale IP addresses remain constant regardless of the device's physical location. Even if a device switches network connections, such as from Wi-Fi to a cellular network, its Tailscale IP address remains the same.

For example, connecting to a Tailscale IP address (like `100.64.0.1`) would resemble:

```shell
ssh user@100.64.0.1
```

You cannot connect to a Tailscale SSH server using a non-Tailscale IP address.

### [Transition from your existing SSH client to Tailscale SSH](#transition-from-your-existing-ssh-client-to-tailscale-ssh)

When you enable Tailscale SSH, Tailscale claims port `22` for the Tailscale IP address (that is, only for traffic coming from your tailnet) on the devices for which you have enabled SSH, and routes SSH traffic for the device to an SSH server run by Tailscale, instead of your standard SSH server. Your SSH config (`/etc/ssh/sshd_config`) and keys (`~/.ssh/authorized_keys`) file will not be modified, which means that other SSH connections to the same host, not made over Tailscale, will still work.

### [Rotate keys](#rotate-keys)

Re-authenticating on the device will generate a new node key pair, store the private key locally, and share the public key with Tailscale for distribution.

To generate new node and SSH host keys:

```shell
tailscale up --ssh --force-reauth
```

## [Disable Tailscale SSH](#disable-tailscale-ssh)

### [Disable Tailscale SSH from a device](#disable-tailscale-ssh-from-a-device)

Prior to disabling Tailscale SSH, ensure you have another way to SSH to the device, or else you may lose access to it.

Run `tailscale set` on the device with `--ssh=false` to disable Tailscale SSH:

```shell
tailscale set --ssh=false
```

### [Block other devices from connecting to your device over SSH](#block-other-devices-from-connecting-to-your-device-over-ssh)

To disable Tailscale SSH on your device, reconfigure the device with `--ssh=false`:

```shell
tailscale set --ssh=false
```

To [block incoming connections](https://tailscale.com/kb/1072/client-preferences#allow-incoming-connections) from the tailnet to your device, including Tailscale SSH connections:

```shell
tailscale set --shields-up
```

### [Revoke a user's ability to SSH](#revoke-a-users-ability-to-ssh)

To remove a user's ability to SSH to a device, modify the [access rule](https://tailscale.com/kb/1337/policy-syntax#acls) specifying the user's ability to SSH to the device. An update to access control policies will be pushed to the device, and remove the user's access, almost instantaneously. You can still allow the user to connect to the device, but not use Tailscale SSH, if that is desired.

This **will** stop existing SSH connections the user has established. The user will receive a message, "Access revoked".

If a user has another way of accessing the device outside of Tailscale, such as their SSH key, this also needs to be removed or revoked.

### [Disable Tailscale SSH from your tailnet](#disable-tailscale-ssh-from-your-tailnet)

To completely remove Tailscale SSH functionality from your tailnet:

-   Opt out every host from Tailscale SSH (`tailscale set --ssh=false`)
-   Remove SSH access rules for Tailscale SSH from the access control policies

You do not need to remove or modify other [access rules](https://tailscale.com/kb/1337/policy-syntax#acls) if you still want users to be able to access the specified devices, but not using Tailscale SSH.

### [Misconfigurations](#misconfigurations)

Tailscale SSH requires access control policies in the tailnet policy file that allow and specify both the SSH source and destination. Additionally, Tailscale SSH must be enabled on the destination device.

If the access control policy is missing, this can be changed in the tailnet policy file in the [Access controls](https://login.tailscale.com/admin/acls) page of the admin console. You need to be an [Admin or Network admin](https://tailscale.com/kb/1138/user-roles) to modify the tailnet policy file.

If SSH is not advertised on the device, connect to the device over Tailscale, then run `tailscale set --ssh`.

## [Configure Tailscale SSH with check mode](#configure-tailscale-ssh-with-check-mode)

SSH check mode lets you require SSH connections to be further verified before establishing the connection. Check mode requires re-authentication on the device initiating the connection. The SSH initialization provides a URL for signing in. The sign-in attempt may also trigger any identity provider [multifactor authentication](https://tailscale.com/kb/1075/multifactor-auth) (MFA) or other risk-based challenges.

![Use check mode to require a user to re-authenticate before being able to establish a Tailscale SSH connection.](/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fcheck-mode-required.8983eaaa.png&w=3840&q=75)

Example of check mode requiring a user to re-authenticate their session in a browser.

Once re-authenticated to a destination, the user can access the device and any other device in the tailnet without re-verification for the next 12 hours. If a different check period is specified for the connection, then the user can access _specifically_ this device without re-verification for the duration of the check period. For example, if a check period of 10 minutes is specified, if the user has not re-authenticated within the last 10 minutes, they will be asked to re-authenticate even if they have re-authenticated within the last 12 hours.

-   Check mode is optional and not enabled by default.
-   Check mode is only available for Tailscale SSH connections.

Check mode is controlled through SSH policy settings. The `ssh` rule must contain the `action` field, set to `check`:

```json
"ssh": [
  {
    "action": "check", // instead of "accept"
    "src": ["autogroup:member"],
    "dst": ["autogroup:self"],
    "users": ["autogroup:nonroot"],
    "checkPeriod": "5m", // optional, define in minutes, hours, or "always"
  }
]
```

You can use the [visual policy editor](https://tailscale.com/kb/1550/visual-editor) to manage your tailnet policy file. Refer to the [visual editor reference](https://tailscale.com/kb/1587/visual-editor-reference) for guidance on using the visual editor.

You can specify a custom check period in minutes or hours. The default check period is 12 hours. You may also specify `"always"` to require check mode on every connection.

Choosing to always require check mode may cause unexpected behavior with automation tools that open many SSH connections in a short time span, such as [Ansible](https://www.ansible.com).

For example, to require check mode for Alice to SSH to devices tagged `tag:prod` as `root` and re-authenticate after `1h`, but not require check mode for her to SSH to her own devices as non-`root`:

```json
{
  "grants": [
    {
      "src": ["*" ],
      "dst": ["*"],
      "ip": ["*"]
    }
  ],
  "ssh": [
    {
      "action": "accept",
      "dst": ["autogroup:self"],
      "src": ["alice@example.com"],
      "users": ["autogroup:nonroot"]
    },
    {
      "action": "check",
      "checkPeriod": "1h",
      "dst": ["tag:prod"],
      "src": ["alice@example.com"],
      "users": ["root"]
    }
  ]
}
```

You can use the [visual policy editor](https://tailscale.com/kb/1550/visual-editor) to manage your tailnet policy file. Refer to the [visual editor reference](https://tailscale.com/kb/1587/visual-editor-reference) for guidance on using the visual editor.

## [Limitations](#limitations)

### [Devices](#devices)

-   You can currently use Tailscale SSH to connect to only devices on your Tailscale network. Devices available behind subnet routers, but not running Tailscale, cannot use Tailscale SSH.
-   You can currently use Tailscale SSH to connect to only Linux devices and macOS open source [`tailscale` + `tailscaled` CLI version devices](https://github.com/tailscale/tailscale/wiki/Tailscaled-on-macOS). You can connect from any device running Tailscale, regardless of platform.
-   You cannot run Tailscale SSH on Synology or QNAP devices.
-   Restarting the Tailscale daemon (`tailscaled`), for example, by performing an upgrade, will stop any existing Tailscale SSH session.

### [Ports](#ports)

Tailscale SSH assumes you use port `22` for SSH.

At this time, there is no way to configure Tailscale SSH to use a different port.

### [SSH users](#ssh-users)

SSH access rules are evaluated based on their restrictiveness, so if both a check and an accept rule exist for a given connection, the check rule applies. This means that the user will be restricted by the SSH `users` in the check rule only, not also considering those allowed in the accept rule.

### [SSH tests](#ssh-tests)

You can write [SSH tests](https://tailscale.com/kb/1337/policy-syntax#sshtests) to assert that your SSH access rules are working as expected.

### [Check mode](#check-mode-1)

You can use check mode only on Tailscale SSH connections, not for plain SSH or other TCP connections running over Tailscale.

### [OS user authentication on the client](#os-user-authentication-on-the-client)

Traditional SSH requires a local OS user on the client machine to be able to read their SSH key pair from files on disk. This effectively restricts which client-side OS users can SSH to remote machines.

Because Tailscale doesn't use a local SSH key pair for authentication, any OS user on the client machine can connect to SSH servers over Tailscale. The scope of this access is still restricted by [Tailscale access control policies](https://tailscale.com/kb/1018/access-control), which are enforced on the server side.

Tailscale SSH is an [improvement](#how-does-it-work) over traditional SSH for:

-   servers and containers that use a single system user to run workloads
-   single-user machines, like employees' laptops
-   any machines that don't allow outbound SSH connections in Tailscale access control policies

Tailscale SSH may not be a good fit for:

-   multi-user machines, where OS users on those machines have different SSH access permissions in Tailscale access control policies
-   machines that have outbound Tailscale SSH access, where you do not trust the code running on those machines
-   machines where you use `authorized_keys` to limit what commands remote users can run

You can mitigate this concern by using [check mode](#configure-tailscale-ssh-with-check-mode) with `checkPeriod` set to `always`, which will prompt for SSO-based approval on every new connection.

If Tailscale SSH is not a good fit for your needs, you can still run traditional SSH servers and clients on top of Tailscale as the network layer. This provides you the standard SSH experience without exposing your servers to the internet.

## [Additional information](#additional-information)

-   Tailscale CLI command: [`tailscale set --ssh`](https://tailscale.com/kb/1080/cli#set)
-   Tailscale CLI command: [`tailscale up --ssh`](https://tailscale.com/kb/1241/tailscale-up)
-   tailnet policy file section: [`ssh`](https://tailscale.com/kb/1337/policy-syntax#ssh)
```



### File: 1203-audit-logging.md

```markdown
# Configuration audit logging

Configuration audit logs let you identify _who_ did _what_, and _when_, in your tailnet. Configuration audit logs record actions that modify a tailnet's configuration, including the type of action, the actor, the target resource, and the time.

You can export logs for long-term storage and/or for security analysis, threat detection, and incident investigation. You can also stream logs to a security information and event management ([SIEM](https://tailscale.com/learn/security-information-and-event-management)) system.

For changes to the tailnet policy file, the log includes a full diff of the previous and new files.

Configuration audit logs are available for [all plans](https://tailscale.com/pricing).

All [users who have access to the admin console](https://tailscale.com/kb/1138/user-roles) can view configuration audit logs in the [Logs](https://login.tailscale.com/admin/logs) page of the admin console, and can filter these logs to find specific events.

Configuration audit logs are enabled by default for all tailnets, and are available for the most recent 90 days.

## [Log structure](#log-structure)

Logs include several components:

-   **Timestamp**: When the event happened. This is displayed in your browser's local time.
-   **Action**: What action happened. For example, approve a device, or modify the tailnet policy file.
-   **Actor**: Which user or process completed the action. If the action is made by a user, this value is the user's name. The user's email or GitHub username, as well as their name, is available in the events returned by the API. If the action is made by the Tailscale control plane, this value is the Tailscale service. For a list of actions made by the Tailscale control plane, see [Service events](#service-events).
-   **Target**: Which resource the action applied to. For example, for an action modifying a user's role, the target is the user. For an action approving a device, the target is the device. Where the action is a tailnet-wide configuration, the target is the tailnet.
-   **Diff**: The old and the new values provided, if relevant. For example, if you renamed a node's machine name, or updated a list of tags, you will see both the old and new values. For access control policy changes, you'll see a full diff of the previous and updated versions, including non-substantive changes like comments. For re-authenticating a node, you'll see the old node key expiry and the new key expiry.

![The Logs page of the admin console listing example configuration logs.](/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Faudit-logging-page.f678414b.png&w=3840&q=75)

## [Enabling configuration audit logging](#enabling-configuration-audit-logging)

Configuration audit logs are always enabled for all tailnets and cannot be disabled.

Configuration audit logs are a subset of the logs that Tailscale uses to provide the service, in line with our [privacy policy](https://tailscale.com/privacy-policy#the-information-we-collect).

## [Accessing configuration audit logs](#accessing-configuration-audit-logs)

Configuration audit logs can be accessed in the [Logs](https://login.tailscale.com/admin/logs) page of admin console or via API.

### [Viewing configuration audit logs in the admin console](#viewing-configuration-audit-logs-in-the-admin-console)

All [users who have access to the admin console](https://tailscale.com/kb/1138/user-roles) can view configuration audit logs in the [Logs](https://login.tailscale.com/admin/logs) page of the admin console, and can filter these logs to find specific events.

Logs are shown in the order that events occurred, starting with the most recent.

#### [Filtering configuration audit logs](#filtering-configuration-audit-logs)

Events in the [Logs](https://login.tailscale.com/admin/logs) page of the admin console can be filtered to more easily find events meeting certain criteria.

Filters can be used on time, action, and actor. Multiple filters can be applied simultaneously to find events meeting all the filtering criteria.

![The 'Action' dropdown expanded with filters. Several example filters have checkmarks.](/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Faudit-log-filter.74ba9f3f.png&w=1080&q=75)

#### [Time](#time)

Use the **Timeframe** filter to show only logs between two specified dates.

#### [Type of action](#type-of-action)

Use the **Action** filter to show only logs that match the selected actions. For example, you can see all events that include an update to your tailnet policy file.

#### [Actor](#actor)

Use the **Actor** filter to show only logs where actions were taken by the selected users.

### [Accessing configuration audit logs via API](#accessing-configuration-audit-logs-via-api)

You can export configuration audit logs from the Tailscale [API](https://tailscale.com/kb/1101/api). You need an [API access token](https://tailscale.com/kb/1101/api#authentication) with the `logs:configuration:read` scope to access configuration audit logs.

The response to the `logs` API call is in the form of the `TailnetLogsResponse` struct:

```go
type TailnetLogsResponse struct {
  Version string        `json:"version"`
  Tailnet dbx.TailnetID `json:"tailnetId"`

  Logs []Log `json:"logs"` // Ordered chronologically
}
```

You can use the following query parameters with the API:

-   `start`: Required. Start of the timeframe, in [RFC3339](https://datatracker.ietf.org/doc/html/rfc3339) timestamp format, for the logs to retrieve. For example: `2022-07-20T00:00:00Z`.
-   `end`: Required. End of the timeframe, in RFC3339 timestamp format, for the logs to retrieve. For example, `2022-07-21T00:00:00Z`.

`start` and `end` times are inclusive within nanosecond resolution.

This example assumes you have set up the following variables to use for your API call:

-   `$ACCESS_TOKEN`: An [API access token](https://tailscale.com/kb/1101/api#authentication) to use when calling the Tailscale API. You can create an API access token in the [Keys](https://login.tailscale.com/admin/settings/keys) page of the admin console.
-   `$TAILNET_ID`: The [tailnet ID](https://tailscale.com/kb/1217/tailnet-name#tailnet-id). You can find your tailnet ID in the [General](https://login.tailscale.com/admin/settings/general) page of the admin console.
-   `$START`: The start of the timeframe for the logs to retrieve.
-   `$END`: The end of the timeframe for the logs to retrieve.

```shell
export ACCESS_TOKEN=tskey-api-k123456CNTRL-0123456789abcdef
export TAILNET_ID=example.com
export START=2022-07-20T00:00:00Z
export END=2022-07-21T00:00:00Z
```

```shell
curl -u  $ACCESS_TOKEN:  -X GET \
  "https://api.tailscale.com/api/v2/tailnet/{$TAILNET_ID}/logging/configuration?start={$START}&end={$END}"
```

Optionally, use `json_pp` to prettify the JSON output:

```shell
curl -u  $ACCESS_TOKEN: -X GET \
  "https://api.tailscale.com/api/v2/tailnet/{$TAILNET_ID}/logging/configuration?start={$START}&end={$END}" \
  | json_pp
```

The output will look like:

```json
{
  "logs": [
    {
      "action": "UPDATE",
      "actor": {
        "displayName": "Alice Architect",
        "id": "123456CNTRL",
        "loginName": "alice@example.com",
        "type": "USER"
      },
      "deferredAt": "0001-01-01T00:00:00Z",
      "eventGroupID": "12345",
      "eventTime": "2022-07-20T20:13:30.136022207Z",
      "new": "2023-01-14T20:13:30.134350003Z",
      "old": "0001-01-01T00:00:00Z",
      "origin": "NODE",
      "target": {
        "id": "654321CNTRL",
        "name": "node1.yak-bebop.ts.net",
        "property": "KEY_EXPIRY_TIME",
        "type": "NODE"
      },
      "type": "CONFIG"
    },
    {
      "action": "CREATE",
      "actor": {
        "displayName": "Alice Architect",
        "id": "123456CNTRL",
        "loginName": "alice@example.com",
        "type": "USER"
      },
      "deferredAt": "0001-01-01T00:00:00Z",
      "eventGroupID": "23456",
      "eventTime": "2022-07-20T18:40:58.838529518Z",
      "new": {
        "capabilities": ["CONTROL_API_SCOPE_ALL_READ", "CONTROL_API_SCOPE_ALL"],
        "expires": "2022-10-18 18:40:58.653877012 +0000 UTC"
      },
      "origin": "ADMIN_UI",
      "target": {
        "id": "789123CNTRL",
        "name": "Control API key",
        "type": "API_KEY"
      },
      "type": "CONFIG"
    },
    {
      "action": "UPDATE",
      "actor": {
        "displayName": "Bob Builder",
        "id": "987654CNTRL",
        "loginName": "bob@example.com",
        "type": "USER"
      },
      "deferredAt": "0001-01-01T00:00:00Z",
      "eventGroupID": "34567",
      "eventTime": "2022-07-20T22:35:19.590021877Z",
      "new": ["...", "...", "10.0.0.0/24", "10.0.1.0/24"],
      "old": ["...", "..."],
      "origin": "ADMIN_UI",
      "target": {
        "id": "876543CNTRL",
        "name": "bob-workstation.yak-bebop.ts.net",
        "property": "ALLOWED_IPS",
        "type": "NODE"
      },
      "type": "CONFIG"
    }
  ],
  "tailnetId": "example.com",
  "version": "1.1"
}
```

Currently, there is no pagination support and no maximum page size for the API. All events in the specified timeframe are returned.

When [multiple events occur for a single operation](#multiple-events-for-a-single-operation), the actions have the same value for `eventGroupID`.

## [Reverting access control policies from audit logs](#reverting-access-control-policies-from-audit-logs)

This option is not available if you are using [GitOps for Tailscale](https://tailscale.com/kb/1204/gitops-acls).

You need to be an [Owner, Admin, or IT admin](https://tailscale.com/kb/1138/user-roles) of a tailnet to revert a [tailnet policy file](https://tailscale.com/kb/1155/terminology-and-concepts#tailnet-policy-file) from audit logs.

You can revert your tailnet policy file from a previous date and time.

1.  Open the [Configuration logs](https://login.tailscale.com/admin/logs) page of the admin console.

2.  Locate and expand the log entry containing the policy file change you want to revert to, then select **Revert to previous version**. In the confirmation dialog, select **Revert**.

    ![The policy file change display. Highlighting 'Revert to previous version'.](/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Flog-acl-revert.1b1c75e4.png&w=3840&q=75)

3.  Open the [Access controls](https://login.tailscale.com/admin/acls) page of the admin console and verify the policy file was reverted with the expected changes.


## [Events](#events)

Configuration audit logs include write actions that change the configuration of a tailnet, including changes that a user can make in the admin console or via API.

Any successfully completed event will create a corresponding log entry.

Events included in configuration audit logs are:

**Target**

**Action**

**Description**

Tailnet

Create tailnet

Tailnet was created.

Update policy file for tailnet

[Tailnet policy file](https://tailscale.com/kb/1018/acls) was modified. This includes changes to [tests](https://tailscale.com/kb/1337/policy-syntax#tests), [tagOwners](https://tailscale.com/kb/1337/policy-syntax#tag-owners), [autoApprovers](https://tailscale.com/kb/1337/policy-syntax#autoapprovers), and [Tailscale SSH](https://tailscale.com/kb/1337/policy-syntax#ssh) configurations.

Update max key duration for tailnet

[Key expiry](https://tailscale.com/kb/1028/key-expiry) was modified.

Update DNS configuration for tailnet

[DNS](https://tailscale.com/kb/1054/dns) configuration was updated. This includes adding global or restricted nameservers (Split DNS) and changes to MagicDNS.

Enable device approval for tailnet

[Device approval](https://tailscale.com/kb/1099/device-approval) was enabled.

Disable device approval for tailnet

Device approval was disabled.

Enable user approval for tailnet

[User approval](https://tailscale.com/kb/1239/user-approval) was enabled.

Disable user approval for tailnet

User approval was disabled.

User joined external tailnet

A user in your tailnet joined [another tailnet](https://tailscale.com/kb/1271/invite-any-user).

User left external tailnet

A user in your tailnet left another tailnet.

Enable MagicDNS for tailnet

[MagicDNS](https://tailscale.com/kb/1081/magicdns) was enabled.

Disable MagicDNS for tailnet

MagicDNS was disabled.

Enable Mullvad VPN for tailnet

[Mullvad Exit Nodes](https://tailscale.com/kb/1258/mullvad-exit-nodes) were enabled.

Disable Mullvad VPN for tailnet

Mullvad Exit Nodes were disabled.

Enable Taildrop for tailnet

[Taildrop](https://tailscale.com/kb/1106/taildrop) was enabled.

Disable Taildrop for tailnet

Taildrop was disabled.

Enable services collection for tailnet

[Services collection](https://tailscale.com/kb/1100/services) was enabled.

Disable services collection for tailnet

Services collection was disabled.

Enable HTTPS domain for tailnet

[HTTPS](https://tailscale.com/kb/1153/enabling-https) was enabled.

Disable HTTPS domain for tailnet

HTTPS was disabled.

Update tailnet DNS name

[Tailnet DNS name](https://tailscale.com/kb/1217/tailnet-name#tailnet-dns-name) was changed.

Enable user and group provisioning for tailnet

[User and group provisioning](https://tailscale.com/kb/1290/user-group-provisioning) was enabled.

Disable user and group provisioning for tailnet

User and group provisioning was disabled.

Update account email for tailnet

[Account email](https://tailscale.com/kb/1224/contact-preferences#setting-the-account-changes-email) was updated.

Verify account email for tailnet

Account email was verified.

Update configuration email for tailnet

[Configuration email](https://tailscale.com/kb/1224/contact-preferences#setting-the-configuration-issues-email) was updated.

Verify configuration email for tailnet

Configuration email was verified.

Update security email for tailnet

[Security email](https://tailscale.com/kb/1224/contact-preferences#setting-the-security-issues-email) was updated.

Verify security email for tailnet

Security email was verified.

Join waitlist for feature

A waitlist for an [invite only feature](https://tailscale.com/kb/1222/invite-only-feature) was joined.

Accept invite for feature

An invitation to an invite only feature was accepted.

Create logstream endpoint for tailnet

A log streaming endpoint was created.

Update logstream endpoint for tailnet

A log streaming endpoint destination was updated.

Delete logstream endpoint for tailnet

A log streaming endpoint was deleted.

Enable network flow logging for tailnet

[Network flow logs](https://tailscale.com/kb/1219/network-flow-logs) were enabled.

Disable network flow logging for tailnet

Network flow logs were disabled.

Enable tailnet lock

[Tailnet Lock](https://tailscale.com/kb/1226/tailnet-lock) was enabled.

Disable tailnet lock

Tailnet Lock was disabled.

Sign node key for tailnet lock

A node's key was signed by a trusted Tailnet Lock key.

Add trusted key to tailnet lock

A trusted key was added to Tailnet Lock.

Remove trusted key from tailnet lock

A trusted key was removed from Tailnet Lock.

Update tailnet lock trusted key

A trusted Tailnet Lock key was updated.

Create webhook endpoint

A [webhook](https://tailscale.com/kb/1213/webhooks) was created.

Delete webhook endpoint

A webhook was deleted.

Update secret for webhook endpoint

The [secret](https://tailscale.com/kb/1213/webhooks#webhook-secret) for a webhook was updated.

Update subscribed events for webhook endpoint

The set of subscribed [events](https://tailscale.com/kb/1213/webhooks#events) for a webhook was updated.

Enable posture identity collection

Collection of [device posture identifiers](https://tailscale.com/kb/1326/device-identity-collection) (for example, serial numbers) was enabled.

Disable posture identity collection

Collection of device posture identifiers was disabled.

Create posture integration

A new [device posture integration](https://tailscale.com/kb/1289/crowdstrike-zta) was added.

Update posture integration

A device posture integration was updated.

Remove posture integration

A device posture integration was removed.

Billing

Create billing subscription for tailnet

Subscription was created.

Update billing subscription for tailnet

Subscription was modified. This includes changes to the [selected plan](https://tailscale.com/pricing) and limits. _Note that the log will not include diffs for subscriptions. Information on the current subscription is available on the [Billing](https://login.tailscale.com/admin/settings/billing) page of the admin console._

Cancel billing subscription for tailnet

Subscription was canceled.

Update billing address for tailnet

[Billing address](https://tailscale.com/kb/1182/billing-information#name-and-address) was modified. This includes physical address and name.

Update billing email for tailnet

[Billing email](https://tailscale.com/kb/1182/billing-information#billing-email) was modified.

Update billing payment information for tailnet

[Billing payment information](https://tailscale.com/kb/1182/billing-information) was modified, including payment method and [tax IDs](https://tailscale.com/kb/1182/billing-information#tax-ids).

User

Create user

User joined the tailnet.

Invite user to join tailnet

User is either sent or resent an [invite](https://tailscale.com/kb/1064/invite-team-members) to join a tailnet.

Approve user

User [was approved](https://tailscale.com/kb/1239/user-approval).

Update role for user

User's [role](https://tailscale.com/kb/1138/user-roles) was changed.

Suspend user

User was [suspended](https://tailscale.com/kb/1145/remove-team-members#suspending-users) from the tailnet.

Restore user

User was [restored](https://tailscale.com/kb/1145/remove-team-members#restoring-users) to the tailnet.

Delete user

User was [deleted](https://tailscale.com/kb/1145/remove-team-members#deleting-users) from the tailnet.

Push user

User attributes were updated for a user [provisioned](https://tailscale.com/kb/1290/user-group-provisioning) in a [SCIM-integrated](https://tailscale.com/learn/what-is-scim) identity provider.

Group

Push group

A group was provisioned in a SCIM-integrated identity provider.

Node

Create node

Node was added. For tailnets with [device approval](https://tailscale.com/kb/1099/device-approval) enabled, it may not yet be approved.

Log in node

User logged in to or re-authenticated on a node. This includes re-authentication as part of [Tailscale SSH check mode](https://tailscale.com/kb/1193/tailscale-ssh#configure-tailscale-ssh-with-check-mode).

Approve node

Node was [approved](https://tailscale.com/kb/1099/device-approval).

Update name for node

[Node name](https://tailscale.com/kb/1098/machine-names) updated.

Enable key expiry for node

Node [key expiry](https://tailscale.com/kb/1028/key-expiry) was enabled.

Disable key expiry for node

Node key expiry was disabled.

Update key expiry time for node

User re-authenticated the node, extending the node key validity, or node key expiry was [temporarily extended](https://tailscale.com/kb/1028/key-expiry#renewing-keys-for-an-expired-device).

Expire node key

Node key expired.

Update approved routes for node

[Routes](https://tailscale.com/kb/1019/subnets) for this node were manually updated.

Update auto approved routes for node

Routes for this node were automatically updated based on [auto approvers](https://tailscale.com/kb/1337/policy-syntax#autoapprovers).

Update exit settings for node

[Exit node](https://tailscale.com/kb/1103/exit-nodes) advertised by the node updated.

Update tags for node

Node [tags](https://tailscale.com/kb/1068/tags) updated.

Update node attribute

A [device posture attribute](https://tailscale.com/kb/1288/device-posture#posture-attributes-api) was changed on the node.

Update node posture identity

[Device posture identity](https://tailscale.com/kb/1326/device-identity-collection) for the node was changed.

Log out node

User logged out of node.

Delete node

Node was deleted.

Admin console

Log in to admin console

[Authorized user](https://tailscale.com/kb/1138/user-roles#permission-matrix) logged in to the admin console.

Log out of admin console

Authorized user logged out of the admin console.

login.tailscale.com

Log in using web interface

[Member](https://tailscale.com/kb/1138/user-roles#member) user logged in to the web interface.

Log out using web interface

Member user logged out of the web interface.

Invite

Create invite for node share

Node [share invite](https://tailscale.com/kb/1084/sharing) was created by sharer tailnet. The invite target is the label entered when creating the invite.

Accept invite for node share

Node share invite was accepted by sharee tailnet.

Delete invite for node share

Node share invite was revoked by sharer tailnet.

Share

Create node share

Shared node was added to sharee's tailnet.

Update node share

Shared node was updated. This occurs when a shared node is shared with a sharee who already has the shared node.

Delete node share

Shared node was deleted from sharee's tailnet. This could be an action by either the sharer (to revoke access to the shared node) or the sharee (to remove the shared node from their tailnet).

API

Failed request

API call attempted with insufficient permission.

API key

Create API key

[API access token](https://tailscale.com/kb/1101/api) was generated.

Revoke API key

API access token was revoked.

API key expired

API access token expired.

Auth key

Create API key

[Auth key](https://tailscale.com/kb/1085/auth-keys) was generated. This includes tags and if the key is reusable, ephemeral, pre-approved.

Revoke API key

Auth key was revoked.

API key expired

Auth key expired.

Note that failed login attempts are not included in Tailscale events-these should be seen in your identity provider logs, not Tailscale logs.

## [Multiple events for a single operation](#multiple-events-for-a-single-operation)

Multiple events that occur as part of the same operation are logged individually. For example, when a user is deleted, there are log entries for deleting each of their nodes and each of their API access tokens, as well as deleting the user themselves. When a node is added to your tailnet, there are log entries for updating the name for a node, creating a node, updating the key expiry time for a node, logging into a node, and if applicable, approving the node.

**Operation**

**Events**

A user is added to the tailnet

-   (If user was [sent an invite](https://tailscale.com/kb/1064/invite-team-members)) Invite user to join tailnet
-   Create user
-   (If [user approval](https://tailscale.com/kb/1239/user-approval) is enabled) Approve user

A user is deleted

-   Delete node, for each node
-   Delete user

A node is added to the tailnet

-   Update name for node (name set from blank to node name)
-   Create node
-   Update [key expiry](https://tailscale.com/kb/1028/key-expiry) time for node (key expiry set for current time + expiry period)
-   Log in node


Shortly afterwards, if [device approval](https://tailscale.com/kb/1099/device-approval) is enabled:

-   Approve node

A node is logged out

-   Enable key expiry for node (key expiry is enabled)
-   Update key expiry time for node (key expiry is set to the current time)
-   Log out node

A node is re-authenticated

-   Update key expiry time for node
-   Log in node

MagicDNS is enabled

-   Enable [MagicDNS](https://tailscale.com/kb/1081/magicdns) for tailnet
-   Update [DNS](https://tailscale.com/kb/1054/dns) configuration for tailnet

MagicDNS is disabled

-   Disable MagicDNS for tailnet
-   Update DNS configuration for tailnet

## [Events for shared nodes](#events-for-shared-nodes)

When using [shared nodes](https://tailscale.com/kb/1084/sharing), some events are logged in both the sharer and sharee tailnets. Events related to invites are only logged in the sharer tailnet, and events related to the shared node are logged in both the sharer and sharee tailnets.

**Target**

**Action**

**Actor**

**Logged by sharer tailnet?**

**Logged by sharee tailnet?**

Invite

Create invite for node share

Sharer admin

✅

❌

Accept invite for node share

Sharee admin

✅

❌

Delete invite for node share

Sharer admin

✅

❌

Share

Create node share

Sharee admin

✅

✅

Update node share

Sharee admin

✅

✅

Delete node share

Sharer admin or Sharee admin

✅

✅

## [Service events](#service-events)

The log includes service events, which are actions performed by the Tailscale service, not performed by users directly. Service events include:

**Target**

**Action**

**Actor**

**Description**

Tailnet

Suspend user

Tailscale service: user and group provisioning

User deactivated or unassigned from the Tailscale app for tailnets using [user & group provisioning](https://tailscale.com/kb/1290/user-group-provisioning)

Tailnet

Restore user

Tailscale service: user and group provisioning

User reactivated or assigned the Tailscale app for tailnets using user & group provisioning

Node

Delete node

Tailscale service: remove ephemeral node

Remove inactive [ephemeral node](https://tailscale.com/kb/1111/ephemeral-nodes)

API key or Auth key

API key expired

Tailscale service: expire API key

[Expire](https://tailscale.com/kb/1101/api) key after 90 days

## [Events not included](#events-not-included)

Changes to a tailnet that were initiated by a request to Tailscale's support team are currently not included. This includes:

-   Update [identity provider](https://tailscale.com/kb/1013/sso-providers#changing-identity-providers)
-   Complete identity provider configuration for [Okta](https://tailscale.com/kb/1066/sso-okta#steps) or [OneLogin](https://tailscale.com/kb/1070/sso-onelogin)
-   Update [tailnet ID](https://tailscale.com/kb/1217/tailnet-name#tailnet-id)
-   Update custom [HTTPS domain](https://tailscale.com/kb/1153/enabling-https)
-   Delete tailnet
-   Allowlist tailnet for alpha feature

Changes that would have been included if performed by a user, but were instead initiated by a Support request are also not included:

-   Update the [tailnet ID](https://tailscale.com/kb/1217/tailnet-name#tailnet-id)
-   Update role for user
-   Delete user
-   Create billing subscription for tailnet
-   Update billing subscription for tailnet
-   Cancel billing subscription for tailnet
-   Update billing address for tailnet
-   Update billing email for tailnet
-   Update billing payment information for tailnet
-   Update key expiry time for node
-   Enable device approval for tailnet
-   Disable device approval for tailnet

## [Configuration audit logs streaming](#configuration-audit-logs-streaming)

Log streaming lets you stream network flow logs into a security information and event management ([SIEM](https://tailscale.com/learn/security-information-and-event-management)) system. For more information, see [Log streaming](https://tailscale.com/kb/1255/log-streaming).

## [Limitations](#limitations)

-   Configuration audit logs only include actions that modify a tailnet's configurations. Read-only actions, such as a user viewing the admin console, are not included.
-   Changes to a tailnet that were initiated by Tailscale's support team are not currently included.
-   Configuration audit logs only include changes to configuration of a tailnet. Information about connections within a tailnet (data plane audit logs), such as network flow logs, are not included in configuration logs. You can use [Network flow logs](https://tailscale.com/kb/1219/network-flow-logs) to log information about connections with a tailnet.
-   Configuration audit logs are available as part of the admin console, exportable via API, and as a [streaming source](https://tailscale.com/kb/1255/log-streaming) for SIEM systems.
-   There is currently no guarantee for a maximum delay between an event taking place and its inclusion in the audit logs. In practice, this occurs within seconds.
-   The period of time that configuration logs are stored cannot be configured. Configuration logs are stored for 90 days.
-   [Devices with the same node key](https://tailscale.com/kb/1023/troubleshooting#multiple-devices-have-the-same-100x-ip-address) will appear in logs as the same node target.
-   When a user is suspended, the suspension of the user's nodes, API access tokens, and auth keys are not logged.
-   When a user is deleted, the deletion of the user's API access tokens and auth keys are not logged.
```



### File: 1212-shared-responsibility.md

```markdown
# Shared responsibility model

Securing a virtual private network requires both the provider and the user to share in the burden of responsibility. This non-exhaustive list covers responsibilities for both Tailscale and the user.

## [Tailscale's responsibilities](#tailscales-responsibilities)

-   **Use secure software development practices** for development of the Tailscale client, the coordination server, and relay servers. This includes conducting peer reviews of source code changes, conducting regular audits of source code, reviewing potential vulnerabilities and developing patches, regularly patching dependencies, and building, signing, and releasing software following a sanctioned process.
-   **Harden and protect the coordination server**, including hardening the hosting provider and database configurations, and hardening and patching the operating system. This includes encrypting and backing up data by default, restricting access to the production environment based on business need, and monitoring the production environment for unusual activity.
-   **Harden and protect the DERP relay servers**, including hardening the hosting provider configurations, and hardening and patching the operating system. This includes restricting access based on business need.
-   **Provide features for securing your tailnet**, such as [integrations with identity providers](https://tailscale.com/kb/1013/sso-providers) and [access control policies](https://tailscale.com/kb/1393/access-control).

To learn more about how Tailscale protects your network, see the [Security](https://tailscale.com/security) page.

## [User's responsibilities](#users-responsibilities)

-   **Maintain the devices you run Tailscale on**, including patching the firmware and operating system of those devices, and providing network connectivity to those devices.
-   **Configure and maintain your identity provider**, so that only authorized users are able to join your network.
-   **Update Tailscale clients regularly to supported versions**. On some operating systems (macOS and iOS), clients are automatically updated. Tailscale is responsible for [responding to security issues](https://tailscale.com/security-bulletins) and providing patches in a timely manner, but it's your responsibility to upgrade to apply these patches.
-   **Provide Tailscale with bug reports or logs** when requested for troubleshooting purposes as part of a support request.
-   **Configure security features in Tailscale** to restrict access as appropriate for your environment. For example, use access control policies to restrict access to resources in your network, and use groups and tags to make management of users and devices more simple.

To best protect your network, we recommend following the [hardening guide](https://tailscale.com/kb/1196/security-hardening).
```



### File: 1213-webhooks.md

```markdown
# Webhooks

Webhooks let you subscribe to certain events on your Tailscale network and process the event notifications through an integration or app. For example, you could integrate Tailscale events with a Slack channel. If subscribed to an event such as adding a node, your webhook endpoint can send a message in a Slack channel anytime a node is added to your tailnet.

![Tailscale events in a Slack channel](/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Ftailscale-events-slack.01bdd3d7.png&w=3840&q=75)

Webhooks are available for [all plans](https://tailscale.com/pricing).

## [How it works](#how-it-works)

You provide a webhook endpoint which can receive HTTPS POST requests for subscribed Tailscale events. The body of the request provides information about the event. It is up to you to determine how the webhook should process a notification. Tailscale typically sends an event notification to a webhook within a few seconds of the event's occurrence.

You create and manage webhook endpoints in the [Webhooks](https://login.tailscale.com/admin/settings/webhooks) page of the admin console.

Tailscale provides a digital signature for events that it sends, so you can verify whether an event was signed by a secret that is shared between you and Tailscale.

Webhook events are sent as JSON objects, with the format described in [events payload](#events-payload). Optionally, you can configure webhooks to send events in a compatible format for the following destinations:

Destination

Destination's webhook documentation

Discord

[Intro to Discord webhooks](https://support.discord.com/hc/en-us/articles/228383668-Intro-to-Webhooks)

Google Chat

[Send messages to Google Chat with incoming webhooks](https://developers.google.com/chat/how-tos/webhooks)

Mattermost

[Mattermost webhooks](https://developers.mattermost.com/integrate/webhooks)

Slack

[Sending Slack messages using incoming webhooks](https://api.slack.com/messaging/webhooks)

## [Prerequisites](#prerequisites)

-   You need a webhook endpoint which will process the Tailscale event notifications.

-   Your webhook endpoint must be able to process HTTPS POST requests and must use either port `80` or port `443`.

-   You need to be an [Owner, Admin, Network admin, or IT admin](https://tailscale.com/kb/1138/user-roles) of a tailnet to create, modify, or delete webhooks.


## [Setting up a webhook endpoint](#setting-up-a-webhook-endpoint)

Webhooks apply to a tailnet. If one user creates a webhook, other [Owner, Admin, Network admin, or IT admin](https://tailscale.com/kb/1138/user-roles) users in the tailnet can modify or delete it. If a webhook is created by a user who is later removed or suspended from your tailnet, the webhook will still work.

1.  Open the [Webhooks](https://login.tailscale.com/admin/settings/webhooks) page of the admin console.

2.  Select **Add endpoint**.

3.  In the **Add endpoint** page:

    1.  For **Webhook URL**, provide the endpoint for your webhook. The endpoint URL must use the HTTPS protocol, and must use either port `80` or port `443`.

    2.  (Optional) For **Destination**, select the destination for the endpoint. Tailscale will send your webhook events in the format expected by the destination. (If you enter a Discord or Slack URL for **Webhook URL**, then the **Destination** field will be grayed out with the respective destination selected.)

        ![The webhooks 'Webhook URL' UI in the admin console](/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fadd-webhook-endpoint.e488686c.png&w=1080&q=75)

        Choose **None** if you are using the general Tailscale format for the events.

    3.  Select the event categories or events you want to receive as notifications.

        A category is a set of related events. For example, the **Tailnet Management** category contains events related to node actions and [tailnet policy file](https://tailscale.com/kb/1337/policy-syntax) updates. If you select a category, you will be subscribed to any new events that Tailscale adds to the category in the future.

        If you don't want to use categories, you can select specific events.

        ![The webhooks 'Events' UI in the admin console](/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fwebhook-events.b12a00fe.png&w=1080&q=75)

    4.  Select **Add endpoint**.

4.  On the subsequent **Webhook secret** popup, select **Copy** to copy the newly-created webhook secret. After you close the **Webhook secret** page, you won't be able to copy the secret again. Also, note that Tailscale-generated webhook secrets are case-sensitive.


Store the webhook secret securely.

5.  Select **Done**.

    Your webhook endpoint is now configured.

6.  To ensure your webhook is configured correctly and can receive events from Tailscale, [test your webhook](#testing-your-webhook).


## [Events](#events)

You can subscribe to the following events:

Category

Event

Description

Device misconfiguration

`exitNodeIPForwardingNotEnabled`

[Exit node](https://tailscale.com/kb/1103/exit-nodes) has [IP forwarding](https://tailscale.com/kb/1103/exit-nodes?tab=linux#advertise-a-device-as-an-exit-node) disabled.

Device misconfiguration

`subnetIPForwardingNotEnabled`

[Subnet](https://tailscale.com/kb/1019/subnets) has [IP forwarding](https://tailscale.com/kb/1019/subnets?tab=linux#enable-ip-forwarding) disabled.

Tailnet management

`nodeApproved`

Node was approved.

Tailnet management

`nodeAuthorized` (deprecated)

Node was authorized. This event is deprecated and is replaced by `nodeApproved`. Your endpoint will continue to receive this event until you turn it off.

Tailnet management

`nodeCreated`

Node was created.

Tailnet management

`nodeDeleted`

Node was deleted. This includes automatic deletion of [ephemeral nodes](https://tailscale.com/kb/1111/ephemeral-nodes).

Tailnet management

`nodeKeyExpired`

Node key recently expired.

Tailnet management

`nodeKeyExpiringInOneDay`

[Node key](https://tailscale.com/blog/tailscale-key-management#node-keys) is going to expire in less than one day.

Tailnet management

`nodeNeedsApproval`

Node needs [approval](https://tailscale.com/kb/1099/device-approval). Note that any [pre-approved nodes](https://tailscale.com/kb/1099/device-approval#pre-approve-devices-with-an-auth-key) will not generate the `nodeApproved` event.

Tailnet management

`nodeNeedsAuthorization` (deprecated)

Node needs authorization. This event is deprecated and is replaced by `nodeNeedsApproval`. Your endpoint will continue to receive this event until you turn it off.

Tailnet management

`nodeNeedsSignature`

Node needs a signature from a trusted node. This event is only sent for nodes that belong to tailnets that enabled [Tailnet Lock](https://tailscale.com/kb/1226/tailnet-lock), and will not be sent for shared nodes.

Tailnet management

`nodeSigned`

Node was signed by a trusted node. This applies to tailnets that enabled Tailnet Lock.

Tailnet management

`policyUpdate`

[Tailnet policy file](https://tailscale.com/kb/1395/tailnet-policy-file) updated.

Tailnet management

`userApproved`

User was approved.

Tailnet management

`userCreated`

User was created.

Tailnet management

`userNeedsApproval`

User needs [approval](https://tailscale.com/kb/1239/user-approval).

Tailnet management

`userRoleUpdated`

User role was [changed](https://tailscale.com/kb/1171/changing-user-roles).

Webhook management

`test`

Webhook test event was generated.

Webhook management

`webhookDeleted`

Webhook was deleted.

Webhook management

`webhookUpdated`

Webhook was updated.

## [Events payload](#events-payload)

Webhook events are sent as JSON objects with the following fields:

-   `timestamp`: Time the event occurred, formatted as a RFC 3339 string.
-   `version`: Version of the event payload.
-   `type`: Type of the event (as listed in the table above).
-   `tailnet`: Name of the tailnet where the event occurred.
-   `message`: Human-readable summary of the event.
-   `data` (Optional): Per-event payload with additional data. Most events will have an `actor` field that identifies the user or automated process that did the action that triggered the event. It is the same actor that is included in [configuration audit log entries](https://tailscale.com/kb/1203/audit-logging#log-structure).

Multiple events may be sent in one payload to minimize overhead. The root payload object is always an array of events.

The following shows an example events payload sent to a webhook endpoint:

```json
[
    {
        "timestamp": "2022-09-21T13:37:51.658918-04:00",
        "version": 1,
        "type": "test",
        "tailnet": "example.com",
        "message": "This is a test event",
        "data": null
    },
    {
        "timestamp": "2022-09-21T13:59:02.949217-04:00",
        "version": 1,
        "type": "nodeCreated",
        "tailnet": "example.com",
        "message": "Node alice-workstation1.yak-bebop.ts.net created",
        "data": {
            "nodeID": "nFJw3SRKTM59",
            "deviceName": "alice-workstation1.yak-bebop.ts.net",
            "managedBy": "alice@example.com",
            "actor": "alice@example.com",
            "url": "https://login.tailscale.com/admin/machines/100.12.345.67"
        }
    },
    {
        "timestamp": "2022-09-21T13:59:02.949278-04:00",
        "version": 1,
        "type": "nodeNeedsApproval",
        "tailnet": "example.com",
        "message": "Node alice-workstation1.yak-bebop.ts.net needs approval",
        "data": {
            "nodeID": "nFJw3SRKTM59",
            "deviceName": "alice-workstation1.yak-bebop.ts.net",
            "managedBy": "alice@example.com",
            "actor": "alice@example.com",
            "url": "https://login.tailscale.com/admin/machines/100.12.345.67"
        }
    },
    {
        "timestamp": "2022-09-21T13:59:15.966728-04:00",
        "version": 1,
        "type": "nodeApproved",
        "tailnet": "example.com",
        "message": "Node alice-workstation1.yak-bebop.ts.net approved",
        "data": {
            "nodeID": "nFJw3SRKTM59",
            "deviceName": "alice-workstation1.yak-bebop.ts.net",
            "managedBy": "alice@example.com",
            "actor": "admin@example.com",
            "url": "https://login.tailscale.com/admin/machines/100.12.345.67"
        }
    },
    {
        "timestamp": "2023-04-21T13:59:15.966728-04:00",
        "version": 1,
        "type": "nodeDeleted",
        "tailnet": "example.com",
        "message": "Node alice-workstation1.yak-bebop.ts.net deleted",
        "data": {
            "nodeID": "nFJw3SRKTM59",
            "deviceName": "alice-workstation1.yak-bebop.ts.net",
            "managedBy": "alice@example.com",
            "actor": "admin@example.com",
            "url": "https://login.tailscale.com/admin/machines/100.12.345.67"
        }
    },
    {
        "timestamp": "2022-09-27T09:51:46.512946-07:00",
        "version": 1,
        "type": "policyUpdate",
        "tailnet": "example.com",
        "message": "Tailnet policy file updated",
        "data": {
            "newPolicy": "{\n\t\"acls\": [\n\t\t{\"action\": \"accept\", \"src\": [\"autogroup:member\"], \"dst\": [\"*:*\"]},\n\t],\n}",
            "oldPolicy": "{\n\t\"acls\": [\n\t\t{\"action\": \"accept\", \"src\": [\"*\"], \"dst\": [\"*:*\"]},\n\t],\n}",
            "url": "https://login.tailscale.com/admin/acls",
            "actor": "admin@example.com"
        }
    },
    {
        "timestamp": "2022-11-08T10:26:08.775392-08:00",
        "version": 1,
        "type": "nodeKeyExpiringInOneDay",
        "tailnet": "example.com",
        "message": "Node alice-workstation1.yak-bebop.ts.net key expiring in less than one day",
        "data": {
            "nodeID": "nFJw3SRKTM59",
            "url": "https://login.tailscale.com/admin/machines/100.12.345.67",
            "deviceName": "alice-workstation1.yak-bebop.ts.net",
            "managedBy": "alice@example.com",
            "actor": "expiring-node-key-marker",
            "expiration": "2022-11-08T18:44:46.979292Z"
        }
    },
    {
        "timestamp": "2022-11-08T10:45:08.775392-08:00",
        "version": 1,
        "type": "nodeKeyExpired",
        "tailnet": "example.com",
        "message": "Node alice-workstation1.yak-bebop.ts.net key recently expired",
        "data": {
            "nodeID": "nFJw3SRKTM59",
            "url": "https://login.tailscale.com/admin/machines/100.12.345.67",
            "deviceName": "alice-workstation1.yak-bebop.ts.net",
            "managedBy": "alice@example.com",
            "actor": "expiring-node-key-marker",
            "expiration": "2022-11-08T18:44:46.979292Z"
        }
    },
    {
        "timestamp": "2023-02-27T11:49:25.208092-08:00",
        "version": 1,
        "type": "userRoleUpdated",
        "tailnet": "example.com",
        "message": "User alice@example.com role changed",
        "data": {
            "user": "alice@example.com",
            "url": "https://login.tailscale.com/admin/users?q=alice%40example.com",
            "actor": "admin@example.com",
            "oldRoles": ["Member"],
            "newRoles": ["Member", "IT admin"]
        }
    }
]
```

## [Testing your webhook](#testing-your-webhook)

To ensure an endpoint is properly configured and able to receive events from Tailscale, you can send a test event:

1.  Open the [Webhooks](https://login.tailscale.com/admin/settings/webhooks) page of the admin console.

2.  Find the endpoint that you want to test, select the ![ellipsis icon](/files/images/icons/fa-ellipsis-h.svg) menu to the right of the page, and select **Test endpoint**.

3.  Select **Send test event**. If your webhook is configured correctly, within a few seconds your webhook endpoint should receive an event with type of "test".


## [Retries for events that fail to send](#retries-for-events-that-fail-to-send)

Tailscale typically sends an event notification to a webhook within a few seconds of the event's occurrence. If an event notification fails to successfully send (such as when Tailscale receives a `3xx`, `4xx`, or `5xx` error, or no response at all from your webhook endpoint), Tailscale will retry sending the event. For an event that fails to send, we'll retry sending the event hourly, up to a maximum of 24 hours.

## [Updating subscribed events](#updating-subscribed-events)

1.  Open the [Webhooks](https://login.tailscale.com/admin/settings/webhooks) page of the admin console.

2.  Find the endpoint that you want to update, select the ![ellipsis icon](/files/images/icons/fa-ellipsis-h.svg) menu to the right of the page, and select **Edit**.

3.  Select the events you want to receive as notifications, and deselect those you don't want to receive.

4.  Select **Edit endpoint**.


## [Webhook secret](#webhook-secret)

The webhook secret is a signing secret shared between Tailscale and the creator of the webhook endpoint, and is unique per endpoint. If this shared secret is compromised or leaked, whomever knows the secret can send fake events. If you suspect your secret is compromised, [create a new secret](https://tailscale.com/kb/1585/create-rotate-secret).

The webhook secret has no expiry.

## [Rotating a webhook secret](#rotating-a-webhook-secret)

Refer to [rotate a new webhook secret](https://tailscale.com/kb/1585/create-rotate-secret) to create a new webhook secret. After you create the new secret, update your webhook endpoint to use the new secret.

## [Deleting an endpoint](#deleting-an-endpoint)

1.  Open the [Webhooks](https://login.tailscale.com/admin/settings/webhooks) page of the admin console.

2.  Find the endpoint that you want to delete, select the ![ellipsis icon](/files/images/icons/fa-ellipsis-h.svg) menu to the right of the page, and select **Delete**.

3.  Select **Delete endpoint** to confirm you want to delete the endpoint.


## [Using a new webhook for an existing endpoint](#using-a-new-webhook-for-an-existing-endpoint)

To add a new webhook (subscribed event) for an existing endpoint, [edit the endpoint](#updating-subscribed-events) instead of setting up a new endpoint.

## [Audit logging of webhook actions](#audit-logging-of-webhook-actions)

In [configuration audit logging](https://tailscale.com/kb/1203/audit-logging), an action will be recorded in your audit log whenever a webhook is created, deleted, or updated. The log entry will show who performed the action, and when the action occurred.

## [Verifying an event signature](#verifying-an-event-signature)

You can verify whether an event was signed by the [webhook secret](#webhook-secret) that was shared between you and Tailscale. Note this doesn't necessarily mean that an event was sent from Tailscale. Rather, it means an event was sent from an entity that has knowledge of the secret shared between you and Tailscale.

A event sent from Tailscale contains a `Tailscale-Webhook-Signature` header. The `Tailscale-Webhook-Signature` header includes a timestamp and a signature:

```markup
Tailscale-Webhook-Signature:t=1663781880,v1=0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef
```

The timestamp, prefixed by `t=`, is the epoch time in seconds when the event occurred. The signature, prefixed by `v1=`, is a hash-based message authentication code (HMAC) using SHA-256. The only supported scheme for the signature is `v1`.

Most modern programming languages provide libraries for computing and comparing HMACs. The following flow describes how to verify a signature.

1.  Parse the event timestamp and signature from the `Tailscale-Webhook-Signature` header.

    Using the `,` character as the separator, split the `Tailscale-Webhook-Signature` data into a list of elements. Then, using the `=` character, split each element to get two key-value pairs. The first key is `t`, with the event timestamp as its value. The second key is `v1`, with the event signature as its value.

2.  Compare the event timestamp (the value for `t`) with the current time. For example, if your verification process acts on events as soon as they are received, and if the event time is more than 5 minutes prior to the current time, you might consider the event as a replay attack.

3.  Create a string, `string_to_sign`, to sign by concatenating:

    -   The timestamp (the value of `t`) represented as a string.
    -   The `.` character.
    -   The decoded event request body. Note this is in the request itself, not in the `Tailscale-Webhook-Signature` header. The request body contains the encoded [events payload](#events-payload), you need to decode the request body for signing purposes.
4.  Compute the signature of `string_to_sign`.

    Create an HMAC with the SHA256 hash function. Use your webhook secret for the signing key, and use `string_to_sign` as the message to sign.

5.  Use an HMAC compare function to compare the signature in the `Tailscale-Webhook-Signature` header (the value of `v1`) with the signature you created in the previous step. If they are not identical, that indicates the event's payload was not signed by your webhook's secret, and the event should not be considered an event sent from Tailscale.


### [Sample verification code](#sample-verification-code)

Check out our [example Go code](https://github.com/tailscale/tailscale/blob/main/docs/webhooks/example.go) for help verifying the signature.
```



### File: 1217-tailnet-name.md

```markdown
# Tailnet names and types

A Tailscale network (known as a tailnet) contains different types of names used to identify and connect everything within it. Each type of name serves a specific purpose, establishes the network's identity and namespace, device names identify individual nodes within it, MagicDNS names make those devices reachable, and access permissions and user identities define who or what can access specific resources.

There are three primary types of names:

-   **Tailnet DNS name**: The fully qualified domain (FQDN) that is used for name resolution throughout your tailnet.
-   **Machine name**: The name of a device or node in your tailnet.
-   **Tailnet ID**: The string used with the [Tailscale API](https://tailscale.com/kb/1101/api).

## [Tailnet DNS name](#tailnet-dns-name)

When you create a new tailnet, Tailscale assigns it a DNS name with the format `tail<ID>.ts.net`, where `<ID>` is a randomly generated hexadecimal string such as `tailnet-fe8c.ts.net`.

This serves several important purposes, including enabling [MagicDNS](https://tailscale.com/kb/1081/magicdns) to register DNS names for tailnet devices and serving as the fully qualified domain name for [HTTPS](https://tailscale.com/kb/1153/enabling-https) certificates. It's also used by the [sharing](https://tailscale.com/kb/1084/sharing) feature to uniquely identify shared tailnet devices. You can view your tailnet DNS name in the [DNS](https://login.tailscale.com/admin/dns) page of the admin console.

### [Generate a new tailnet DNS name](#generate-a-new-tailnet-dns-name)

You must be an [Owner, Admin, or Network admin](https://tailscale.com/kb/1138/user-roles) to generate and select a new tailnet DNS name.

If you want to use a tailnet DNS name that's more memorable than the generated hexadecimal string (`tail<ID>.ts.net`), you can generate and choose from a selection randomized name options. This can make it easier to remember or type your tailnet DNS name when using features like [MagicDNS](https://tailscale.com/kb/1081/magicdns). For example, `cat-crocodile.ts.net`. These options are randomly generated, and you can always revert this name back to the originally assigned hexadecimal string name.

After you use a randomized name for HTTPS certificates, you cannot re-generate it. However, you will be able to switch between the randomized name and the default name.

To generate a new name:

1.  Open the [DNS](https://login.tailscale.com/admin/dns) page of the admin console.
2.  Select **Rename tailnet**.
3.  Confirm that you want to used the randomized name.
4.  Select one of the randomly generated tailnet names. If you don't want any of the proposed names, you can select **Re-roll options** to generate more options.
5.  Select **Rename tailnet**.

When you select a random tailnet DNS name, it becomes your active tailnet name. If you previously used your default tailnet DNS name for [MagicDNS](https://tailscale.com/kb/1081/magicdns), [HTTPS certificates](https://tailscale.com/kb/1153/enabling-https), or [sharing](https://tailscale.com/kb/1084/sharing), existing links to devices in your tailnet might break. This also applies when you revert back to the originally assigned tailnet DNS name.

### [Revert to the original tailnet DNS name](#revert-to-the-original-tailnet-dns-name)

To revert back to the default tailnet DNS name:

1.  Open the [DNS](https://login.tailscale.com/admin/dns) page of the admin console.
2.  Select **Rename tailnet**.
3.  Confirm that you want to switch your tailnet name.
4.  Select the name that you want to use.
5.  Select **Rename tailnet**.

Because [MagicDNS](https://tailscale.com/kb/1081/magicdns), [HTTPS certificates](https://tailscale.com/kb/1153/enabling-https), and [sharing](https://tailscale.com/kb/1084/sharing) rely on the tailnet DNS name, switching your tailnet DNS name may break existing links to devices in your tailnet.

## [Machine names](#machine-names)

Machine names are unique to each device in your tailnet. They're generated from the device's hostname (from the operating system) when the device joins the tailnet, and you can change a devices machine name from the admin console or the Tailscale CLI. The list of machines in your tailnet is located in the [Machines](https://login.tailscale.com/admin/machines) page of the admin console.

## [Tailnet ID](#tailnet-id)

The Tailnet ID is a string assigned to a tailnet and used by the [Tailscale API](https://tailscale.com/kb/1101/api). It's located in the [General](https://login.tailscale.com/admin/settings/general) page of the admin console.

## [Display name](#display-name)

When you create a tailnet, it displays the private domain or public email address in the Tailscale authentication page, admin console page header, client UI, and the client CLI. For example, `example.com`, `example@gmail.com`, or `user.github`. Setting a custom display name gives your tailnet a recognizable name, making it easier for team members to identify which environment they are authenticating to, joining, or are currently using.

The display name can always be set and viewed of the admin console, and viewing it in the Tailscale client requires version 1.88 or later.

You must be an [Owner or Admin](https://tailscale.com/kb/1138/user-roles) to set or edit the tailnet display name.

1.  Open the [General](https://login.tailscale.com/admin/settings/general) page of the admin console.
2.  Enter the display name. Use letters, numbers, spaces, apostrophes, and hyphens.
3.  Select **Save**.

The display name will appear anywhere your tailnet domain or email address typically displays. Display names can be up to 65 characters and can contain letters, numbers, spaces, apostrophes, and hyphens. You may not use periods or underscores.

## [Legacy ID](#legacy-id)

In October 2025, this field was changed from **Organization** to **Legacy ID** and is only visible to existing tailnets prior to this field name change. Tailnets created after October 2025 will not display the **Legacy ID** field of the admin console.

If you previously used the **Organization** field for the [Tailscale API](https://tailscale.com/kb/1101/api), update your settings to use the **Tailnet ID** field instead.

The **Legacy ID** field is automatically assigned when creating a new tailnet and displays in the [General](https://login.tailscale.com/admin/settings/general) page of the admin console. If you used a custom domain, it displays as the domain name such as `example.com`. If it's an email using a public/shared domain, the email address displays such as `user@gmail.com`. This name displays in the admin console header, the tailnet login page, and in the Tailscale client and provides an indicator of the tailnet you are using. Once created, you cannot change this name.
```



### File: 1219-network-flow-logs.md

```markdown
# Network flow logs

Network flow logs let you understand how and when nodes on your Tailscale network (known as a tailnet) connect to each other. You can export network logs for long-term storage, security analysis, threat detection, or incident investigation. You can also [stream logs](https://tailscale.com/kb/1255/log-streaming) to a security information and event management ([SIEM](https://tailscale.com/learn/security-information-and-event-management)) system.

The data captured in network logs is the flow of network traffic, not the contents of network traffic. Tailscale does not and cannot inspect your traffic. For more information about how your data stays private, refer to our [Security page](https://tailscale.com/security).

Network flow logs are available for the most recent 30 days.

This feature is available for [the Premium and Enterprise plans](https://tailscale.com/pricing).

Only nodes using Tailscale v1.34 or later can send networking telemetry to the Tailscale logs service.

## [How it works](#how-it-works)

When network flow logs are enabled (and not using [`--no-logs-no-support`](https://tailscale.com/kb/1011/log-mesh-traffic#opting-out-of-client-logging)), nodes report their flow information (for both ends of the connection) to the Tailscale logs service. A connection can be between:

-   Two nodes
-   A node and a device behind a subnet router
-   A node and a public device accessed through an exit node

When the connection is between a node and a device behind a subnet router, the subnet router logs the connection. When the connection is between a node and a public device accessed through an exit node, the exit node logs the connection.

Logs occur between transferred and received network connections, and entries exist for both ends.

Logs occur at two layers: the virtual layer and the physical layer. The virtual layer is the Tailscale network (often with IP addresses in [`100.x.x.x`](https://tailscale.com/kb/1015/100.x-addresses)) that Tailscale provides for each device. The physical layer involves all the physical network interfaces on a device. When one node transmits a packet to another, the packet must cross through the physical layer. The summation of all traffic routed at the virtual layer is generally equal to the traffic routed at the physical layer.

Tailscale centrally stores network logs and lets you export them. Tailscale does not log the actual contents or data of the network traffic.

## [Network logs structure](#network-logs-structure)

Network logs contain an array of messages that provide details about network flow activity. Each message contains the following components:

-   **nodeId**: The node that generated this log message. It is a globally unique identifier of a node. It is not the same value as the node name. If you want to map `nodeId` to a node name, you can use the [`/api/v2/device/:nodeId`](https://tailscale.com/api#tag/devices/GET/tailnet/%7Btailnet%7D/devices) method and examine the `name` field.
-   **logged**: The time in UTC that the Tailscale logs service recorded the message. Generally, the logged time is after the end time within a message.
-   **start**: The start time in UTC for the network traffic flow data in the message, as recorded by the node that generated the message.
-   **end**: The end time in UTC for the network traffic flow data in the message, as recorded by the node that generated the message.
-   **virtualTraffic**: Counters for the network flow's virtual traffic. Virtual traffic is traffic that occurs between nodes in your tailnet.
-   **subnetTraffic**: Counters for the network flow's traffic routed through an advertised subnet router.
-   **exitTraffic**: Counters for the network flow's traffic routed through an exit node. For traffic from a node to a public device through an exit node, the source is the Tailscale IP address, but the protocol, source port, and destination are empty. For traffic responses from a public device to a node through an exit node, the destination is the Tailscale IP address, but the protocol, destination port, and source are empty. Tailscale doesn't gather granular information about individual connections to preserve privacy. If an administrator enables [Destination Logging](https://tailscale.com/kb/1103/exit-nodes), the protocol, source port, and destination information are logged.
-   **physicalTraffic**: Counters for the network flow's traffic on the physical network layer that operates below the virtual Tailscale network. Traffic information at the physical layer is gathered at a slightly different time than the virtual layer, so packets flowing through the virtual layer may not exactly line up with those at the physical layer.

Start and end times are specific to the node that generated the message. Timestamps may be subject to clock skew across different nodes.

The virtual, subnet, exit, and physical traffic counters consist of the following components:

-   **proto**: The [IANA Protocol Number](https://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml) for the network flow: 6 for TCP, 17 for UDP. Empty for exit traffic, unless [Destination Logging](https://tailscale.com/kb/1103/exit-nodes) is enabled.
-   **src**: The Tailscale IP address and port for the source of the network flow. The port number is not included for exit traffic, unless [Destination Logging](https://tailscale.com/kb/1103/exit-nodes) is enabled.
-   **dst**: The IP address and port for the destination of the network flow. This IP address can be either a Tailscale IP address or an external IP address, such as on a private network or a public IP. Empty for exit traffic, unless [Destination Logging](https://tailscale.com/kb/1103/exit-nodes) is enabled.
-   **txPackets**: Number of packets transmitted.
-   **txBytes**: Number of bytes transmitted.
-   **rxPackets**: Number of packets received.
-   **rxBytes**: Number of bytes received.

## [Enable network flow logs](#enable-network-flow-logs)

Network flow logs are disabled by default.

You must be an [Owner, Admin, Network admin, or IT admin](https://tailscale.com/kb/1138/user-roles) of a tailnet to enable Network flow logs.

1.  Open the [Network flow logs](https://login.tailscale.com/admin/logs/network) page of the admin console.
2.  Select **Start logging**.
3.  In the **Start logging network flows** dialog, select **Start logging**.

## [Disable network flow logs](#disable-network-flow-logs)

You must be an [Owner, Admin, Network admin, or IT admin](https://tailscale.com/kb/1138/user-roles) of a tailnet to disable Network flow logs.

1.  Open the [Network flow logs](https://login.tailscale.com/admin/logs/network) page of the admin console.
2.  Select **Stop logging**.
3.  In the **Stop logging network flows** dialog, select **Stop logging**.

## [Access network logs](#access-network-logs)

You must be an [Owner, Admin, Network admin, or IT admin](https://tailscale.com/kb/1138/user-roles) of a tailnet to access network logs.

You can access network logs using the Tailscale [API](https://tailscale.com/kb/1101/api) or [log streaming](#network-flow-logs-streaming).

### [Access network logs through the API](#access-network-logs-through-the-api)

You need an [API access token](https://tailscale.com/kb/1101/api#authentication) with the `logs:network:read` scope to access network logs.

The response from the `https://api.tailscale.com/api/v2/tailnet/{$TAILNET_ID}/logging/network` endpoint call is in the form of the `Response` struct:

```go
type Response struct {
  Logs []Message `json:"logs"`
}
```

Using Golang syntax, the `Response` struct contains a slice of `Message` types. The `Message` struct is defined as:

```go
type Message struct {
  // NodeID is the stable ID of the node that
  // generated this network log message.
  NodeID string `json:"nodeId"` // for example, "n123456CNTRL"

  // Logged is the timestamp of when the Tailscale logs service
  // recorded the network log message from a given node.
  // It is guaranteed to be within the start and end time ranges
  // specified in the API request.
  // All log messages are listed in chronological order
  // from oldest to newest.
  Logged time.Time `json:"logged"`

  // Start and End are the inclusive time ranges for the network
  // traffic flow information present in the message.
  // These timestamps are recorded by the node and subject
  // to clock skew across different nodes.
  // Generally speaking, the Logged timestamp is after End.
  //
  // Network logs are gathered in 5 second windows.
  // This may change in the future.
  Start time.Time `json:"start"`
  End time.Time `json:"end"`

  // VirtualTraffic records connection statistics for
  // node to node traffic.
  // Both the source and address are Tailscale IP addresses
  // (for example, 100.xx.xx.xx). The source is always the
  // Tailscale IP address of the current node.
  VirtualTraffic []ConnectionCounts `json:"virtualTraffic"`

  // SubnetTraffic records node to external traffic
  // on an explicitly advertised subnet route.
  //
  // For nodes using a subnet router,
  // the source is the Tailscale IP address of the current node and
  // the destination is the external IP address in the subnet range.
  // For nodes operating as the subnet router,
  // the destination is the Tailscale IP address of the node
  // using the subnet router and the source address
  // is the external IP address within the advertised subnet range.
  SubnetTraffic []ConnectionCounts `json:"subnetTraffic"`

  // ExitTraffic records aggregated statistics for all traffic
  // flowing through an exit node. For traffic from a node to a
  // public device through an exit node, the source will be the
  // Tailscale IP address, but the protocol, source port,
  // and destination will be empty. For traffic responses from a
  // public device to a node through an exit node, the destination
  // will be the Tailscale IP address, but the protocol,
  // destination port and source will be empty. Fine
  // granularity information about individual connections is not
  // gathered so that privacy can be preserved.
  ExitTraffic []ConnectionCounts `json:"exitTraffic"`

  // PhysicalTraffic records traffic on the physical network layer
  // that operates below the virtual Tailscale network.
  // The source is the Tailscale IP address of remote nodes
  // that the current node is communicating with and
  // the destination is the external IP address that traffic
  // is physically sent to to communicate with that
  // remote node.
  //
  // Traffic information at the physical layer is gathered
  // at a slightly different moment in time as the virtual layer,
  // so packets flowing through the virtual layer
  // may not exactly line up with those at the physical layer.
  PhysicalTraffic []ConnectionCounts `json:"physicalTraffic"`
}
```

Several fields in the `Message` struct use the type `ConnectionCounts`. The `ConnectionCounts` struct is defined as:

```go
type ConnectionCounts struct {
  Proto uint8  `json:"proto"` // for example, 6 for TCP, 17 for UDP
  Src   string `json:"src"`   // for example, "100.11.22.33:4567"
  Dst   string `json:"dst"`   // for example, "192.55.66.77:80"

  TxPackets uint64 `json:"txPkts"` // transferred packets
  TxBytes   uint64 `json:"txBytes"` // transferred bytes
  RxPackets uint64 `json:"rxPkts"` // received packets
  RxBytes   uint64 `json:"rxBytes"` // received bytes
}
```

The `Message.NodeID` field is verified by the Tailscale logs service as the actual node from which the message originated. The `Start`, `End`, `VirtualTraffic`, `SubnetTraffic`, `ExitTraffic`, and `PhysicalTraffic` fields are produced by individual nodes and recorded by the Tailscale logs service without validation. It is infeasible for Tailscale to verify the accuracy or truthfulness of this information. It is possible for malicious nodes to spoof this information.

When investigating network flow logs, you should identify a set of nodes that you consider more trustworthy (such as a server running in production) in contrast to those that might be more easily tampered with (such as an individual employee's work laptop). Discrepancies in network logs between the two might be indicative of malicious behavior.

You can use the following query parameters with the API:

-   `start`: Required. Start of the timeframe, in [RFC 3339](https://datatracker.ietf.org/doc/html/rfc3339) timestamp format, for the logs to retrieve. For example: `2022-07-20T00:00:00Z`.
-   `end`: Required. End of the timeframe, in RFC3339 timestamp format, for the logs to retrieve. If `end` is greater than the latest known timestamp in the log, the API call will not block the call. This means consecutive queries with the same `start` and `end` times range may return different log entries that were not available during the earlier query.

`start` and `end` times are inclusive within nanosecond resolution.

All log messages are listed in chronological order from oldest to newest.

There is no pagination support or maximum page size for the API. All known logged network activity in the specified timeframe is returned.

#### [Example API call](#example-api-call)

This example assumes you have set up the following variables to use for your API call:

-   `$ACCESS_TOKEN`: An [API access token](https://tailscale.com/kb/1101/api#authentication) to use when calling the Tailscale API. You can create an API access token in the [Keys](https://login.tailscale.com/admin/settings/keys) page of the admin console.
-   `$TAILNET_ID`: Your tailnet ID. You can find your tailnet ID in the [General](https://login.tailscale.com/admin/settings/general) page of the admin console.
-   `$START`: The start of the timeframe for the logs to retrieve.
-   `$END`: The end of the timeframe for the logs to retrieve.

```shell
export ACCESS_TOKEN=tskey-api-k123456CNTRL-0123456789abcdef
export TAILNET_ID=example.com
export START=2022-10-28T22:40:00.000000000Z
export END=2022-10-28T22:40:04.999999999Z
```

This example makes a call to the `https://api.tailscale.com/api/v2/tailnet/{$TAILNET_ID}/logging/network` endpoint.

```shell
curl -u $ACCESS_TOKEN: \
  "https://api.tailscale.com/api/v2/tailnet/{$TAILNET_ID}/logging/network?start={$START}&end={$END}"
```

(You can also copy the command above from the [Network flow logs](https://login.tailscale.com/admin/logs/network) page of the admin console.)

The following code block contains an example log output:

```json
{
  "logs": [
    {
      "nodeId": "aBcdef1CNTRL",
      "logged": "2022-10-28T22:40:00.290605382Z",
      "start": "2022-10-28T22:39:51.890385065Z",
      "end": "2022-10-28T22:39:56.886545512Z",
      "virtualTraffic": [
        {
          "proto": 6,
          "src": "100.111.22.33:21291",
          "dst": "100.111.44.55:63281",
          "txPkts": 2,
          "txBytes": 108,
          "rxPkts": 2,
          "rxBytes": 112
        },
        {
          "proto": 6,
          "src": "100.111.22.33:864",
          "dst": "100.44.55.66:2049",
          "txPkts": 6,
          "txBytes": 900,
          "rxPkts": 3,
          "rxBytes": 728
        },
        {
          "proto": 6,
          "src": "100.111.22.33:723",
          "dst": "100.99.88.77:2049",
          "txPkts": 4,
          "txBytes": 596,
          "rxPkts": 2,
          "rxBytes": 432
        },
        {
          "proto": 6,
          "src": "100.111.22.33:21291",
          "dst": "100.111.44.55:63280",
          "txPkts": 2,
          "txBytes": 108,
          "rxPkts": 2,
          "rxBytes": 112
        }
      ],
      "physicalTraffic": [
        {
          "src": "100.111.44.55:0",
          "dst": "192.55.66.77:41641",
          "txPkts": 4,
          "txBytes": 384,
          "rxPkts": 4,
          "rxBytes": 384
        },
        {
          "src": "100.44.55.66:0",
          "dst": "192.168.0.101:41641",
          "txPkts": 6,
          "txBytes": 1136,
          "rxPkts": 3,
          "rxBytes": 848
        },
        {
          "src": "100.99.88.77:0",
          "dst": "143.110.111.222:41641",
          "txPkts": 4,
          "txBytes": 752,
          "rxPkts": 2,
          "rxBytes": 512
        }
      ]
    },
    {
      "nodeId": "uvwXyz2CNTRL",
      "logged": "2022-10-28T22:40:00.344979725Z",
      "start": "2022-10-28T22:39:53.286643402Z",
      "end": "2022-10-28T22:39:58.286028244Z",
      "virtualTraffic": [
        {
          "proto": 6,
          "src": "100.44.55.66:49284",
          "dst": "100.99.88.77:22",
          "txPkts": 5,
          "txBytes": 440,
          "rxPkts": 10,
          "rxBytes": 1180
        },
        {
          "proto": 6,
          "src": "100.44.55.66:49282",
          "dst": "100.99.88.77:22",
          "txPkts": 5,
          "txBytes": 440,
          "rxPkts": 10,
          "rxBytes": 1180
        },
        {
          "proto": 6,
          "src": "100.44.55.66:49286",
          "dst": "100.99.88.77:22",
          "txPkts": 5,
          "txBytes": 440,
          "rxPkts": 9,
          "rxBytes": 968
        },
        {
          "proto": 6,
          "src": "100.44.55.66:49278",
          "dst": "100.99.88.77:22",
          "txPkts": 5,
          "txBytes": 440,
          "rxPkts": 10,
          "rxBytes": 1180
        },
        {
          "proto": 6,
          "src": "100.44.55.66:37500",
          "dst": "100.66.77.88:22",
          "txPkts": 46,
          "txBytes": 7416,
          "rxPkts": 68,
          "rxBytes": 12612
        },
        {
          "proto": 6,
          "src": "100.44.55.66:49288",
          "dst": "100.99.88.77:22",
          "txPkts": 64,
          "txBytes": 6236,
          "rxPkts": 104,
          "rxBytes": 10412
        },
        {
          "proto": 6,
          "src": "100.44.55.66:49280",
          "dst": "100.99.88.77:22",
          "txPkts": 5,
          "txBytes": 440,
          "rxPkts": 10,
          "rxBytes": 1180
        },
        {
          "proto": 6,
          "src": "100.44.55.66:2049",
          "dst": "100.111.22.33:864",
          "txPkts": 3,
          "txBytes": 728,
          "rxPkts": 6,
          "rxBytes": 900
        },
        {
          "proto": 1,
          "src": "100.44.55.66:0",
          "dst": "100.99.88.77:0",
          "txPkts": 5,
          "txBytes": 420,
          "rxPkts": 5,
          "rxBytes": 420
        }
      ],
      "physicalTraffic": [
        {
          "src": "100.33.444.55:0",
          "dst": "98.97.111.222:2705",
          "txPkts": 1,
          "txBytes": 32
        },
        {
          "src": "100.111.22.33:0",
          "dst": "192.168.0.102:41641",
          "txPkts": 3,
          "txBytes": 848,
          "rxPkts": 6,
          "rxBytes": 1136
        },
        {
          "src": "100.99.88.77:0",
          "dst": "143.110.111.222:41641",
          "txPkts": 94,
          "txBytes": 12672,
          "rxPkts": 158,
          "rxBytes": 23104
        },
        {
          "src": "100.66.77.88:0",
          "dst": "64.71.111.222:41641",
          "txPkts": 46,
          "txBytes": 9296,
          "rxPkts": 68,
          "rxBytes": 15392
        }
      ]
    }
  ]
}
```

You can use the Go binary [`netlogfmt`](https://pkg.go.dev/tailscale.com/cmd/netlogfmt) to make the output more readable:

```shell
curl -u $ACCESS_TOKEN: \
  "https://api.tailscale.com/api/v2/tailnet/{$TAILNET_ID}/logging/network?start={$START}&end={$END}" \
  | go run tailscale.com/cmd/netlogfmt@latest
```

The following code block contains an example log output:

```shell
===========================================================================================
NodeID: aBcdef1CNTRL
Logged: 2022-10-28 15:40:00.290
Window: 2022-10-28 15:39:51.890 (4.996s)
-----------------------------------------------------  Tx[P/s]   Tx[B/s]  Rx[P/s]   Rx[B/s]
VirtualTraffic:                                          2.80    342.66     1.80    277.01
    TCP:   100.111.22.33:864   -> 100.44.55.66:2049      1.20    180.14     0.60    145.71
    TCP:   100.111.22.33:723   -> 100.99.88.77:2049      0.80    119.29     0.40     86.47
    TCP:   100.111.22.33:21291 -> 100.111.44.55:63281    0.40     21.62     0.40     22.42
    TCP:   100.111.22.33:21291 -> 100.111.44.55:63280    0.40     21.62     0.40     22.42
PhysicalTraffic:                                         2.80    454.75     1.80    349.07
                 100.44.55.66  -> 192.168.0.101:41641    1.20    227.37     0.60    169.73
                 100.99.88.77  -> 143.111.222.333:41641  0.80    150.52     0.40    102.48
                 100.111.44.55 -> 192.55.66.77:41641     0.80     76.86     0.80     76.86
=============================================================================================
NodeID: uvwXyz2CNTRL
Logged: 2022-10-28 15:40:00.344
Window: 2022-10-28 15:39:53.286 (4.999s)
-------------------------------------------------------  Tx[P/s]   Tx[B/s]  Rx[P/s]   Rx[B/s]
VirtualTraffic:                                           28.60    3.32Ki    46.41    5.87Ki
    TCP:    100.44.55.66:37500 -> 100.103.145.6:22         9.20    1.45Ki    13.60    2.46Ki
    TCP:    100.44.55.66:49288 -> 100.99.88.77:22         12.80    1.22Ki    20.80    2.03Ki
    TCP:     100.44.55.66:2049 -> 100.111.22.33:864        0.60   145.62     1.20    180.02
    TCP:    100.44.55.66:49284 -> 100.99.88.77:22          1.00     88.01     2.00    236.03
    TCP:    100.44.55.66:49282 -> 100.99.88.77:22          1.00     88.01     2.00    236.03
    TCP:    100.44.55.66:49278 -> 100.99.88.77:22          1.00     88.01     2.00    236.03
    TCP:    100.44.55.66:49280 -> 100.99.88.77:22          1.00     88.01     2.00    236.03
    TCP:    100.44.55.66:49286 -> 100.99.88.77:22          1.00     88.01     1.80    193.62
    ICMPv4:       100.44.55.66 -> 100.99.88.77             1.00     84.01     1.00     84.01
PhysicalTraffic:                                          28.80    4.46Ki    46.41    7.74Ki
                 100.99.88.77  -> 143.111.222.333:41641   18.80    2.48Ki    31.60    4.51Ki
                 100.103.145.6 -> 64.71.162.170:41641      9.20    1.82Ki    13.60    3.01Ki
                 100.111.22.33 -> 192.168.0.102:41641      0.60    169.62     1.20    227.23
```

To make it easier to recognize nodes in the output, the `netlogfmt` binary provides flags that resolve IP addresses to readable hostnames:

-   `--resolve-names`: Convert tailscale IP addresses to hostnames. You must also specify `--api-key` and `--tailnet-name` as parameters to `netlogfmt` when you use the `--resolve-names` flag.
-   `--api-key`: Specifies the [API access token](https://tailscale.com/kb/1101/api#authentication) to use for the Tailscale API. This can be the same API access token you used for the `network-logs` endpoint or another valid API access token.
-   `--tailnet-name`: The same organization name you passed to the `network-logs` endpoint.

This example shows how to use the `netlogfmt` flags:

```shell
curl -u $ACCESS_TOKEN:  -X GET \
  "https://api.tailscale.com/api/v2/tailnet/{$TAILNET_ID}/logging/network?start={$START}&end={$END}" \
  | go run tailscale.com/cmd/netlogfmt@latest --resolve-names --api-key=$ACCESS_TOKEN --tailnet-name=$TAILNET
```

The following code block contains an example log output.

```shell
=======================================================================================
NodeID: aBcdef1CNTRL
Logged: 2022-10-28 15:40:00.290
Window: 2022-10-28 15:39:51.890 (4.996s)
-------------------------------------------------  Tx[P/s]   Tx[B/s]  Rx[P/s]   Rx[B/s]
VirtualTraffic:                                      2.80    342.66     1.80    277.01
    TCP:   carbonite:864 -> prism:2049               1.20    180.14     0.60    145.71
    TCP:   carbonite:723 -> diamond:2049             0.80    119.29     0.40     86.47
    TCP: carbonite:21291 -> glass:63281              0.40     21.62     0.40     22.42
    TCP: carbonite:21291 -> glass:63280              0.40     21.62     0.40     22.42
PhysicalTraffic:                                     2.80    454.75     1.80    349.07
                   prism -> 192.168.0.101:41641      1.20    227.37     0.60    169.73
                 diamond -> 143.110.111.222:41641    0.80    150.52     0.40    102.48
                   glass -> 192.55.66.77:41641       0.80     76.86     0.80     76.86
======================================================================================
NodeID: uvwXyz2CNTRL
Logged: 2022-10-28 15:40:00.344
Window: 2022-10-28 15:39:53.286 (4.999s)
------------------------------------------------  Tx[P/s]   Tx[B/s]  Rx[P/s]   Rx[B/s]
VirtualTraffic:                                    28.60    3.32Ki    46.41    5.87Ki
    TCP:    prism:37500 -> glass:22                 9.20    1.45Ki    13.60    2.46Ki
    TCP:    prism:49288 -> diamond:22              12.80    1.22Ki    20.80    2.03Ki
    TCP:     prism:2049 -> carbonite:864            0.60    145.62     1.20    180.02
    TCP:    prism:49284 -> diamond:22               1.00     88.01     2.00    236.03
    TCP:    prism:49282 -> diamond:22               1.00     88.01     2.00    236.03
    TCP:    prism:49278 -> diamond:22               1.00     88.01     2.00    236.03
    TCP:    prism:49280 -> diamond:22               1.00     88.01     2.00    236.03
    TCP:    prism:49286 -> diamond:22               1.00     88.01     1.80    193.62
    ICMPv4:       prism -> diamond                  1.00     84.01     1.00     84.01
PhysicalTraffic:                                   28.80    4.46Ki    46.41    7.74Ki
                diamond -> 143.110.111.222:41641   18.80    2.48Ki    31.60    4.51Ki
                  glass -> 64.71.111.222:41641      9.20    1.82Ki    13.60    3.01Ki
              carbonite -> 192.168.0.102:41641      0.60    169.62     1.20    227.23
```

## [Network flow logs streaming](#network-flow-logs-streaming)

Log streaming lets you stream network flow logs into a security information and event management ([SIEM](https://tailscale.com/learn/security-information-and-event-management)) system. For more information, refer to [Log streaming](https://tailscale.com/kb/1255/log-streaming).

## [Limitations](#limitations)

-   Only nodes using Tailscale v1.34 or later send networking telemetry to the Tailscale logs service.
-   You can only access network logs using the API and as a [streaming source](https://tailscale.com/kb/1255/log-streaming) for SIEM systems. There is no network logs viewing functionality in the Tailscale admin console.
-   Network flow logs are for logging, not monitoring. The admin console does not contain a live view of the connections between nodes. Additionally, network logs don't include information on whether a node is online or idle. The logs only indicate whether there was network traffic.
-   Network logs do not include individual packet transfers. Logs capture when connections are active, which could include multiple data flows.
-   Tailscale only logs successful connects. If a connection attempt results in denied access, the attempt isn't logged.
-   Traffic information at the physical layer is gathered at a slightly different time than the virtual layer, so packets flowing through the virtual layer might not precisely line up with those at the physical layer.
-   Public IP addresses are not logged as either a destination or source. That is, a connection from your tailnet through an exit node does not log where the traffic is going, and a connection from the public internet through an exit node does not log where the traffic is returning from. To preserve privacy, Tailscale doesn't gather detailed information about individual connections.
    -   If [Destination Logging](https://tailscale.com/kb/1103/exit-nodes) is enabled by the administrator, the protocol, source port, and destination information are logged.
-   The user authenticated on a source or destination host is not logged. To map a node to a user, you can use the [`/api/v2/tailnet/:tailnet/device`](https://tailscale.com/api#tag/devices/GET/tailnet/%7Btailnet%7D/devices) method and examine the `user` field.
-   Network logging is performed client-side. Tailscale cannot guarantee the delivery or integrity of the client logs. Tailscale cannot fully guarantee client log latency thresholds-that is, logs are not delivered in real-time.
-   Enabling network flow logs might result in a slight performance impact because the client does additional work to track necessary metrics. The incremental load is spread across the fleet, not concentrated on a single host.
```



### File: 1222-invite-only-feature.md

```markdown
# Invite only features

Invite only features require a user to be invited to use and accept an invitation for access to feature previews. Users can create invitation codes to share with other users.

## [How it works](#how-it-works)

Invite only features require an invitation code.

A user with an invite only feature code can decide whether they want to accept the invitation to add the feature to their own tailnet.

An invitation code can be redeemed up to some maximum allowed times and has no time expiration.

![Example of acceptance dialog for an invite only feature.](/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Finvite-only-dialog.ab3d7384.png&w=1080&q=75)

You need to be an [Owner, Admin, or IT admin](https://tailscale.com/kb/1138/user-roles) of a tailnet to create or accept an invitation code, join a waitlist for an invitation code, or copy an invitation code from the admin console.

## [Creating a feature invitation](#creating-a-feature-invitation)

You need to be an [Owner, Admin, or IT admin](https://tailscale.com/kb/1138/user-roles) of a tailnet to create a feature invitation.

1.  Open the [General](https://login.tailscale.com/admin/settings/general) settings page of the admin console.

2.  In the **Feature previews** section, locate the feature that you would like to invite others to access. Invite only features have the **Invite only** badge.

3.  Select the **Invite others** button, for example, **Invite others to use New Feature**.

4.  Select **Generate & copy invite link**.

    ![Example of generating an invite dialog.](/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fgenerate-invite-link.e7a9c64b.png&w=1080&q=75)

5.  Share the copied link with others.


If you need to copy the link again, return to the [General](https://login.tailscale.com/admin/settings/general) settings page of the admin console, select the **Invite others** button, and then select **Copy invite link**.

## [Accepting a feature invitation](#accepting-a-feature-invitation)

You need to be an [Owner, Admin, or IT admin](https://tailscale.com/kb/1138/user-roles) of a tailnet to accept a feature invitation.

1.  Open the invitation URL.
2.  Confirm that you want to accept the feature by selecting the **Join alpha** button.
3.  Depending on the feature, you may need to update your tailnet settings or take other steps to enable the feature. Take action if needed based on guidance provided when you accept the invitation.

## [Joining a feature invitation waitlist](#joining-a-feature-invitation-waitlist)

You need to be an [Owner, Admin, or IT admin](https://tailscale.com/kb/1138/user-roles) of a tailnet to join an invitation waitlist.

1.  Open the [General](https://login.tailscale.com/admin/settings/general) settings page of the admin console.
2.  In the **Feature previews** section, locate the feature for which you would like to have access. Invite only features have the **Invite only** badge.
3.  Select the **Join waitlist** button.

If the feature has an available opening, Tailscale will automatically grant you access to the feature. Otherwise, Tailscale adds you to the feature's waitlist-you will receive an email when your access is granted.
```



### File: 1223-funnel.md

```markdown
# Tailscale Funnel

Tailscale Funnel is currently [in beta](https://tailscale.com/kb/1167/release-stages#beta). To try it, follow the steps below to enable it for your network using Tailscale v1.38.3 or later.

Tailscale Funnel is available for [the Personal, Personal Plus, Premium, and Enterprise plans](https://tailscale.com/pricing).

Tailscale Funnel lets you route traffic from the broader internet to a local service running on a device in your Tailscale network (known as a tailnet). You can use it to share a local service, like a web app, for anyone to access-even if they don't use Tailscale.

If you'd like to share local services only with other devices in your tailnet, use [Tailscale Serve](https://tailscale.com/kb/1312/serve) instead. Also check out [Funnel vs. sharing](https://tailscale.com/kb/1464/funnel-vs-sharing).

Explore the following to learn more about Funnel:

-   [Get started with Funnel](#get-started-with-funnel)
-   [How Funnel works](#how-funnel-works)
-   [The `tailscale funnel` command](https://tailscale.com/kb/1311/tailscale-funnel)
-   [Troubleshoot Funnel](#troubleshoot-funnel)
-   [Funnel examples](https://tailscale.com/kb/1247/funnel-examples)

## [How Funnel works](#how-funnel-works)

Funnel exposes a local resource to the internet through a unique Funnel URL. Using Funnel to share a local resource creates an encrypted tunnel from the internet to a specific resource on your device. Tailscale does this using a TCP proxy and Funnel relay servers.

![Diagram showing how Tailscale Funnel works](/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Ffunnel-diagram.2f3f0e10.png&w=3840&q=75)

When you share a local resource with Funnel, it creates a unique Funnel URL that you can share. When someone uses your Funnel URL, their device sends a request to the Funnel relay server. After receiving the request, the Funnel relay server will establish a TCP proxy to your device using Tailscale. This proxy is an encrypted tunnel between the local resource and the device accessing the Funnel URL that points to it. Using a TCP proxy protects the shared data and lets Tailscale hide the IP address of your local device. The Funnel relay server cannot decrypt data sent over this proxy.


Learn more

The process, from creating a Funnel to accessing a resource shared through it, involves:

-   [Creating and sharing the Funnel URL](#creating-and-sharing-the-funnel-url).
-   [Resolving the Funnel URL to an IP address](#resolving-the-funnel-url-to-an-ip-address).
-   [Establishing an encrypted proxy](#establishing-an-encrypted-proxy).
-   [Serving the shared resource through the proxy](#serving-the-shared-resource-through-the-proxy).

### [Creating and sharing the Funnel URL](#creating-and-sharing-the-funnel-url)

When you share a local resource with Funnel, it creates a unique Funnel URL that you can share. The generated URL points only to the specific resource you used Funnel to share. So, if you share a local web server, the Funnel only shares that specific web server. Likewise, if you share a file or directory, the Funnel only shares the specific file or directory.

### [Resolving the Funnel URL to an IP address](#resolving-the-funnel-url-to-an-ip-address)

When a device tries to access a Funnel URL, it first contacts public DNS servers to resolve the URL to an IP address. These DNS servers respond with the IP address of a Funnel relay server, not your device's IP address. This step hides your device's location from the public internet. After resolving the URL to an IP address, the device sends a request to the Funnel relay server.

### [Establishing an encrypted proxy](#establishing-an-encrypted-proxy)

After receiving the request, the Funnel relay server creates a TCP proxy to your device over Tailscale. This proxy acts as an encrypted relay between the Funnel relay server and your device. It ensures that your device's IP address is never exposed to the internet.

Funnel relay servers do not decrypt the traffic between public devices and your device. This ensures that Tailscale cannot access or read any content. It maintains end-to-end [encryption](https://tailscale.com/kb/1504/encryption) and privacy.

The Tailscale server running on your device receives the encrypted request from the TCP proxy. It then terminates the [TLS](https://en.wikipedia.org/wiki/Transport_Layer_Security) connection and passes the decrypted request to the local service you exposed through Funnel. The local service processes the request and generates a response.

### [Serving the shared resource through the proxy](#serving-the-shared-resource-through-the-proxy)

After the local server on your device processes the request, it sends the response to the Tailscale server on your device. The Tailscale server then encrypts the response and sends it back to the Funnel relay server over the established TCP proxy.

Upon receiving the encrypted response, the Funnel relay server forwards it to the user's device. It does not decrypt its contents; it maintains the end-to-end encryption of the data. Finally, the user's device ends the TLS connection. It then decrypts the response and shows the requested information to the user accessing the Funnel URL.

## [Get started with Funnel](#get-started-with-funnel)

Tailscale Funnel is disabled by default, but you can use the [Tailscale CLI](https://tailscale.com/kb/1080/cli) to enable the Funnel service and create Funnels.

### [Requirements and limitations](#requirements-and-limitations)

Funnel requires the following to work:

-   Tailscale v1.38.3 or later.
-   [MagicDNS](https://tailscale.com/kb/1081/magicdns) enabled for your tailnet.
-   [HTTPS](https://tailscale.com/kb/1153/enabling-https) enabled and valid HTTPS certificates for your tailnet.
-   A funnel [node attribute](https://tailscale.com/kb/1337/policy-syntax#node-attributes) in your tailnet policy file. This attribute tells Tailscale which tailnet users can use Funnel.

Additionally, Funnel has the following limitations:

-   Funnel can only use DNS names in your [tailnet's domain](https://tailscale.com/kb/1217/tailnet-name) (`tailnet-name.ts.net`).
-   Funnel can only listen on ports `443`, `8443`, and `10000`.
-   Funnel only works over [TLS](https://en.wikipedia.org/wiki/Transport_Layer_Security)\-encrypted connections.
-   Traffic sent over a Funnel is subject to non-configurable bandwidth limits.
-   Funnel only works on platforms that can run the Tailscale CLI.
-   To use Funnel on macOS, you must use one of the [open source variants of the Tailscale application for macOS](https://tailscale.com/kb/1065/macos-variants).

When you enable Funnel using the Tailscale CLI, Tailscale automatically creates valid HTTPS certificates and updates your tailnet policy file. By default, it lets any users in the `autogroup:members` [autogroup](https://tailscale.com/kb/1337/policy-syntax#autogroups) to use Funnel. You can adjust this by manually updating your tailnet policy file.

It is possible to frequently request a new certificate and exceed Let's Encrypt's rate limits. As a result, you may find yourself waiting 34 hours until you can try again. For more information, refer to Let's Encrypt's [rate limits documentation](https://letsencrypt.org/docs/rate-limits/).

### [Enable Funnel](#enable-funnel)

Use the [`tailscale funnel`](https://tailscale.com/kb/1311/tailscale-funnel) command to enable Funnel. The command triggers a web interface that prompts you to approve enabling Funnel. After you approve it, Tailscale will create valid HTTPS certificates for your tailnet and add a funnel node attribute to your tailnet policy file.

### [Create a Funnel](#create-a-funnel)

To create a Funnel, use the `tailscale funnel` command and pass the target you want to share. You can share a service, a file, or a directory. You can also optionally pass any of the [available flags](https://tailscale.com/kb/1311/tailscale-funnel#funnel-command-flags).

```shell
tailscale funnel 3000
Available on the internet:
https://amelie-workstation.pango-lin.ts.net

|-- / proxy http://127.0.0.1:3000

Press Ctrl+C to exit.
```

When you use Tailscale Funnel, the Funnel relay servers show up in your device's list of Tailscale peers. All peers using the command [`tailscale status --json`](https://tailscale.com/kb/1080/cli#status) display.

Sharing files and directories with Funnel only works with the [open source variants](https://tailscale.com/kb/1065/macos-variants) of the Tailscale client for macOS. Other variants have sandbox limitations.

You can only use Funnel to share ports if you installed Tailscale for macOS from the App Store or as a Standalone variant system extension.

### [Next steps](#next-steps)

-   Explore the collection of [Funnel use case examples](https://tailscale.com/kb/1247/funnel-examples) for inspiration and ideas.
-   [Use the TCP forwarder](https://tailscale.com/kb/1311/funnel-cli#use-a-tcp-forwarder).
-   [Reset the Funnel configuration](https://tailscale.com/kb/1311/funnel-cli#reset-tailscale-funnel).
-   [Disable Funnel](https://tailscale.com/kb/1311/funnel-clil#disable-tailscale-funnel).

## [Troubleshoot Funnel](#troubleshoot-funnel)

Trouble with Funnels is usually related to one of the following issues:

-   [Funnel node attribute](#funnel-node-attribute)
-   [HTTPS certificates](#https-certificates)
-   [Access controls](#access-controls)
-   [DNS propagation](#dns-propagation)

### [Funnel node attribute](#funnel-node-attribute)

Tailscale Funnel requires a [node attribute](https://tailscale.com/kb/1337/policy-syntax#node-attributes) (`nodeAttrs`) of `funnel` in your tailnet policy file to tell Tailscale who can use Funnel. If you use the Tailscale CLI to enable Funnel, Tailscale ensures this requirement is met. Alternatively, you can manually add the node attribute for Funnel. You need to be an [Owner, Admin, or Network admin](https://tailscale.com/kb/1138/user-roles) of a tailnet to modify a tailnet policy file.

1.  Open the [Access controls](https://login.tailscale.com/admin/acls) page of the admin console.
2.  Expand the Funnel section and select **Add Funnel to policy**.

This adds the default `nodeAttrs` section and saves the tailnet policy file automatically.

```json
"nodeAttrs": [
    {
        "target": ["autogroup:member"],
        "attr":   ["funnel"],
    },
],
```

You can use the [visual policy editor](https://tailscale.com/kb/1550/visual-editor) to manage your tailnet policy file. Refer to the [visual editor reference](https://tailscale.com/kb/1587/visual-editor-reference) for guidance on using the visual editor.

### [HTTPS certificates](#https-certificates)

Tailscale Funnel requires valid [HTTPS certificates](https://tailscale.com/kb/1153/enabling-https) for your tailnet to automatically provision TLS certificates for your unique tailnet DNS name. If you use the Tailscale CLI to enable Funnel, Tailscale ensures this requirement is met.

### [Access controls](#access-controls)

If the funnel node attribute in your tailnet policy file doesn't permit you to use Funnel, you won't be able to. The default node attribute to enable Funnel includes all tailnet members by default, but [Owners, Admins, and Network admins](https://tailscale.com/kb/1138/user-roles) can modify this to further restrict access.

### [DNS propagation](#dns-propagation)

Public DNS records can take up to 10 minutes to show up for your tailnet domain. This delay might prevent someone from using a Funnel URL until the public DNS records are updated.
```



### File: 1224-contact-preferences.md

```markdown
# Contact preferences

When issues that affect your tailnet are discovered, and we have your contact information, we will contact you. For example, if a security issue affects your tailnet and we have a security contact email for you, we will send you an email.

You can add, view, and update your account changes, configuration issues, and security issues contacts in the [Contact preferences](https://login.tailscale.com/admin/settings/contact-preferences) page of the admin console, if you have a [user role](https://tailscale.com/kb/1138/user-roles) that is permitted access. For information about updating your billing contact, see [Billing email](https://tailscale.com/kb/1182/billing-information#billing-email).

The account changes, configuration issues, security issues, and billing emails cannot be disabled or unsubscribed from. They are for notifications about transactional events-they are not marketing emails.

If you are using GitHub as your identity provider, we have no contact email information unless you add an email address to your contact preferences.

## [Types of contact emails](#types-of-contact-emails)

The types of contact emails are for account changes, configuration issues, security issues, and billing. A billing email is not enabled unless you're on a [paid Tailscale plan](https://tailscale.com/pricing).

If no email is set for a contact type, Tailscale uses the default behavior, which is to send emails to the tailnet owner email address.

### [Account changes email](#account-changes-email)

The account changes email is used for notifications about changes to your account. For example, approvals for access to new features requests, or changes to rate limits.

### [Configuration issues email](#configuration-issues-email)

The configuration issues email is used for notifications if there is an issue with your tailnet configuration. For example, you have a [tailnet policy file](https://tailscale.com/kb/1018/acls) misconfiguration.

### [Security issues email](#security-issues-email)

The security issues email is used for notifications about security issues affecting your tailnet. For example, if we need to email a [security bulletin](https://tailscale.com/security-bulletins) for an issue that affects you.

### [Billing email](#billing-email)

The billing email is used by Stripe to send you invoices and other billing-related email. If you are not paying for a [paid Tailscale plan](https://tailscale.com/pricing), a billing email does not exist for your tailnet.

## [Setting the account changes email](#setting-the-account-changes-email)

You need to be an [Owner, Admin, or IT admin](https://tailscale.com/kb/1138/user-roles) of a tailnet to update the account email.

1.  Open the [Contact preferences](https://login.tailscale.com/admin/settings/contact-preferences) page in the admin console.

2.  In the **Account changes** text box, enter an email address.

3.  Select **Save**.

    A verification URL will be emailed to the new email address.

4.  Follow the verification URL to confirm the email address. If the email address is not verified, Tailscale sends any new account changes emails to the last verified account email (or the tailnet owner email if there is no previously verified account changes email).


Once the email address is verified, future account changes emails will be sent to the email address that you provided.

## [Setting the configuration issues email](#setting-the-configuration-issues-email)

You need to be an [Owner, Admin, or IT admin](https://tailscale.com/kb/1138/user-roles) of a tailnet to update the support email.

1.  Open the [Contact preferences](https://login.tailscale.com/admin/settings/contact-preferences) page in the admin console.

2.  In the **Configuration issues** text box, enter an email address.

3.  Select **Save**.

    A verification URL will be emailed to the new email address.

4.  Follow the verification URL to confirm the email address. If the email address is not verified, Tailscale sends any new configuration issues emails to the last verified configuration issues email (or the tailnet owner email if there is no previously verified configuration issues email).


Once the email address is verified, future support issue emails will be sent to the email address that you provided.

## [Setting the security issues email](#setting-the-security-issues-email)

You need to be an [Owner or Admin](https://tailscale.com/kb/1138/user-roles) of a tailnet to update the security email.

1.  Open the [Contact preferences](https://login.tailscale.com/admin/settings/contact-preferences) page in the admin console.

2.  In the **Security issues** text box, enter an email address.

3.  Select **Save**.

    A verification URL will be emailed to the new email address.

4.  Follow the verification URL to confirm the email address. If the email address is not verified, Tailscale sends any new security issue emails to the last verified security issues email (or the tailnet owner email if there is no previously verified security issues email).


Once the email address is verified, future security issue emails will be sent to the email address that you provided.

## [Setting the billing email](#setting-the-billing-email)

For information about updating your billing contact preference, see [Billing email](https://tailscale.com/kb/1182/billing-information#billing-email).

## [Audit logging of contact preference updates and verification](#audit-logging-of-contact-preference-updates-and-verification)

In [configuration audit logging](https://tailscale.com/kb/1203/audit-logging), an action will be recorded in your audit log whenever a contact preference is updated and whenever a contact preference is verified. The log entry will show who performed the action and when the action occurred. For a contact preference update, the log entry will also show both the new value and old value for the email address.

## [Limitations](#limitations)

-   While the account changes, configuration issues, security issues, and billing contacts can differ, each of them can have only one email. If you want multiple users to be notified, consider using an email group. For example, use `security@example.com`, instead of `alice@example.com`, for security issue notifications.
-   The account changes, configuration issues, and security issues emails cannot be disabled or unsubscribed from. Since these are transactional emails, they will always be sent, even if you have unsubscribed from marketing emails. Similarly, if you are paying by invoice, you cannot disable or unsubscribe from billing notifications.
```



### File: 1226-tailnet-lock.md

```markdown
# Tailnet Lock

Tailnet Lock lets you verify that no node joins your Tailscale network (known as a tailnet) unless trusted nodes in your tailnet sign the new node. With Tailnet Lock enabled, even if Tailscale were malicious or Tailscale infrastructure hacked, attackers can't send or receive traffic in your tailnet.

Tailnet Lock is available for [the Personal, Personal Plus, and Enterprise plans](https://tailscale.com/pricing).

## [What is Tailnet Lock?](#what-is-tailnet-lock)

Tailnet Lock lets trusted nodes in your tailnet sign and verify other nodes, meaning you don't need to trust the Tailscale [coordination server](https://tailscale.com/kb/1508/control-data-planes#coordination-server) for distributing public [node keys](https://tailscale.com/blog/tailscale-key-management#node-keys) to peer nodes in your tailnet. You can control which nodes are trustworthy to sign another node's public key.

Tailscale's [control plane](https://tailscale.com/kb/1508/control-data-planes#control-plane) has the ability to add to and remove nodes from a tailnet. Inherently, customers must trust Tailscale's control plane to make the right decisions about who and what can join any given tailnet. Customers sometimes consider this a vector for abuse or security threats. Tailnet Lock largely mitigates the risk of Tailscale suddenly acting like a threat vector, by enforcing that the customer must use a trusted node to sign new additions to the tailnet. Tailnet Lock follows a "Trust on first use (TOFU)" model, where customers must initially trust Tailscale's control plane, but after first use, the customer can move centers of trust into their network.

Customers could alternatively host their own trusted control plane by using [Headscale](https://headscale.net). This is however a path that removes the availability guarantees and low maintenance overhead that Tailscale's software as a service (SaaS) model provides. Customers who want to keep the center of trust on their networks while still subscribing to the benefits of a Tailscale-maintained control plane can use Tailnet Lock.

## [How it works](#how-it-works)

Without Tailnet Lock, when a new node joins the tailnet, the Tailscale coordination server distributes the public node key to peer nodes. If Tailscale were malicious, and stealthily inserted new nodes into your network, then Tailscale could send or receive traffic to your existing nodes in plaintext.

With Tailnet Lock, when a new node joins the tailnet, its public node key requires a signature from a Tailnet Lock key. The coordination server distributes the signed public node key to peer nodes in the tailnet. Peer nodes can then verify the signature before allowing connections. In this manner, you control which nodes are trustworthy to be in your tailnet, as well as which nodes are trustworthy to sign other nodes.

Each node has a node key, and a Tailnet Lock key:

-   The [node key](https://tailscale.com/blog/tailscale-key-management#node-keys) is a public/private key pair generated on a node by a Tailscale client. The coordination server ties the node key to a specific identity. The private key remains private on the node. The public key is transmitted to the coordination server.

-   The Tailnet Lock key (TLK), which is also a public/private key pair. Every node generates a TLK, even if Tailnet Lock is not enabled. The private key of each TLK is stored on the node that generated it, and a copy of each trusted public TLK is stored in the [tailnet key authority](t#tailnet-key-authority) (TKA).


Tailnet Lock primarily consists of two components:

-   Signing nodes, which are nodes that can be used to sign new nodes into the tailnet.

-   The tailnet key authority, which is a storage mechanism for the available signing nodes in a tailnet. By knowing the current set of trusted TLKs, the TKA can verify signatures in two situations:

    -   Verifying node key signatures before adding node keys to its list of peers.

    -   Verifying signatures for requests to change the set of trusted TLKs before processing those changes.


    The TKA storage mechanism is a cryptographic chain. The TKA can grow unbounded as customers change the tailnet's configuration.


For more information about the architecture of Tailnet Lock, refer to [Tailnet Lock white paper](https://tailscale.com/kb/1230/tailnet-lock-whitepaper).

### [Disablement secrets](#disablement-secrets)

Disablement secrets are long passwords generated during the process of enabling Tailnet Lock. Because disabling Tailnet Lock is a security-relevant operation, you must have a disablement secret if you want to disable Tailnet Lock. If the disablement procedure lacked authorization checks, a compromised coordination server could trivially disable Tailnet Lock (and all its protections) to attack a tailnet as if Tailnet Lock wasn't running.

You get your disablement secrets only when you initialize Tailnet Lock. Ensure that you securely store them. Some options include using your organization's secure storage like a password manager, or printing them and storing them in a secure safe. During Tailnet Lock initialization, you can optionally generate a disablement secret for Tailscale support. This way, Tailscale support could disable Tailnet Lock in case of an issue with how we've implemented Tailnet Lock, or if you have lost your disablement secret.

### [Tailnet key authority](#tailnet-key-authority)

To determine which Tailnet Lock keys to trust, nodes implement a new subsystem, called the tailnet key authority (TKA). The TKA tracks and updates the set of Tailnet Lock keys available to sign node keys. You specify the initial set of trusted lock keys when you enable Tailnet Lock. You can [add](#add-a-signing-node) or [remove](#remove-a-signing-node) keys to change the set of trusted Tailnet Lock keys. The coordination server publishes the set of trusted Tailnet Lock keys across your tailnet.

## [Enable Tailnet Lock](#enable-tailnet-lock)

You need to be an [Owner, Admin, or IT admin](https://tailscale.com/kb/1138/user-roles) of a tailnet to enable Tailnet Lock.

Tailnet Lock is not enabled by default. With Tailnet Lock enabled, all existing nodes in the tailnet have signatures provided by a trusted node in your tailnet.

Ensure the nodes that you want to lock with Tailnet Lock are running Tailscale v1.46.1 or later.

Enabling Tailnet Lock requires using the [`tailscale lock init`](https://tailscale.com/kb/1243/tailscale-lock#lock-init) command. Use the Tailscale admin console to make it easier to create the `tailscale lock init` command values.

![Enable Tailnet Lock UI](/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fenable-tailnet-lock.3c2d04ef.png&w=1080&q=75)

1.  Open the [Device management](https://login.tailscale.com/admin/settings/device-management) page of the admin console. Ensure that you log into the same tailnet for both the admin console and the Tailscale clients running on the signing nodes.
2.  Select **Enable Tailnet Lock**.
3.  In the **Add signing nodes** section, select **Add signing node**.
4.  Select the nodes whose Tailnet Lock keys you want to trust. You must select at least two signing nodes.
5.  (Optional): In the **Configure disablement options** section, specify whether to send a [disablement secret](#disablement-secrets) to Tailscale support. When **Send disablement secret to Tailscale support** is enabled, this option will create an extra disablement secret that is automatically transmitted to Tailscale support. This way, Tailscale support could disable Tailnet Lock in case of an issue with how we've implemented Tailnet Lock, or if you have lost your disablement secret.
6.  In the **Run command from signing node** section, copy the `tailscale lock init` command.
7.  Open a terminal window on one of the signing nodes you selected.
8.  Paste in the `tailscale lock init` command that you copied from the admin console and press Enter.

When you run the `tailscale lock init` command provided by the admin console, the command creates and displays ten disablement secrets. You need only a single disablement secret to disable Tailnet Lock, not all ten, although `tailscale lock init` generates ten. Make note of the disablement secrets displayed in the output. The disablement secrets are long passwords needed to disable your Tailnet Lock. For more information about disablement secrets, refer to [`tailscale lock disable`](https://tailscale.com/kb/1243/tailscale-lock#lock-disable).

The disablement secrets display only when you initialize Tailnet Lock. If you lose your disablement secrets, and you did not provide one to Tailscale support, the tailnet cannot be recovered. Ensure that you securely store the disablement secrets. Some options include using your organization's secure storage like a password manager, or printing them and storing them in a secure safe.

After `tailscale lock init` completes successfully:

-   All existing nodes in the tailnet are signed by the trusted Tailnet Lock keys.
-   The set of trusted Tailnet Lock keys is distributed to the existing nodes.
-   Nodes verify the signature of a peer's node key before allowing a connection.
-   All new node keys must be [signed](#add-a-node-to-a-locked-tailnet) by an existing Tailnet Lock key.

When Tailnet Lock is enabled, each node relies on the initial state of Tailnet Lock sent to it from the control plane ([Trust on First Use](https://tailscale.com/kb/1230/tailnet-lock-whitepaper#enablement-is-trust-on-first-use-tofu)). To confirm that the initial state has not been compromised, you can verify the provisioned state of Tailnet Lock on each node by running the [`tailscale lock status`](https://tailscale.com/kb/1243/tailscale-lock#lock-status) command and checking the list of trusted signing keys. All nodes in your tailnet should report the same set of signing keys, which should match the Tailnet Lock keys of your designated signing nodes.

## [Disable Tailnet Lock](#disable-tailnet-lock)

You need to be an [Owner, Admin, or IT admin](https://tailscale.com/kb/1138/user-roles) of a tailnet to disable Tailnet Lock.

[Tailscale admin console](https://tailscale.com/kb/1226/tailnet-lock?tab=tailscale+admin+console)[Tailscale CLI](https://tailscale.com/kb/1226/tailnet-lock?tab=tailscale+cli)

1.  Open the [Device management](https://login.tailscale.com/admin/settings/device-management) page of the admin console.
2.  Select **Disable Tailnet Lock**.
3.  For **Disablement secret**, enter a [disablement secret](#disablement-secrets) that you stored securely when you enabled Tailnet Lock.
4.  Select **Disable Tailnet Lock**.

Once you use the specified disablement secret, the Tailscale coordination server distributes it to all nodes in the tailnet and you should consider it public.

If you re-enable Tailnet Lock, for example, by running the `tailscale lock init` command again, you get new disablement secrets.

If you encounter a significant issue with Tailnet Lock for your entire tailnet and can't disable it by using the [Device management](https://login.tailscale.com/admin/settings/device-management) page (for example, if you can't locate your disablement secret), you could run the `tailscale lock local-disable` command on each of your nodes to make your tailnet in effect ignore Tailnet Lock. For details, refer to [`tailscale lock local-disable`](https://tailscale.com/kb/1243/tailscale-lock#lock-local-disable).

## [Add a node to a locked tailnet](#add-a-node-to-a-locked-tailnet)

If you have already enabled Tailnet Lock and want to add an additional node, you need to sign the new node's [node key](https://tailscale.com/blog/tailscale-key-management#node-keys).

You have two options to add a node:

-   Use a Tailscale client app signing link. This is possible only for macOS, Windows, and iOS. _We are working on Android._
-   Use the [`tailscale lock sign`](https://tailscale.com/kb/1243/tailscale-lock#lock-sign) command, which is part of the [Tailscale CLI](https://tailscale.com/kb/1080/cli). This is possible only for Linux, macOS, and Windows.

Both options require access to the Tailscale admin console, because retrieving information for the node key to add is possible only through the [Machines](https://login.tailscale.com/admin/machines) page of the admin console.

### [Use a client app to add a node](#use-a-client-app-to-add-a-node)

1.  Open the [Machines](https://login.tailscale.com/admin/machines) page of the admin console. Ensure that you log into the same tailnet for both the admin console and the Tailscale clients running on the signing nodes.
2.  Select the node that needs a signature. Look for the **Locked out** badge in the machines list, or use the [`property:locked-out`](https://login.tailscale.com/admin/machines?q=property%3Alocked-out) filter to find all devices that are locked out.
3.  Select **Sign machine**.
4.  In the **Sign machine** dialog, you have 3 tabs to choose from, to add the node.
    -   In the **Desktop** tab, if you are on a macOS or Windows device that is a signing node, select **Sign this node**. Otherwise, select **Copy signing URL**, send the URL to a signing node, and open the URL on the signing node. Either process opens the Tailscale client and lets you add the node.

    -   In the **Mobile** tab, if you are on an iOS device that is a signing node, scan the QR code to open the Tailscale client, then add the node. Alternatively, select **Copy signing URL**, send the URL to a signing node, and open the URL on the signing node. Either process opens the Tailscale client and lets you add the node.

        Using a QR code to add a node is currently supported only on iOS devices.

    -   In the **CLI** tab, select the **Copy** icon to copy the [`tailscale lock sign`](https://tailscale.com/kb/1243/tailscale-lock#lock-sign) command. Run the command on a signing node to add the node.


### [Use the CLI to add a node](#use-the-cli-to-add-a-node)

Use the [`tailscale lock sign`](https://tailscale.com/kb/1243/tailscale-lock#lock-sign) command to add a node:

```shell
tailscale lock sign nodekey:1abddef1 tlpub:abcdef12
```

`nodekey:1abddef1` is the node key for the node you want to add to your tailnet. `tlpub:abcdef12` is an optional Tailnet Lock key for a trusted signing node, to use for key rotation.

You can determine the `tailscale lock sign` command either using the admin console or using the [Tailscale CLI](https://tailscale.com/kb/1080/cli).

To determine the `tailscale lock sign` command using the admin console:

1.  Open the [Machines](https://login.tailscale.com/admin/machines) page of the admin console. Ensure that you log into the same tailnet for both the admin console and the Tailscale clients running on the signing nodes.
2.  Select the node that needs to be signed. Look for the **Locked out** badge in the machines list, or use the [`property:locked-out`](https://login.tailscale.com/admin/machines?q=property%3Alocked-out) filter to find all devices that are locked out.
3.  Select **Sign node**.
4.  Select **CLI**.
5.  Copy the `tailscale lock sign` command needed to sign the node.
6.  Run the command on a signing node to add the node.

Alternatively, to determine the `tailscale lock sign` command using the Tailscale CLI:

1.  On the node that you want to add to your tailnet, run:

    ```shell
    tailscale lock status
    ```

2.  In the output of `tailscale lock status`, copy the `tailscale lock sign` command needed to sign the node.


Then, on a node with a trusted Tailnet Lock key, run the command you copied in the previous step:

```shell
tailscale lock sign nodekey:<your-node-key> tlpub:<your-tailnet-lock-key>
```

When a signed node key [expires](https://tailscale.com/kb/1028/key-expiry), the new node key will not need to be re-signed. When the user re-authenticates, the node's signature will be automatically rotated, by signing the new node key with the node's [Tailnet Lock key](https://tailscale.com/kb/1230/tailnet-lock-whitepaper#tailnet-lock-keys).

### [Add a node using a pre-signed auth key](#add-a-node-using-a-pre-signed-auth-key)

Signing an [auth key](https://tailscale.com/kb/1085/auth-keys) lets you add devices to your locked tailnet using [pre-signed](https://tailscale.com/kb/1085/auth-keys#authkey-pre-signed) auth keys, so that you don't need to add the node and _then_ sign its node key.

1.  [Generate](https://tailscale.com/kb/1085/auth-keys#generate-an-auth-key) a pre-approved auth key.

2.  On a node with a trusted Tailnet Lock key, set an environment variable, `AUTH_KEY`, to the value of the auth key:

    ```shell
    export AUTH_KEY="tskey-auth-XXXXCTRL-NNNNNN"
    ```

3.  Sign the auth key by running the [`tailscale lock sign`](https://tailscale.com/kb/1243/tailscale-lock#lock-sign) command:

    ```shell
    tailscale lock sign $AUTH_KEY
    ```

4.  Use the new key that is generated by the `tailscale lock sign` command to [pre-approve devices](https://tailscale.com/kb/1099/device-approval#pre-approve-devices-with-an-auth-key) in your tailnet.


## [Determine a node's Tailnet Lock public key](#determine-a-nodes-tailnet-lock-public-key)

For some Tailnet Lock operations, you need to know a node's Tailnet Lock public key. This is not the same as a node's Tailscale public key, which is of the form `nodekey:abcdef12`. A node's Tailnet Lock public key is of the form `tlpub:abcdef12.`

### [Determining the Tailnet Lock public key by using the CLI](#determining-the-tailnet-lock-public-key-by-using-the-cli)

To determine a node's Tailnet Lock public key using the [Tailscale CLI](https://tailscale.com/kb/1080/cli), which is possible only for Linux, macOS, and Windows:

-   Run [`tailscale lock status`](https://tailscale.com/kb/1243/tailscale-lock#lock-status). The command displays the Tailnet Lock public key for the node.

### [Determining the Tailnet Lock public key by using the admin console](#determining-the-tailnet-lock-public-key-by-using-the-admin-console)

To determine a node's Tailnet Lock public key using the admin console:

1.  Open the [Machines](https://login.tailscale.com/admin/machines). Ensure that you log into the same tailnet for both the admin console and the Tailscale clients running on the signing nodes.

2.  Select the node whose Tailnet Lock public key you want to determine.

3.  In the **Machine Details** section, look for **Tailnet Lock key**. If you do not find **Tailnet Lock key** within the UI, then Tailnet Lock is not enabled for the tailnet.

4.  Select **Copy** to copy the key to your clipboard.


### [Determining the Tailnet Lock public key by using the client](#determining-the-tailnet-lock-public-key-by-using-the-client)

[macOS](https://tailscale.com/kb/1226/tailnet-lock?tab=macos)[iOS](https://tailscale.com/kb/1226/tailnet-lock?tab=ios)

1.  Select **Settings** from the Tailscale client menu.
2.  Select the **Settings** tab if it is not already active.
3.  In the **Tailnet Lock** section, select **Manage**.
4.  In the dialog that opens, the **Tailnet Lock Key** section shows the Tailnet Lock public key. Select the **Copy** icon to copy the key to your clipboard.

## [Add a signing node](#add-a-signing-node)

1.  [Determine the Tailnet Lock public key](#determine-public-key) for the node you want to add as a signing node.

2.  On a node with a trusted Tailnet Lock key, run the [`tailscale lock add`](https://tailscale.com/kb/1243/tailscale-lock#lock-add) command, passing in the Tailnet Lock keys that you determined in the previous step.

    This examples adds two signing nodes:

    ```shell
    tailscale lock add tlpub:trusted-key1, tlpub:trusted-key2
    ```


## [Remove a signing node](#remove-a-signing-node)

You need to run this process from a node with a trusted Tailnet Lock key.

1.  If you don't already have the Tailnet Lock public key for each node you want to remove as a signing node, [determine the Tailnet Lock public key](#determine-public-key).

2.  On a node with a trusted Tailnet Lock key, run the [`tailscale lock remove`](https://tailscale.com/kb/1243/tailscale-lock#lock-remove) command, passing in the Tailnet Lock keys that you determined in the previous step.

    This example removes two signing nodes:

    ```shell
    tailscale lock remove tlpub:trusted-key7 tlpub:trusted-key8
    ```


When you remove a signing node _Node-B_ by running `tailscale lock remove` on node _Node-A_, by default all nodes previously signed by Node-B are re-signed with Node-A's key. You can disable this by passing in `--re-sign=false` to the `tailscale lock remove` command.

## [Revoke a compromised signing node](#revoke-a-compromised-signing-node)

If a signing node becomes compromised, revoke the compromised key by running the [`tailscale lock revoke-keys`](https://tailscale.com/kb/1243/tailscale-lock#lock-revoke-keys) command. Once you revoke a key, you can no longer use it for Tailnet Lock. Any nodes that were previously signed by a revoked key lose their authorization and require a new signature.

If you want to remove a key that is not compromised, use the [`tailscale lock remove`](https://tailscale.com/kb/1243/tailscale-lock#lock-remove) command instead.

Revocation is a multi-step process that requires several signing nodes to co-sign the revocation. Each step uses the `tailscale lock revoke-keys` command.

1.  Open a terminal on a signing node that does not have a compromised key.

2.  Run the following command, where `tlpub:compromised-key1 tlpub:compromised-key2` is a space-separated list of the keys that you want to revoke:

    ```shell
    tailscale lock revoke-keys tlpub:compromised-key1 tlpub:compromised-key2
    ```

    The output of this command contains a `tailscale lock revoke-keys --cosign` command, which you will use in the next step.

3.  On another trusted signing node, run the `tailscale lock revoke-keys --cosign` command. The output of this command contains a new `tailscale lock revoke-keys --cosign` command. Repeat this process, always using the new output from each `--cosign` command, until the number of times you used `--cosign` exceeds the number of revoked keys. For example, if you revoked 3 keys, you need to run the `tailscale lock revoke-keys --cosign` command 4 times.

4.  Finish the process by running the command that was output from the last use of `--cosign` **except** replace `--cosign` with `--finish`:

    ```shell
    tailscale lock revoke-keys --finish <hex-data>
    ```


By default, Tailscale will determine the appropriate point in the Tailnet Lock log to fork. If more signing nodes agree that a key should be revocable than not, then your tailnet uses the keys in the fork that Tailscale determined as still trustworthy, instead of the revoked keys.

If the majority of signing nodes become compromised, you can disable and then re-enable Tailnet Lock itself.

## [How Tailnet Lock works with other Tailscale features](#how-tailnet-lock-works-with-other-tailscale-features)

Take the following into consideration for how Tailnet Lock works with other Tailscale features.

### [Sharing](#sharing)

To use Tailnet Lock with the [sharing feature](https://tailscale.com/kb/1084/sharing), a node shared into a tailnet with Tailnet Lock requires a signature before it is accessible.

To share nodes out of a tailnet with Tailnet Lock, the user who accepts the share invite needs to have their nodes signed in the locked tailnet before they can access the shared node.

### [Tailscale SSH Console](#tailscale-ssh-console)

You can use [Tailscale SSH Console](https://tailscale.com/kb/1216/tailscale-ssh-console) to establish an SSH session for a signed node in your tailnet, provided:

-   your [tailnet policy file](https://tailscale.com/kb/1018/acls) permits network access.
-   a [Tailscale SSH rule](https://tailscale.com/kb/1337/policy-syntax#ssh) permits SSH access.

## [Configuration audit logging](#configuration-audit-logging)

Enabling, disabling, or modifying Tailnet Lock configuration creates events that will appear in the [configuration audit logs](https://tailscale.com/kb/1203/audit-logging).

Independent of configuration audit logging, you can run the [`tailscale lock log`](https://tailscale.com/kb/1243/tailscale-lock#lock-log) command on a node to find recent Tailnet Lock changes to your tailnet.

## [Tailnet Lock state](#tailnet-lock-state)

Tailnet Lock tries to store data in the Tailscale state directory of each node:

-   If you use the macOS, Windows, iOS, Android, and tvOS clients, the state directory is set automatically.
-   If you run the [`tailscaled` daemon](https://tailscale.com/kb/1278/tailscaled), the state directory is set by the [`--statedir`](https://tailscale.com/kb/1278/tailscaled#flags-to-tailscaled) or `--state` flags.
-   If you use the default systemd unit files distributed with the official Tailscale `deb`, `rpm` and `tar.gz` packages, the `--state` flag is set automatically.
-   If you use Tailscale in Docker or Kubernetes, the state directory is set by the [`TS_STATE_DIR` environment variable](https://tailscale.com/kb/1282/docker#ts_state_dir).

If you do not provide a state directory, Tailscale must store Tailnet Lock data in-memory. This means your node must re-fetch the complete state from the control plane whenever it starts.

We strongly recommend setting a state directory, which removes this control plane startup dependency.

## [Limitations](#limitations)

-   You need to securely store the [disablement secrets](#disablement-secrets) yourself. If you lose your disablement secrets, and you did not provide one to Tailscale support, the tailnet cannot be recovered.
-   You can have a maximum of 20 signing nodes in your tailnet.
-   To prevent unbounded growth of the TKA, rotate Tailnet Lock keys at most once per year.
-   You cannot enable both Tailnet Lock and [device approval](https://tailscale.com/kb/1099/device-approval)-they are mutually exclusive features.
-   Tailnet Lock keys are stored on the device. If the device is compromised, the key can be obtained.
-   You cannot use an Android device as a signing node, because it cannot be used for signing operations. _This is being worked on._
```



### File: 1227-bug-report.md

```markdown
# Generate a bug report

The Tailscale support team can help troubleshoot certain issues based on diagnostic logs. If you are working with the support team to troubleshoot an issue, you might be asked to create a bug report. A bug report is a random indicator that marks a section of the diagnostic logs to give us better visibility into what is occurring at a specific time, which can help make triage easier.

To generate a bug report, you must be directly using the device-a bug report cannot be generated remotely.

A bug report looks like this:

```shell
BUG-1b7641a16971a9cd75822c0ed8043fee70ae88cf05c52981dc220eb96a5c49a8-20210427151443Z-fbcd4fd3a4b7ad94
```

The bug report identifier shares no personally-identifiable information, and is unused unless you share the bug report with our team. You can generate a bug report by using the Tailscale client applications, or the [`bugreport`](https://tailscale.com/kb/1080/cli#bugreport) command in the [Tailscale CLI](https://tailscale.com/kb/1080/cli).

After you generate a bug report, copy and paste the value that you can then share when you [contact support](https://tailscale.com/contact/support#support-form).

## [Generating a bug report by using the client application](#generating-a-bug-report-by-using-the-client-application)

[macOS](https://tailscale.com/kb/1227/bug-report?tab=macos)[Windows](https://tailscale.com/kb/1227/bug-report?tab=windows)[Android](https://tailscale.com/kb/1227/bug-report?tab=android)[iOS](https://tailscale.com/kb/1227/bug-report?tab=ios)[tvOS](https://tailscale.com/kb/1227/bug-report?tab=tvos)

There are two ways of sending us information to help resolve an issue.

You can copy a bug report identifier string that the Tailscale support team can use for diagnosing general connectivity issues. To generate a bug report identifier:

1.  Select the Tailscale icon in the menu bar.
2.  Select **Settings**, **About**, then **Report an Issue**.
3.  Copy the bug report identifier string and paste it into your correspondence to the Tailscale support team.

The Tailscale support team might also ask you to generate a configuration report that contains more in-depth information. To generate and export a configuration report:

1.  Select the Tailscale icon in the menu bar.
2.  Select **Settings**, **About**, then **Report an Issue**.
3.  Select the **Export Configuration Report**.
4.  After the report generation is complete, the folder where it has been saved will open in the Finder. Copy and paste it into your correspondence to the Tailscale support team.

The configuration report is a `tar.gz` file that includes information gathered by various diagnostic tools on your Mac, such as `netstat`, `ifconfig`, `lsappinfo`, and `systemextensionsctl`. Sharing this report with the support team will speed up the troubleshooting process because it gives them a detailed look at what might be causing the issue.

Since many Tailscale issues stem from conflicts with other software installed on your Mac, the report also includes a list of installed third-party applications and system/kernel extensions. While the Tailscale support team strives to handle your personal information carefully, it's a good idea to check the configuration report yourself before sending it to ensure you're not accidentally disclosing any sensitive information.

## [Generating a bug report by using the CLI](#generating-a-bug-report-by-using-the-cli)

The [Tailscale CLI](https://tailscale.com/kb/1080/cli) is supported only for Linux, macOS, and Windows.

Run the [`bugreport`](https://tailscale.com/kb/1080/cli#bugreport) command:

```shell
tailscale bugreport
```

If you are using macOS and you haven't [set your system path](https://tailscale.com/kb/1080/cli?tab=macos#using-the-cli) to include the Tailscale command executable, you need to specify the path to `tailscale`. For example:

```shell
/Applications/Tailscale.app/Contents/MacOS/Tailscale bugreport
```

You can use the following flags with the `bugreport` command:

-   `--diagnose` Prints additional verbose information about the system to the Tailscale logs after generating a bugreport identifier, which can then be viewed by our support team. Defaults to false.
-   `--record` Pause and then write another bugreport. Use this flag to create an initial bugreport identifier. During the pause, perform the action that reproduces your issue. Then, press Enter to create a second bugreport identifier. Share both bug identifiers with our team. Defaults to false.

## [What is shared in a bug report](#what-is-shared-in-a-bug-report)

The components of the bug report identifier are:

-   `BUG` to signal that this is a bug report
-   The public key for your device's logs, used by Tailscale support to locate the correct logs
-   The time that the bug report was created
-   A random number, used by Tailscale support to locate the correct location within the log

When a bug report is generated, the bug report identifier is written to the [client logs](https://tailscale.com/kb/1011/log-mesh-traffic#client-logs), along with current health status, the current network map supplied by the coordination server, and some additional OS-dependent information that we have found useful to collect when responding to support requests, such as:

-   Windows registry settings relating to the Tailscale application
-   Windows page file settings, DLL versions, a list of installed security applications, and network interface information
-   Some additional details about internal state are also recorded if the bug report is generated using the CLI with the `--diagnose` option.

The bug report details are recorded in the [client logs](https://tailscale.com/kb/1011/log-mesh-traffic#client-logs). You can see exactly what was sent by reading those logs. You can also [inspect the code](https://github.com/tailscale/tailscale/blob/main/ipn/localapi/localapi.go) that generates the bug reports in GitHub, search for `serveBugReport`.

If [client logging is disabled](https://tailscale.com/kb/1011/log-mesh-traffic#opting-out-of-client-logging) then bug reports are not generated even when using the `tailscale bugreport` command and nothing is sent to Tailscale.
```



### File: 1245-set-up-servers.md

```markdown
# Setting up a server on your Tailscale network

If you're setting up servers on Tailscale, we recommend you use an [auth key](https://tailscale.com/kb/1085/auth-keys) to provision the server, and a [tag](https://tailscale.com/kb/1068/tags) to restrict its access. You can also set up [Tailscale SSH](https://tailscale.com/kb/1193/tailscale-ssh) to access your servers.

Here's how to set up a server in Tailscale:

1.  Create a new [tag](https://tailscale.com/kb/1068/tags) in your tailnet for the type of shared resource you are managing. For example, you can use the tag `server` for your servers, `prod` or `test` for your environments, and `front-end` for grouping of other resources that you maintain.

    To create a tag, modify the [tailnet policy file](https://tailscale.com/kb/1018/acls) to specify the owner of the tag, which is the team or user who can use that tag. You can use an existing tag for all servers. If you're also setting up Tailscale SSH, we recommend using a new tag.

    ```json
    {
      "tagOwners": {
        "tag:server": ["alice@example.com"]
      }
    }
    ```

    You can use the [visual policy editor](https://tailscale.com/kb/1550/visual-editor) to manage your tailnet policy file. Refer to the [visual editor reference](https://tailscale.com/kb/1587/visual-editor-reference) for guidance on using the visual editor.

2.  Write [access rules](https://tailscale.com/kb/1337/policy-syntax#acls) in the tailnet policy file which:

    -   Allow the desired sources to reach the tagged resources
    -   If you're also setting up Tailscale SSH, allow the desired sources to reach the tagged resources using Tailscale SSH

    ```json
    {
      "grants": [
        {
          "src": ["group:sre"],
          "dst": ["tag:server"],
          "ip": ["*"]
        }
      ],
      "ssh": [
        {
          "action": "accept",
          "src": ["group:sre"],
          "dst": ["tag:server"],
          "users": ["ubuntu", "root"]
        }
      ]
    }
    ```

    You can use the [visual policy editor](https://tailscale.com/kb/1550/visual-editor) to manage your tailnet policy file. Refer to the [visual editor reference](https://tailscale.com/kb/1587/visual-editor-reference) for guidance on using the visual editor.

3.  Generate an [authentication key](https://tailscale.com/kb/1085/auth-keys) to automatically connect servers to your network. Select the tag or tags you wish to use for your servers as part of this auth key.

    -   If you're authenticating more than one server, use a reusable auth key. Or, for long-lived auth keys, set up an [OAuth client with the scope `auth_keys`](https://tailscale.com/kb/1215/oauth-clients#generating-long-lived-auth-keys).
    -   If you're authenticating ephemeral workloads like containers or functions, use an ephemeral key.
    -   If your tailnet has [device approval](https://tailscale.com/kb/1099/device-approval) enabled, and you only intend to use that to approve end-user devices, use a pre-authorized auth key.

    ![Tailscale's auth key generation page](/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fgenerate-auth-key.a0369d5c.png&w=750&q=75)


The **Pre-approved** option will only display in the dialog if [device approval](https://tailscale.com/kb/1099/device-approval) is enabled in your Tailscale network.

Currently, if your client node is provisioned with an [authentication key](https://tailscale.com/kb/1085/auth-keys), you cannot use [check mode](https://tailscale.com/kb/1193/tailscale-ssh#check-mode) when establishing a Tailscale SSH connection using the node as a source.

4.  When you provision a new server, [install](https://tailscale.com/download) and connect to Tailscale manually or as part of your automation tooling. Make sure to specify the auth key including the tags you want, and to enable Tailscale SSH.

    ```shell
    tailscale up --auth-key=$TS_AUTHKEY
    ```

    If you want to specify a particular machine name for your server to use with [MagicDNS](https://tailscale.com/kb/1081/magicdns), then also specify `--hostname`:

    ```shell
    tailscale up --auth-key=$TS_AUTHKEY --hostname=$TS_HOSTNAME
    ```

    If the auth key was not generated with tags, then also specify `--advertise-tags`:

    ```shell
    tailscale up --auth-key=$TS_AUTHKEY --advertise-tags=<tags>
    ```

    If you want to enable Tailscale SSH, then also specify `--ssh`:

    ```shell
    tailscale up --auth-key=$TS_AUTHKEY --ssh
    ```

5.  To access your servers over Tailscale, you can connect to them like any other device in your tailnet.

    If you have Tailscale SSH set up, you can connect to your severs using [Tailscale SSH](https://tailscale.com/kb/1193/tailscale-ssh) or [Tailscale SSH Console](https://tailscale.com/kb/1216/tailscale-ssh-console).
```



### File: 1246-tailscale-ssh-session-recording.md

```markdown
# Tailscale SSH session recording

Tailscale SSH session recording lets you stream logs of [Tailscale SSH](https://tailscale.com/kb/1193/tailscale-ssh) sessions to another node in your tailnet. These recordings are encrypted end-to-end just like all other Tailscale traffic.

Tailscale SSH session recording is currently [in beta](https://tailscale.com/kb/1167/release-stages#beta). To try it, follow the steps below to enable it for your network using Tailscale v1.40.1 or later.

Tailscale SSH session recording is available for [the Personal, Personal Plus, and Enterprise plans](https://tailscale.com/pricing).

## [How it works](#how-it-works)

Tailscale SSH session recording lets you stream recordings of Tailscale SSH sessions from the destination node to a recorder node in your tailnet. The recorder is a [`tsnet` binary](https://tailscale.com/blog/tsnet-virtual-private-services), which you deploy to a machine or [Kubernetes cluster](https://tailscale.com/kb/1484/kubernetes-operator-deploying-tsrecorder) you manage. Logs are streamed over your tailnet to your node, so they are end-to-end encrypted and not visible to Tailscale. The recorder can either store the log files on the host filesystem, or export them to Amazon S3 or another S3-compatible storage service.

Tailscale SSH session recording captures terminal sessions in [`asciinema`](https://asciinema.org) format. These recordings are newline-delimited JSON files that can be searched as text, and replayed from the recorder node's optional web UI or the `asciinema` CLI.

Session recording captures all terminal output, meaning any text that appears on the terminal screen during a Tailscale SSH session. This could include sensitive data. No keystrokes are captured.

When using binary protocols like older versions of `scp`, session recording will capture the transmitted binary data. This could include sensitive data.

## [Set up session recording for Tailscale SSH](#set-up-session-recording-for-tailscale-ssh)

### [Prerequisites](#prerequisites)

Session recording is only available for SSH connections over Tailscale SSH.

You need to be an [Owner, Admin, or Network admin](https://tailscale.com/kb/1138/user-roles) of a tailnet to set up session recording.

To enable session recording, you must:

-   Ensure that Tailscale SSH is properly configured in your tailnet.
-   Deploy a recorder node in your tailnet.
-   Turn on session recording in your tailnet policy file by adding a `recorder:["tag:<tag-name>"]` field to each SSH policy entry. SSH sessions permitted by that stanza will be streamed to any recorder with the named tag.

The recorder node binary will run on any platform as a Docker container. Because the binary uses [`tsnet`](https://tailscale.com/blog/tsnet-virtual-private-services) to join your tailnet as a node, the Docker host does not need to be a member of your tailnet. The application listens on port `80` to receive session recordings, and provides an optional, built-in web application for viewing session recordings at port `443`.

### [Create a tag and auth key for session recorders](#create-a-tag-and-auth-key-for-session-recorders)

A recorder node must be associated with a tag. We recommend that you create a new [tag](https://tailscale.com/kb/1068/tags) specifically to use with SSH session recording. You can do this by visiting the [Access controls](https://login.tailscale.com/admin/acls) page of the admin console and defining an owner of the tag in access control policies.

```json
// Example tag for SSH session recorders
"tagOwners": {
  "tag:session-recorder": [
    "<tag-owner>",
  ],
}
```

Next, visit the [Keys](https://login.tailscale.com/admin/settings/keys) page of the admin console to create an auth key. Assign the new tag you created to this auth key. If your tailnet has device approval enabled, use a pre-approved key. Be sure to copy this auth key to your clipboard.

On the host where you will deploy the recorder node container, set the `TS_AUTHKEY` environment variable to the auth key. This is only necessary the first time you start the recorder application.

```markup
export TS_AUTHKEY=<your-auth-key>
```

### [Deploy a recorder node](#deploy-a-recorder-node)

The recorder is provided as a Docker container, and you can find it on [Tailscale's DockerHub profile](https://hub.docker.com/r/tailscale/tsrecorder/tags).

If you use Tailscale's Kubernetes operator, you can also deploy the recorder using the [`Recorder` Custom Resource](https://tailscale.com/kb/1484/kubernetes-operator-deploying-tsrecorder).

```shell
docker pull tailscale/tsrecorder:stable
```

To run the container and save recordings to the Docker host's filesystem:

```shell
docker run --name tsrecorder --rm -it \
  -e TS_AUTHKEY=$TS_AUTHKEY \
  -v $HOME/tsrecorder:/data \
  tailscale/tsrecorder:stable \
  /tsrecorder --dst=/data/recordings --statedir=/data/state --ui
```

Required flags:

-   `--dst` Specifies where recordings will be saved. Accepts a local file path or an S3 region URL. You can alternatively define the value as an environment variable, `TSRECORDER_DST`.

Optional flags:

-   `--hostname` Specifies a hostname to use for the recorder node. Defaults to `recorder`. You can alternatively define the value as an environment variable, `TSRECORDER_HOSTNAME`.
-   `--access-key` The AWS access key for an IAM user that can upload recordings to an S3 bucket. Required when using S3 as a storage backend if no IAM role is passed to the instance. You can alternatively define the secret access key as an environment variable, `AWS_ACCESS_KEY_ID`.
-   `--secret-key` The AWS secret access key for an IAM user that can upload recordings to an S3 bucket. Required when using S3 as a storage backend if no IAM role is passed to the instance. You can alternatively define the secret access key as an environment variable, `AWS_SECRET_ACCESS_KEY`.
-   `--bucket` The name of the S3 bucket where the recorder should upload recordings. Required when using S3 as a storage backend. You can alternatively define the secret access key as an environment variable, `TSRECORDER_BUCKET`.
-   `--state` Path to Tailscale state file, used to persist recorder state across container restarts. This can be a persistent volume or a Kubernetes [`Secret`](https://kubernetes.io/docs/concepts/configuration/secret/). You can alternatively define this value as an environment variable, `TS_STATE`.
    -   To use a `Secret`, specify `kube:<secret-name>`. If set to use a `Secret` for state storage, the recorder must have permissions to read, update, and patch the `Secret`. If the `Secret` does not exist, the recorder will create it, and must have permissions to do so.
    -   If `--state` is unset, the state will be stored in the directory set via `--statedir`.
-   `--statedir` Specifies where the recorder should store its internal state. Accepts a local file path. If storage backend is filesystem, defaults to `<recordings-destination>/state`. Required unless statefile path is set. Alternatively can be set via `TS_STATE_DIR` env var.
-   `--ui` Enables the recorder container web UI for viewing recorded SSH sessions. Defaults to `false` if this flag is not present. You can alternatively define this value as an environment variable, `TSRECORDER_UI`.
    -   If you deploy the recorder with the UI, you must have HTTPS enabled in your tailnet.
    -   If you enable the recorder container web UI, you should restrict access to port `443` on the recorder in your access control policies to prevent unauthorized members of your tailnet from viewing sensitive recordings.

### [Turn on session recording in your tailnet policy file](#turn-on-session-recording-in-your-tailnet-policy-file)

You can turn on session recording on a per-access rule basis for SSH [access rules](https://tailscale.com/kb/1337/policy-syntax#acls) in your tailnet policy file. For each rule, add a `recorder` field and specify the tag (`["tag:<tag-name>"]`) that is attached to the recorder node. If no `recorder` is specified, the session is not recorded.

By default, Tailscale will allow a Tailscale SSH session to connect when session recording is enabled for its SSH access rule even if the recorder nodes are unreachable. We refer to this as "failing open." You can adjust this behavior by adding the `enforceRecorder` field and setting it to `true`. This will deny and/or terminate any Tailscale SSH session that should be recorded when the recorder nodes are unreachable. We refer to this behavior as "failing closed".

If an SSH connection is allowed by two or more SSH access rules, and the access rules specify different values for `enforceRecorder`, Tailscale will follow the behavior that is listed first in the tailnet policy file.

```json
{
  "action": "check", // "accept" or "check"
  "src": [list-of-sources],
  "dst": [list-of-destinations],
  "users": [list-of-ssh-users],
  "recorder": ["tag:<tag-name>"], // optional field; specify the tag attached to your recorder node.
  "enforceRecorder": false, // optional field; defaults to false; if session recorder node is unavailable, should the session be denied?
},
```

If `enforceRecorder` is `true` and the recorder node becomes unavailable after session recording is enabled in access control policies, Tailscale SSH sessions will be refused. Any active Tailscale SSH sessions will be terminated. To establish a Tailscale SSH session when the recorder node is unreachable and set to fail closed, remove the `recorder` field in access control policies.

## [Scope access to the recorder node and host](#scope-access-to-the-recorder-node-and-host)

Each Tailscale SSH server sends its SSH session recordings to the recorder node on port `80`. Tailscale will automatically ensure that traffic is permitted between Tailscale SSH servers and the recorder nodes to which they send sessions. You don't need to make any changes in access control policies to allow this.

If you enabled the recorder container web UI, you should be sure to allow access to port `443` for the appropriate users. Like before, use the associated tag to write this access rule.

Because the recorder stores the session recordings on the host disk, you should ensure that you have restricted access to these environments to the right users. We recommend scoping access to the recorder node and its host to the fewest number of users necessary, and recall that Owners, Admins, and Network admins will all have access to change access rules for this feature.

## [Disable session recording](#disable-session-recording)

You can disable Tailscale SSH session recording for specific SSH access rules, or for the whole tailnet.

### [Disable session recording for specific Tailscale SSH access rules](#disable-session-recording-for-specific-tailscale-ssh-access-rules)

To disable Tailscale SSH session recording for specific SSH access rules, remove the `recorder` line from the SSH access rule. SSH sessions that meet that rule will no longer be recorded.

Previous recordings will not be removed, and need to be deleted from the recorder node.

### [Disable session recording for all Tailscale SSH sessions](#disable-session-recording-for-all-tailscale-ssh-sessions)

To disable Tailscale SSH session recording for all Tailscale SSH sessions in the tailnet:

-   Remove the `recorder` rule from all SSH access rules in the `ssh` section of your tailnet policy file
-   Remove the recorder node from your tailnet. This can be done by removing the device from the [Machines](https://login.tailscale.com/admin/machines) tab of the admin console.

## [Session recordings](#session-recordings)

Recordings are stored at the directory you specified, as `/dir/<stablenodeid>/<timestamp>.cast`. The `<stablenodeid>` directory corresponds to the [stable node ID](https://tailscale.com/api#tag/devices) of the SSH servers being accessed.

If you run out of disk on the host, the recorder can no longer store sessions and will fail. This will cause open sessions to be terminated and new sessions to be refused. To fix this, remove the `recorder` field from the SSH access rule for your machine, access the node host, clear space or add storage, and replace the `recorder` field.

### [Viewing recordings](#viewing-recordings)

Tailscale SSH session recording captures each SSH session in `asciinema` format. This format can be played to see what occurred in a session.

If you are deploying the recorder with the built-in web UI turned on, you can view your recordings from a web browser at the URL. You can find your [tailnet DNS name](https://tailscale.com/kb/1217/tailnet-name#tailnet-dns-name) in the [DNS](https://login.tailscale.com/admin/dns) page of the admin console.

`https://{recorder-name}.{tailnet-dns-name}.ts.net`

From the CLI, you can view the recording data using the command:

```shell
cat <session-recording.cast>
```

You can also watch recordings from the CLI with `asciinema` using the command:

```shell
play <session-recording.cast>
```

To install `asciinema` locally, refer to the [installation docs](https://docs.asciinema.org/manual/cli/installation) for your platform.

You can also convert the recording to a gif using [`agg`](https://github.com/asciinema/agg).

### [Analyzing recordings](#analyzing-recordings)

Recordings use the `asciinema` format, so they are newline-delimited JSON files that can be searched as text. For example, to search a recording for `sudo`:

```shell
grep "sudo" <session-recording.cast>
```

### [Example recording](#example-recording)

Here's an example of a short session recording being replayed using `asciinema`:

![A recording of a terminal, made with asciinema, where the user types 'echo hi' and the terminal prints 'hi'.](/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fssh-recording-demo.904d935d.gif&w=3840&q=75)

A demo of the asciinema session recording playback.

This is how the same recording is represented in the `asciinema` file. It's easy to search this file for keywords or patterns that interest you.

```markup
{"version":2,"width":203,"height":38,"timestamp":1679441819,"env":{"TERM":"xterm-256color"},"srcNode":"srcnode.ts.net","srcNodeID":"nguedK2CNTRL","srcNodeTags":null,"sshUser":"alice","localUser":"alice","srcNodeUserID":30585448562688899,"srcNodeUser":"alice@tailscale.com"}
[0.456997416,"o","Last login: Tue Mar 21 16:35:14 from 1.2.3.4\r\n"]
[0.552500666,"o","\u001b[1m\u001b[7m%\u001b[27m\u001b[1m\u001b[0m                                                                                                                                                                                                          \r \r"]
[0.557596708,"o","\u001b]2;alice@laptop:~\u0007\u001b]1;~\u0007"]
[0.567016125,"o","\r\u001b[0m\u001b[27m\u001b[24m\u001b[J\u001b[01;32m➜  \u001b[36m~\u001b[00m \u001b[K"]
[0.567112833,"o","\u001b[?1h\u001b=\u001b[?2004h"]
[1.500827583,"o","e"]
[1.58455025,"o","\u0008ec"]
[1.6682777500000001,"o","h"]
[1.7546742499999999,"o","o"]
[1.896455708,"o"," "]
[2.020248958,"o","h"]
[2.08789675,"o","i"]
[2.323278875,"o","\u001b[?1l\u001b\u003e"]
[2.323438208,"o","\u001b[?2004l\r\r\n"]
[2.324209,"o","\u001b]2;echo hi\u0007"]
[2.324296291,"o","\u001b]1;echo\u0007hi\r\n\u001b[1m\u001b[7m%\u001b[27m\u001b[1m\u001b[0m                                                                                                                                                                                                          \r \r"]
[2.334692083,"o","\u001b]2;alice@laptop:~\u0007\u001b]1;~\u0007"]
[2.349814583,"o","\r\u001b[0m\u001b[27m\u001b[24m\u001b[J\u001b[01;32m➜  \u001b[36m~\u001b[00m \u001b[K"]
[2.349910875,"o","\u001b[?1h\u001b=\u001b[?2004h"]
[2.89156075,"o","\u001b[?2004l\r\r\n"]
```

### [(Optional) Deploy multiple recorders for failover](#optional-deploy-multiple-recorders-for-failover)

If you are running Tailscale SSH session recording in a production environment, you may want to [deploy multiple recorders in a failover configuration](https://tailscale.com/kb/1262/multiple-recorder-nodes) to prevent unwanted downtime.

## [Limitations](#limitations)

-   Recordings are only available for Tailscale SSH sessions, not other SSH sessions over Tailscale.
-   Recordings are streamed from the destination node of the Tailscale SSH connection, and cannot be configured to be streamed from the source node.
-   Session recording only records outputs from an SSH session, not inputs.
-   All outputs are logged, including any sensitive data that might be in the output.
```



### File: 1250-support-options.md

```markdown
# Support options

Encountering an issue with Tailscale? We're here and ready to help!

## [Immediate Assistance](#immediate-assistance)

Day or night, browse or search our [documentation](https://tailscale.com/kb) to find the fastest answers. Enter a term or browse by topic. We most likely have a topic for you.

## [Email Support](#email-support)

We offer [email support](https://tailscale.com/contact/support) in English for all customers between 9am-6pm Eastern Standard Time, Monday through Friday.

You can submit a ticket through our [support form](https://tailscale.com/contact/support#support-form) while logged in to your account in the browser. You can find the form by either selecting **Support** in the upper right-hand corner of the Tailscale [admin console](https://login.tailscale.com/admin) or by going directly to [https://tailscale.com/contact/support](https://tailscale.com/contact/support).

If you don't see an email response from us, be sure to check your spam and junk folders.

## [Priority Support](#priority-support)

Priority support is included in all [Premium and Enterprise plans, and the legacy Business plan](https://tailscale.com/pricing). With priority support, requests from Premium and Enterprise customers are promptly triaged and moved to the front of the queue, where our team will get back to you as soon as possible.

We also offer add-on support packages, as detailed in our [Service Level Agreement](https://tailscale.com/sla). If you're in need of a guaranteed SLA or 24/7 emergency responses, [contact sales](https://tailscale.com/contact/sales) to discuss our additional support packages.

## [Severity Definitions](#severity-definitions)

We use the following definitions to triage incoming support requests.

**Severity Level**

**Description**

Sev 1
Critical

There is a Full Outage, a Personal Data Breach (defined in our DPA), or other major security breach.

Ex: Tailscale is not operational for your entire company.

Ex: There is a security breach we need to know about immediately.

Sev 2
High

There is a Partial Outage of a core service, feature or functionality, or an attempted security breach.

Ex: SCIM is not operational.

Sev 3
Normal

There is a Partial Outage of a non-core or non-essential service, feature or functionality.

Ex: A user or subset of users are experiencing poor latency or disconnects when using Tailscale.

Sev 4
Low

A non-material support item, and there is no Outage (Full or Partial).

Ex: configuration help requests; minor UX bugs.

## [Exclusions](#exclusions)

Our Support team is pretty incredible, and we will do our best to resolve any issue you run into, but we can't do everything. The following are outside the scope of support that we provide:

-   Writing custom scripts, tools, or resources
-   Virus or malware infections
-   Spam protection
-   System and server administration activities
-   Routine product maintenance including data backup, cleaning disk space, and configuring log rotation
-   Support for any integrations or third-party services. Check your terms of service with us for what these mean.
-   Self-hosted coordination servers, including Headscale
-   General issues with your internet service or internet service provider (ISP)
-   Devices behind a subnet router
-   General computer or device support or maintenance
```



### File: 1255-log-streaming.md

```markdown
# Log streaming

Configuration audit log streaming is available for [the Personal, Personal Plus, and Enterprise plans](https://tailscale.com/pricing).

Network flow log streaming is available for [the Enterprise plan](https://tailscale.com/pricing).

Log streaming lets you collect and send [configuration audit logs](https://tailscale.com/kb/1203/audit-logging) or [network flow logs](https://tailscale.com/kb/1219/network-flow-logs) about your Tailscale network (known as a tailnet) into various systems for collection and analysis.

You can use `User-Agent: TailscaleLogStreamPublisher` to identify Tailscale traffic.

## [Supported integrations](#supported-integrations)

Tailscale supports different ways of integrating log streaming.

### [SIEM integrations](#siem-integrations)

You can stream logs into a Security information and event management ([SIEM](https://tailscale.com/learn/security-information-and-event-management)) system to help detect and respond to security threats, set up alerting and monitoring rules, and the like.

We support log streaming integrations for the following SIEM systems:

-   [Axiom](https://axiom.co)
-   [Cribl](https://cribl.io)
-   [Datadog](https://www.datadoghq.com)
-   [Elasticsearch Logstash](https://www.elastic.co/logstash), through a [data stream](https://www.elastic.co/guide/en/elasticsearch/reference/current/data-streams.html)
-   [Panther](https://panther.com)
-   [Splunk](https://www.splunk.com), through an [HTTP Event Collector](https://dev.splunk.com/enterprise/docs/devtoolshttpeventcollector)
-   [Additional SIEM systems](#additional-siem-systems)

### [Amazon S3 and S3-compatible services](#amazon-s3-and-s3-compatible-services)

You can stream your logs to Amazon S3 and S3-compatible services for various cloud storage providers.

We support log streaming integrations for sending logs to the following S3 bucket types:

-   [Amazon S3](https://docs.aws.amazon.com/AmazonS3/latest/userguide/logging-with-S3.html)
-   S3-compatible services, including:
    -   [Storj](https://www.storj.io/)
    -   [Wasabi](https://wasabi.com/)

### [Other integrations types](#other-integrations-types)

Additional integrations that you can use for log streaming include:

-   [Private endpoints](#private-endpoints)
-   [Vector](https://vector.dev)

## [Prerequisites](#prerequisites)

-   You need an endpoint and credentials for either your SIEM integration or S3 cloud storage provider. Consult your vendor's documentation for how to get an endpoint and API credentials.
-   You need to be an [Owner, Admin, Network admin, or IT admin](https://tailscale.com/kb/1138/user-roles) to add, edit, and delete a streaming destination.

## [Configuration log streaming](#configuration-log-streaming)

Configuration audit log streaming is available for [the Personal, Personal Plus, and Enterprise plans](https://tailscale.com/pricing).

### [Add configuration log streaming](#add-configuration-log-streaming)

[SIEM integrations](https://tailscale.com/kb/1255/log-streaming?tab=siem+integrations)[Amazon S3](https://tailscale.com/kb/1255/log-streaming?tab=amazon+s3)[S3-compatible](https://tailscale.com/kb/1255/log-streaming?tab=s3-compatible)

1.  Open the [Configuration logs](https://login.tailscale.com/admin/logs) page of the admin console.
2.  Select **Start streaming**.
3.  In the **Start streaming configuration logs** dialog:
    1.  Select a SIEM destination.
    2.  For **URL**, enter your SIEM endpoint. The endpoint URL must use the HTTPS protocol, and there is no restriction on which port is used. Splunk's HTTP Endpoint Connectors require an endpoint ending with `/services/collector/event`. Elasticsearch's data streams require an endpoint ending with `<stream_id>/_bulk?pretty`.
    3.  If your SIEM system requires a value for **Username**, enter the SIEM username.
    4.  For **Token**, enter the SIEM API token.
4.  Select **Start streaming**.

![The 'Start streaming configuration logs' dialog. Listing several available destinations.](/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fstream-configuration-logs.3c575276.png&w=750&q=75)

Check your SIEM system to verify you are successfully streaming from your tailnet.

Depending on network conditions, there may be a delay before you can see the log streaming appear in your third-party tools.

### [Edit a configuration log streaming destination](#edit-a-configuration-log-streaming-destination)

You can change the information for passing your logs to your preferred streaming destination.

1.  Open the [Configuration logs](https://login.tailscale.com/admin/logs) page of the admin console.
2.  For the system that you want to update, select the **Action** dropdown, then select **Edit**.
3.  Update the values as needed.
4.  Select **Save changes**.

If you are editing a log streaming destination for an Amazon S3 bucket, you can update the **Role ARN** field (the Amazon resource name) if the resource name already belongs to the specified AWS account. If the role does not belong to the AWS account, you must delete the log streaming destination in the admin console and create a new one.

### [Delete a configuration log streaming destination](#delete-a-configuration-log-streaming-destination)

1.  Open the [Configuration logs](https://login.tailscale.com/admin/logs) page of the admin console.
2.  For the integration that you want to delete, select the **Action** dropdown, then select **Delete**.
3.  In the confirmation dialog, select **Delete**.

## [Network log streaming](#network-log-streaming)

Network flow log streaming is available for [the Enterprise plan](https://tailscale.com/pricing).

### [Add a network log streaming destination](#add-a-network-log-streaming-destination)

[SIEM integrations](https://tailscale.com/kb/1255/log-streaming?tab=siem+integrations)[Amazon S3](https://tailscale.com/kb/1255/log-streaming?tab=amazon+s3)[S3-compatible](https://tailscale.com/kb/1255/log-streaming?tab=s3-compatible)

1.  If you haven't already, [enable Network flow logs](https://tailscale.com/kb/1219/network-flow-logs#enable-network-flow-logs) for your tailnet.
2.  Open the [Network flow logs](https://login.tailscale.com/admin/logs/network) page of the admin console.
3.  Select **Start streaming**.
4.  In the **Start streaming network logs** dialog:
    1.  Select a SIEM destination.
    2.  For **URL**, enter your SIEM endpoint. The endpoint URL must use the HTTPS protocol, and there is no restriction on which port is used. Splunk's HTTP Endpoint Connectors require an endpoint ending with `/services/collector/event`. Elasticsearch's data stream endpoints end with `<stream_id>/_bulk?pretty`.
    3.  If your SIEM system requires a value for **Username**, enter the SIEM username.
    4.  For **Token**, enter the SIEM API token.
5.  Select **Start streaming**.

![The 'Start streaming network logs' dialog. Listing several available destinations.](/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fstream-network-logs.25f4eb29.png&w=750&q=75)

Check your SIEM system to verify you are successfully streaming from your tailnet.

Depending on network conditions, there may be a delay before you can see the log streaming appear in your third-party tools.

### [Edit a network log streaming destination](#edit-a-network-log-streaming-destination)

You can change the information for passing your logs to your preferred streaming destination.

1.  Open the [Network flow logs](https://login.tailscale.com/admin/logs/network) page of the admin console.
2.  For the system that you want to update, select the **Action** dropdown, then select **Edit**.
3.  Update the values as needed.
4.  Select **Save changes**.

If you are editing a log streaming destination for an Amazon S3 bucket, you can update the **Role ARN** field (the Amazon resource name) if the resource name already belongs to the specified AWS account. If the role does not belong to the AWS account, you must delete the log streaming destination in the admin console and create a new one.

### [Delete a network log streaming destination](#delete-a-network-log-streaming-destination)

1.  Open the [Network flow logs](https://login.tailscale.com/admin/logs/network) page of the admin console.
2.  For the integration that you want to delete, select the **Action** dropdown, then select **Delete**.
3.  In the confirmation dialog, select **Delete**.

## [Private endpoints](#private-endpoints)

Log streaming can publish logs to a host that is directly reachable over the public internet, in which case the endpoint must use HTTPS for security. Alternatively, log streaming can publish logs to a private host that is not directly reachable over the public internet by utilizing Tailscale for connectivity. Plain HTTP may be used since the underlying transport is secured by Tailscale using WireGuard.

Use of log streaming to a private host is detected automatically based on the host specified in the endpoint URL.

![An example of the URL used for private endpoints.](/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fprivate-endpoint-url.b93a54fd.png&w=828&q=75)

The host must reference a node within your tailnet and can be any of the following:

-   The name of a Tailscale node (for example, `splunk`).
-   The [fully-qualified domain name](https://tailscale.com/kb/1081/magicdns#fully-qualified-domain-names-vs-machine-names) of a Tailscale node (for example, `splunk.yak-bebop.ts.net`).
-   The IPv6 address of a Tailscale node (for example, `fd7a:115c:a1e0:ab12:0123:4567:89ab:cdef`).

Only IPv6 addresses are supported for log streaming. IPv4 addresses are not supported for log streaming because Tailscale uses CGNAT for IPv4 addresses assigned to nodes within a single tailnet. This can present an issue because IPv4 addresses can be reused across a tailnet. IPv6 addresses are not reused, and hostnames will always route to the correct node.

Log streaming to a private endpoint operates by [sharing](https://tailscale.com/kb/1084/sharing) your node into a Tailscale-managed tailnet, where a Tailscale-managed node will publish logs directly to your node. This requires both sharing your node out to Tailscale's `logstream` tailnet, and modifying your [tailnet policy file](https://tailscale.com/kb/1018/acls) to support incoming traffic to your node from the `logstream@tailscale` user.

When adding or updating an endpoint that points to a private host, the control plane may need to share your node and/or update the tailnet policy file on your behalf. If additional configuration changes are needed, a follow-up dialog box will ask you for permission to perform the necessary actions. Audit log events will be generated for these operations and the actions will be attributed to you.

![The 'Grant share access to private host' confirmation dialog to share the node or update the tailnet policy file.](/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fprivate-endpoint-confirmation.f857e999.png&w=828&q=75)

After adding or updating the endpoint, the node will be listed on the [Machines](https://login.tailscale.com/admin/machines) page of the admin console as having been shared out to the `logstream@tailscale` user. Also, the tailnet policy file will be modified with a rule similar to the following:

```json
{
  // Private log streaming enables audit and network logs to be directly
  // uploaded to a node in your tailnet without exposing it to the public internet.
  // This access rule provides access for a Tailscale-managed node to upload logs
  // directly to the specified node.
  // See https://tailscale.com/kb/1255/log-streaming/#private-endpoints
  "action": "accept",
  "src":    ["logstream@tailscale"],
  "dst":    ["[nodeAddressV6]:port"],
}
```

You can use the [visual policy editor](https://tailscale.com/kb/1550/visual-editor) to manage your tailnet policy file. Refer to the [visual editor reference](https://tailscale.com/kb/1587/visual-editor-reference) for guidance on using the visual editor.

where:

-   `nodeAddressV6` is the IPv6 address of the Tailscale node.
-   `port` is the service port for the log streaming system.

The IPv6 address is specified as the log stream publisher that can communicate with your node over v6 of the Internet protocol.

Only IPv6 addresses are supported for log streaming. IPv4 addresses are not supported for log streaming because Tailscale uses CGNAT for IPv4 addresses assigned to nodes within a single tailnet. This can present an issue because IPv4 addresses can be reused across a tailnet. IPv6 addresses are not reused, and hostnames will always route to the correct node.

Since log streaming to a private host may require the ability to share nodes and the ability to update the tailnet policy file, only the [Admin](https://tailscale.com/kb/1138/user-roles#admin) and [Network admin](https://tailscale.com/kb/1138/user-roles#network-admin) roles have sufficient permissions to unilaterally make use of private endpoints. The [IT admin](https://tailscale.com/kb/1138/user-roles#it-admin) has the ability to share nodes, but lacks the ability to update the tailnet policy file. An IT admin can still make use of private endpoints, but requires either an Admin or Network admin to manually update the tailnet policy file before logs can start streaming.

If your tailnet is configured to use [GitOps for management of Tailscale](https://tailscale.com/kb/1204/gitops-acls), you will receive an error when Tailscale attempts to update your tailnet policy file to support incoming traffic from the `logstream@tailscale` user. To avoid this error, first use GitOps to add an [access rule](https://tailscale.com/kb/1337/policy-syntax#acls) that allows incoming traffic from the `logstream@tailscale` user to the node that you use for the private endpoint, and then add your private endpoint as the log streaming URL.

## [Additional SIEM systems](#additional-siem-systems)

We strive to support many common SIEM systems used by our customers, but we cannot support all the commercial and open-source SIEM and logging tools available. Some SIEM systems have [Splunk HTTP Event Collector (Splunk HEC)](https://dev.splunk.com/enterprise/docs/devtoolshttpeventcollector) compatible endpoints such as [DataSet by SentinelOne](https://app.scalyr.com/solutions/splunk-hec). If your SIEM supports Splunk HEC, configure [configuration audit log streaming](#configuration-log-streaming) and [network flow log streaming](#network-log-streaming) per the instructions above to stream logs directly to your SIEM as if it were Splunk.

If we do not support your SIEM system, you can use [Vector](https://vector.dev), an open-source high-performance observability data pipeline, to ingest log data from Tailscale via Vector's Splunk HEC support and deliver it to Vector's many supported SIEM systems, called "sinks" in Vector's terminology. Vector supports a number of [sinks](https://vector.dev/docs/reference/configuration/sinks) such as object storage systems, messaging queuing systems, Grafana Loki, New Relic, and more.

### [Vector deployment](#vector-deployment)

To use Vector with log streaming from Tailscale:

1.  Follow Vector's [deployment guide](https://vector.dev/docs/setup/deployment) to deploy a machine running Vector to your infrastructure.
2.  Configure Vector's [Splunk HTTP Event Collector (HEC) source](https://vector.dev/docs/reference/configuration/sources/splunk_hec) to allow Tailscale to send log data to Vector.
3.  Configure the [Vector sink](https://vector.dev/docs/reference/configuration/sinks) for your SIEM as the destination for the log streaming data.
4.  Configure [configuration audit log streaming](#configuration-log-streaming) and [network flow log streaming](#network-log-streaming) per the instructions above to stream logs to your Vector instance, ideally using [private endpoints](#private-endpoints).

### [Vector example configuration](#vector-example-configuration)

The Vector configuration below receives data via the `splunk_hec` source and outputs data to the `file` sink:

```yaml
# /etc/vector/vector.yaml

sources:
  splunk_hec:
    type: "splunk_hec"
    address: "100.x.y.z:8088" # Your Vector Tailscale device's IP or hostname
    valid_tokens:
      - "YOUR TOKEN"

sinks:
  file_sink:
    type: "file"
    inputs:
      - "splunk_hec"
    path: "/vector-data-dir/tailscale-%Y-%m-%d.log"
    encoding:
      codec: "json"
```
```



### File: 1259-domain-ownership.md

```markdown
# Domain ownership

When you create your Tailscale network, also known as a tailnet, your user domain becomes part of your Tailscale identity.

**The guidance in this topic also applies for Tailscale accounts based on GitHub organizations, GitHub personal accounts, and for single-user tailnets based on email/user identity.**

Ensure that you maintain control of your domain, to prevent malicious takeover of your tailnet.

## [How your domain is used](#how-your-domain-is-used)

Tailscale requires you to show ownership and control of a user's domain when signing up with a [custom OIDC identity provider](https://tailscale.com/kb/1240/sso-custom-oidc), or when requesting help from our support team for certain issues. Depending on your request, we will ask you to do one of the following actions:

-   Set DNS TXT records.
-   Respond to a confirmation email sent to a `*@example.com` email address. For example, an email sent from Tailscale support to the owner admin of a tailnet when another user of the tailnet is requesting some action in the tailnet.
-   Set up a WebFinger endpoint.

For verification of [GitHub organization](https://docs.github.com/en/get-started/learning-about-github/types-of-github-accounts#organization-accounts), the owner of the tailnet must also be an admin of the GitHub organization.

Once your tailnet is created, your domain is always associated with the tailnet, and you need to maintain control over and use of your domain for the lifetime of your tailnet.

## [Mitigating tailnet risk from a malicious takeover](#mitigating-tailnet-risk-from-a-malicious-takeover)

To help mitigate the impact of a malicious actor gaining control of your domain, there are several settings you can use with your tailnet:

-   Enable [device approval](https://tailscale.com/kb/1099/device-approval) so that an admin can review and approve new devices before they can join the tailnet.
-   Enable [user approval](https://tailscale.com/kb/1239/user-approval) so that an admin can review and approve new users before they can join the tailnet.
-   Use [Tailnet Lock](https://tailscale.com/kb/1226/tailnet-lock) to verify that no device is added to your tailnet without being signed by a trusted device already in your tailnet.

For general guidance on securing your tailnet, refer to [Best practices to secure your tailnet](https://tailscale.com/kb/1196/security-hardening).

## [If you no longer use your domain](#if-you-no-longer-use-your-domain)

If you need to change domain names or relinquish an old name and move to a new name, [contact support](https://tailscale.com/contact/support?type=domainchange) so we can rename the tailnet for you.

If you delete your domain, your tailnet is not automatically deleted. If you want to delete your tailnet, you need to explicitly [delete your tailnet](https://tailscale.com/kb/1237/delete-tailnet).
```



### File: 1277-key-prefixes.md

```markdown
# Key prefixes

Tailscale uses prefixes as part of the ID for keys. The prefix starts with `tskey-` and is followed by the key type. For example, when you create a Tailscale API access token, the prefix is `tskey-api`, resulting in a key ID in the form of:

`tskay-api-abcDEF1CNTRL-091234567890ABCDEF`

The type of key prefixes are:

Key prefix

Description

`tskey-api`

The key is a [Tailscale API](https://tailscale.com/kb/1101/api) access token.

`tskey-auth`

The key is a [pre-authentication key](https://tailscale.com/kb/1085/auth-keys).

`tskey-client`

The key is a Tailscale [OAuth client](https://tailscale.com/kb/1215/oauth-clients) key.

`tskey-scim`

The key is a [System for Cross-domain Identity Management](https://tailscale.com/learn/what-is-scim) (SCIM) key.

`tskey-webhook`

The key is a [webhook](https://tailscale.com/kb/1213/webhooks) key.

Note that all Tailscale-generated keys and secrets are case-sensitive. For more information about keys and secrets in general, refer to [Key and secret management](https://tailscale.com/kb/1252/key-secret-management).
```



### File: 1292-pikvm.md

```markdown
# Access PiKVM from anywhere

PiKVM is a Raspberry Pi based KVM (keyboard, video, and mouse) over IP solution. It lets you connect to a computer remotely and use it as if you were in front of it. This guide shows you how to set up Tailscale on PiKVM.

To find out more about PiKVM, visit [pikvm.org](https://pikvm.org). We also have a video guide on how to set up Tailscale on PiKVM.

## [Prerequisites](#prerequisites)

-   A PiKVM device or a Raspberry Pi with PiKVM installed.
    -   The PiKVM project [recommends](https://pikvm.org/faq/) a Pi 4. The Pi 5 provides little to no performance improvement for this use case.
-   [A Tailscale account](https://login.tailscale.com/start)\-the free [Personal plan](https://tailscale.com/pricing) includes all you need to get started.

## [Install Tailscale](#install-tailscale)

1.  Access your PiKVM via the web interface and open the web terminal.

    ![The pikvm web interface. Highlighting the 'Terminal' option.](/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fpikvm-web-terminal.bef01a95.png&w=1920&q=75)

2.  Elevate to root.

    ```shell
    # default password is 'root'
    su -
    ```

3.  Enable read-write mode.

    ```shell
    rw
    ```


If you reboot your PiKVM during this process, you will need to re-enable read-write mode.

4.  Install the `tailscale-pikvm` package.

    ```shell
    pacman -Sy tailscale-pikvm
    ```


We recommend the `tailscale-pikvm` package as a result of [this issue](https://github.com/tailscale/tailscale/issues/2934)

5.  Enable and start the Tailscale service.

    ```shell
    systemctl enable --now tailscaled
    ```

6.  Log in to Tailscale.

    For more information on the available login options, see our [Command Reference](https://tailscale.com/kb/1080/cli#up).

    ```shell
    tailscale up
    ```

7.  (Optional) Enable [Tailscale SSH](https://tailscale.com/kb/1193/tailscale-ssh).

    ```shell
    tailscale set --ssh
    ```

8.  Revert to read-only mode.

    ```shell
    ro
    ```


You might prefer to disable key expiry on your subnet nodes to avoid having to periodically reauthenticate. Refer to [key expiry](https://tailscale.com/kb/1028/key-expiry) for more information about machine keys and how to disable their expiry. If you use [tags](https://tailscale.com/kb/1068/tags), [key expiry is disabled by default](https://tailscale.com/kb/1068/tags#key-expiry).

## [Access your PiKVM device](#access-your-pikvm-device)

Once you have installed Tailscale on your PiKVM device, you can access it from anywhere using the Tailscale network.

Open the [Machines](https://login.tailscale.com/admin/machines) page of the admin console and find your PiKVM device.

You can access the web interface by visiting `https://<your-pikvm>.<your-tailnet>.ts.net`. For example, if your PiKVM device is named `pikvm` and your Tailscale network is named `pango-lin`, you would visit `https://pikvm.pango-lin.ts.net`.

### [Use Tailscale Serve to access your PiKVM device](#use-tailscale-serve-to-access-your-pikvm-device)

You can set up Tailscale Serve to proxy your PiKVM's web interface. This provides a valid TLS certificate for your PiKVM device, preventing your browser from displaying a security warning.

To setup Tailscale Serve, follow the instructions below. You can also find more information on our [Use Tailscale Funnel and Serve](https://tailscale.com/kb/1247/funnel-examples) topic.

A Tailscale Serve server can only be access over your tailnet. It is not accessible from the public internet. Using [Tailscale Funnel](https://tailscale.com/kb/1223/funnel) would open your PiKVM device to the public internet, which is not recommended.

```shell
tailscale serve --bg https+insecure://localhost:443
```

After running the command above, you can access your PiKVM device, as before, by visiting `https://<your-pikvm>.<your-tailnet>.ts.net`. The difference is that the connection is proxied through your Tailscale Serve server, providing a valid TLS certificate for your PiKVM device.

The first request to your PiKVM device may take a few seconds to complete. This is because Tailscale Serve needs to fetch a valid TLS certificate for your PiKVM device. Subsequent requests will be much faster.

### [Use your PiKVM node as an exit node or subnet router](#use-your-pikvm-node-as-an-exit-node-or-subnet-router)

Now that PiKVM is in your tailnet, you can configure it to do other useful things, such as functioning an [exit node](https://tailscale.com/kb/1103/exit-nodes) or a [subnet router](https://tailscale.com/kb/1019/subnets).
```



### File: 1293-cloud-init.md

```markdown
# Install Tailscale with cloud-init

Cloud-init is a standard mechanism for initializing new server images, typically with a cloud provider. The project was started by Canonical, and is now supported by [multiple operating systems and most major Linux distributions](https://cloudinit.readthedocs.io/en/latest/reference/distros.html) and is available on [nearly all public cloud providers](https://cloudinit.readthedocs.io/en/latest/reference/datasources.html#datasources-supported). See our video guide below on how to get started with cloud-init and Tailscale.

This document only touches on a subset of cloud-init's capabilities. In particular, it provides a template to direct a new machine to automatically join a tailnet on first boot with a "cloud config" file. This kind of file is utilized in the user data portion of the cloud-init process. The specifics of how to provide this file vary between cloud providers; we've provided some links in the [vendor-specific documentation](#vendor-specific-cloud-init-documentation) section.

Because of cloud-init's connection to providers of major cloud infrastructure, it's typically associated with use cases involving the automated instantiation of many machines. Indeed, this document may be of assistance to users who are spinning up many nodes and want them each to join a tailnet without manual configuration.

This cloud-init configuration may also be helpful for users who are only creating a small number of nodes, and want to be able to interact with those machines over Tailscale as soon as they are available. For example, a user may be creating a machine on a public VPS to provide an exit node or a service available over the tailnet. Using cloud-init can make the machine accessible over Tailscale immediately, without having to first set up SSH and log in to do initial configuration.

We've developed a [utility called Tailgraft](https://github.com/tailscale-dev/tailgraft) to automate the use of cloud config files on Raspberry Pi machines. Read more in the [blog post announcing the tool](https://tailscale.dev/blog/tailgraft).

All of the Tailscale installation and configuration occurs in a block called `runcmd` that specifies commands to run towards the end of the first boot process. If you've already got a cloud config file, you can add this block to the end of it, or it can serve as the entire file.

As indicated in the template, this usage requires an [auth key](https://tailscale.com/kb/1085/auth-keys). You can generate an auth key from the [Keys](https://login.tailscale.com/admin/settings/keys) page of the admin console, or through an authenticated instance of the [get-authkey utility](https://tailscale.com/kb/1215/oauth-clients#get-authkey-utility).

## [Cloud config sample template](#cloud-config-sample-template)

```markup
#cloud-config
# The above header must generally appear on the first line of a cloud config
# file, but all other lines that begin with a # are optional comments.

runcmd:
  # One-command install, from https://tailscale.com/download/
  - ['sh', '-c', 'curl -fsSL https://tailscale.com/install.sh | sh']
  # Set sysctl settings for IP forwarding (useful when configuring an exit node)
  - ['sh', '-c', "echo 'net.ipv4.ip_forward = 1' | sudo tee -a /etc/sysctl.d/99-tailscale.conf && echo 'net.ipv6.conf.all.forwarding = 1' | sudo tee -a /etc/sysctl.d/99-tailscale.conf && sudo sysctl -p /etc/sysctl.d/99-tailscale.conf" ]
  # Generate an auth key from your Admin console
  # https://login.tailscale.com/admin/settings/keys
  # and replace the placeholder below
  - ['tailscale', 'up', '--auth-key=tskey-abcdef1432341818']
  # (Optional) Include this line to make this node available over Tailscale SSH
  - ['tailscale', 'set', '--ssh']
  # (Optional) Include this line to configure this machine as an exit node
  - ['tailscale', 'set', '--advertise-exit-node']
```

## [Vendor-specific cloud-init documentation](#vendor-specific-cloud-init-documentation)

This list of vendors is not exhaustive; if you don't see your preferred cloud provider here, try searching its documentation for "cloud-init" to see how to enter your cloud config data. The summaries here are provided as a starting point, but more information is available at each of the links below.

-   [Amazon EC2](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/user-data.html)
    Add the cloud config info in the **User data** field under **Advanced details** when launching a new instance from the web dashboard, or provide a file path with the `--user-data` flag of the `aws` command line tool.
-   [Google Cloud](https://cloud.google.com/container-optimized-os/docs/how-to/create-configure-instance)
    Specify a cloud config file path with the `--metadata-from-file` flag and the `user-data` field of the `gcloud` command line tool.
-   [Microsoft Azure](https://learn.microsoft.com/en-us/azure/virtual-machines/linux/using-cloud-init)
    Specify a cloud config file path as a parameter to the `--custom-data` flag of the `az` command line tool.
-   [Digital Ocean](https://docs.digitalocean.com/products/droplets/how-to/provide-user-data/#providing-user-data)
    Open **Advanced Options** from the Droplet creation web dashboard and provide cloud config info after selecting **Add Initialization scripts**, or specify a path to the `--user-data` or `--user-data-file` flags of the `doctl` command line tool.
-   [Vultr](https://www.vultr.com/docs/how-to-deploy-a-vultr-server-with-cloudinit-userdata)
    Add cloud config data by checking the **Enable Cloud-Init User-Data** box in the **Additional Features** section of the deployment page, or provide the data itself as an argument to the `--userdata` field of the `vultr-cli` command line tool.
-   [Linode](https://www.linode.com/docs/products/compute/compute-instances/guides/metadata/#add-user-data)
    Provide cloud config data in the **Add User Data** section of the **Create Linode** tool, or provide the base64-encoded cloud config data as an argument to the `--metdata.user_data` flag of the `linode-cli` command line tool.
-   [Oracle Cloud](https://docs.oracle.com/en-us/iaas/Content/ContEng/Tasks/contengusingcustomcloudinitscripts.htm)
    Provide cloud config data or a cloud config file from the web console by selecting **Initialization Script** in the **Advanced Options** section of the **Custom Create** workflow, or provide the base64-encoded cloud config data as a value with the `user-data` key to the `--node-metadata` flag of the `oci` command line tool.
-   [Hetzner](https://community.hetzner.com/tutorials/basic-cloud-config)
    Provide cloud config data in the **Cloud config** text box in the **Cloud Console** creation flow.
```



### File: 1300-production-best-practices.md

```markdown
# Production best practices

[

#### Deployment checklist

Your checklist to ensure a successful Tailscale deployment.



](https://tailscale.com/kb/1344/deployment-checklist)[

#### Key and secret management

Manage the various types of keys and secrets for your tailnet.



](https://tailscale.com/kb/1252/key-secret-management)[

#### Scanning for exposed Tailscale secrets

Find out how Tailscale partners scan for exposed Tailscale secrets and provide notifications to help prevent fraudulent access.



](https://tailscale.com/kb/1301/secret-scanning)[

#### Admin account with passkey login

Proactively set up an admin user that can log in to your tailnet with a passkey, to mitigate against a future SSO lockout.



](https://tailscale.com/kb/1341/tailnet-passkey-admin)[

#### Performance best practices

Get the most performance out of your Tailscale deployment.



](https://tailscale.com/kb/1320/performance-best-practices)[

#### AWS reference architecture

Deploy Tailscale to Amazon Web Services (AWS) with best practices, security, and production readiness in mind.



](https://tailscale.com/kb/1296/aws-reference-architecture)[

#### Azure reference architecture

Deploy Tailscale to Microsoft Azure with best practices, security, and production readiness in mind.



](https://tailscale.com/kb/1314/azure-reference-architecture)[

#### Google Cloud Platform reference architecture

Deploy Tailscale to Google Cloud Platform (GCP) with best practices, security, and production readiness in mind.



](https://tailscale.com/kb/1510/gcp-reference-architecture)
```



### File: 1307-nas.md

```markdown
# Connect to network attached storage (NAS)

Tailscale makes it easy to securely connect to your [Network-Attached Storage (NAS)](https://en.wikipedia.org/wiki/Network-attached_storage) devices over WireGuard®. There are different levels of official or community support depending on the platform.

Tailscale is completely free for most personal uses, including accessing your NAS. In general, [install Tailscale](https://tailscale.com/kb/1031/install-linux) on the NAS and follow the steps to authorize it. More specific instructions are available for some vendors as described below.

## [Synology](#synology)

Tailscale is available officially as an app in the Synology Package Center, including an easy-to-use web UI for configuration. Refer to our [Tailscale on Synology](https://tailscale.com/kb/1131/synology) topic for details.

## [QNAP](#qnap)

Tailscale is available officially as an app in the QNAP App Center, including an easy-to-use web UI for configuration. Refer to our [Tailscale on QNAP](https://tailscale.com/kb/1273/qnap) topic for details.

## [TrueNAS SCALE](#truenas-scale)

Tailscale is available officially as an app in the TrueNAS SCALE software. Refer to our [Tailscale on TrueNAS SCALE](https://tailscale.com/kb/1483/truenas-scale) topic for details.

## [Unraid](#unraid)

Tailscale is available officially as an app in the Unraid software. Refer to our [Tailscale on Unraid](https://tailscale.com/kb/1478/unraid) topic for details.

## [FreeNAS](#freenas)

FreeBSD support for Tailscale is community-maintained, and the client is available in [FreshPorts](https://www.freshports.org/security/tailscale).
```



### File: 1312-serve.md

```markdown
# Tailscale Serve

The CLI commands for both [Tailscale Funnel](https://tailscale.com/kb/1311/tailscale-funnel) and [Tailscale Serve](https://tailscale.com/kb/1242/tailscale-serve) have changed in the 1.52 version of the Tailscale client. If you've used Funnel or Serve in previous versions, we recommend reviewing the CLI documentation.

Tailscale Serve lets you route traffic from other devices on your Tailscale network (known as a tailnet) to a local service running on your device. You can think of this as sharing the service, such as a website, with the rest of your tailnet. This page provides information about how Serve works and how to get started with it in your tailnet. For more specific use cases, refer to [Tailscale Serve examples](https://tailscale.com/kb/1313/serve-examples).

If you'd like to share local services publicly over the internet, use [Tailscale Funnel](https://tailscale.com/kb/1223/funnel) instead.

## [Get started with Serve](#get-started-with-serve)

Tailscale Serve requires you to enable HTTPS certificates in your tailnet.

Additionally, keep in mind that [access control rules](https://tailscale.com/kb/1393/access-control) apply to Serve just like any other service. If you have access control rules that restrict access to certain devices or users, those rules will also apply to the services you're sharing with Serve.

If you don't have HTTPS enabled in your tailnet, the Tailscale CLI command [`tailscale serve`](https://tailscale.com/kb/1080/cli) provides an interactive web UI that prompts you to allow Tailscale to enable HTTPS on your behalf.

The `serve` command prompts you as needed and sends you to a web consent page to enable any unmet requirements.

![The 'Start using serve' web consent page](/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fenable-serve.835c9b8e.png&w=750&q=75)

**Tailscale Funnel** is enabled by default. If you don't plan to use [Tailscale Funnel](https://tailscale.com/kb/1223/funnel) on the device, you can turn it off.

## [Run Tailscale Serve](#run-tailscale-serve)

If you run the [`tailscale serve`](https://tailscale.com/kb/1080/cli) command and your tailnet isn't properly configured to use Tailscale Serve, it presents a login server URL that you can follow to enable the feature.

Tailscale Serve lets you serve local directories, files, plain text, or local ports with other devices in your tailnet. For example, you can proxy requests to a web server running at `http://127.0.0.1:3000` using the following command:

```shell
tailscale serve 3000
```

Run `tailscale serve --help` for more examples.

The CLI opens a foreground session that displays the status of what it's serving and the URL you can use to access your server:

```shell
tailscale serve 3000
Available within your tailnet:
https://amelie-workstation.pango-lin.ts.net

|-- / proxy http://127.0.0.1:3000

Press Ctrl+C to exit.
```

## [Identity headers](#identity-headers)

Serve traffic includes identity headers when serving traffic from your tailnet using Tailscale Serve. Funnel traffic, which is publicly available, does not include identity headers.

When you use Serve to proxy traffic to a local service running on your device, it adds a few Tailscale identity headers to the request sent to your backend. The destination server can use these headers to identify the Tailscale user associated with the request.

-   `Tailscale-User-Login`: Filled with the requester's login name (for example, `alice@example.com`).
-   `Tailscale-User-Name`: Filled with the requester's display name (for example, `Alice Architect`).
-   `Tailscale-User-Profile-Pic`: Filled with the requester's profile picture URL, if their identity provider provides one (for example, `https://example.com/photo.jpg`)..

If the values contain non-ASCII values, Tailscale might use [RFC2047](https://www.rfc-editor.org/rfc/rfc2047) "Q" encoding (for example, `=?utf-8?q?Ferris_B=C3=BCller?=`).

These identity headers are not populated for traffic originating from [tagged devices](https://tailscale.com/kb/1068/tags).

You can use the identity headers with a custom backend or third-party services that offer authentication proxy authentication, such as [Grafana](https://grafana.com/docs/grafana/latest/setup-grafana/configure-security/configure-authentication/auth-proxy/#configure-auth-proxy-authentication).

Although identity headers are only populated for tailnet traffic, this includes traffic from external users who have accepted a share of your device. For example, if you share a device with a friend and have it configured with a Serve proxy, Tailscale populates the identity headers when your friend visits the Serve URL.

When you use the identity headers to authenticate to a backend service, it's best practice to only have the service listen on localhost. Otherwise, any user that can call your service directly (rather than with the Serve URL) could trivially provide their own values for these HTTP headers. By listening only on localhost, this limits tampering to only other services running on the Serve device, and not anyone on your LAN or tailnet.

## [App capabilities header](#app-capabilities-header)

Serve traffic can be configured to forward a header with selected app capabilities of the connected user or tagged node. Similarly to identity headers, this isn't available for Funnel traffic, which is publicly available.

This feature is currently available for preview in v1.91.26 or later of the [unstable](https://tailscale.com/kb/1083/install-unstable) Tailscale client. It is planned for release in the next stable version, v1.92.0.

When you use Serve to proxy traffic to a local service running on your device, you can use the `--accept-app-caps` command line flag to specify which [app capabilities](https://tailscale.com/kb/1537/grants-app-capabilities) of a user or tagged node Serve should forward. If a user or tagged node that makes a request has been granted any of the app capabilities specified, Serve will convert them into serialised JSON and forward them in a header called `Tailscale-App-Capabilities`. For an example of what this can look like, refer to the [Tailscale Serve examples](https://tailscale.com/kb/1313/serve-examples#forward-app-capabilities-with-serve).

If the values contain non-ASCII values, Tailscale might use [RFC2047](https://www.rfc-editor.org/rfc/rfc2047) "Q" encoding (for example, `=?utf-8?q?{"example.com/cap/monitoring":[{"role":"=F0=9F=90=BF=EF=B8=8F"}]}?=`).

When you use the capability headers to authorize users or tagged nodes at a backend service, it's best practice to only have the service listen on localhost. Otherwise, any user that can call your service directly (rather than with the Serve URL) could trivially provide their own values for these HTTP headers. By listening only on localhost, this limits tampering to only other services running on the Serve machine, and not anyone on your LAN or tailnet.

## [Limitations](#limitations)

-   DNS names are restricted to your tailnet's domain name (`device-name.tailnet-name.ts.net`).
-   Because of macOS app sandbox limitations, serving files and directories is limited to the [open source variant of the Tailscale client for macOS](https://tailscale.com/kb/1065/macos-variants).

## [Troubleshooting](#troubleshooting)

Tailscale Serve requires that you [enable HTTPS](https://tailscale.com/kb/1153/enabling-https) in your tailnet to automatically provision TLS certificates for your unique [tailnet DNS name](https://tailscale.com/kb/1217/tailnet-name). If you use the interactive CLI flow as described in the [Get started with Serve](#get-started-with-serve) section, Tailscale automatically enables HTTPS if it is not already enabled.
```



### File: 1337-policy-syntax.md

```markdown
# Syntax reference for the tailnet policy file

You can write Tailscale [access control](https://tailscale.com/kb/1393/access-control) rules such as [ACLs](https://tailscale.com/kb/1018/acls) and [grants](https://tailscale.com/kb/1324/grants) in the tailnet policy file, which is expressed in [human JSON (HuJSON)](https://github.com/tailscale/hujson).

The tailnet policy file has the following top-level sections:

Section

Key

Type

Purpose

[Grants](#grants)

`grants`

Access control

Create network-level and application-level access control policies with optional route filtering.

Prefer grants for access control policies.

[ACLs](#acls)

`acls`

Access control

Create network-level access control policies.

[SSH](#ssh)

`ssh`

Access control

Specify who can use Tailscale SSH.

[Auto approvers](#autoapprovers)

`autoApprovers`

Automation

Specify who can bypass the approval process to advertise subnet routers, exit nodes, and app connectors.

[Node attributes](#nodeattrs)

`nodeAttrs`

Attributes

Apply additional attributes to devices and users.

[Postures](#postures)

`postures`

Attributes

Define device posture rules to target in access control policies.

[Tag owners](#tag-owners)

`tagOwners`

Targets

Define who can assign which tags to devices in your tailnet.

[Groups](#groups)

`groups`

Targets

Define named groups of users, devices, and subnets to target in access control policies and other definitions.

[Hosts](#hosts)

`hosts`

Targets

Define named aliases for devices and subnets.

[IP sets](#ipsets)

`ipsets`

Targets

Define named network segments to target in access control policies and other definitions.

[Tests](#tests)

`tests`

Tests

Write tests to make assertions about access policies (ACLs and network-level grants) that should not change.

[SSH test](#sshtests)

`sshTests`

Tests

Write tests to make assertions about Tailscale SSH that should not change.

You can use the [visual policy editor](https://tailscale.com/kb/1550/visual-editor) to manage your tailnet policy file. Refer to the [visual editor reference](https://tailscale.com/kb/1587/visual-editor-reference) for guidance on using the visual editor.

## [Grants](#grants)

Grants are a new, more powerful approach to access control. They let you do everything you can with ACLs, plus more. When communicating with a destination device, you can grant [application layer](https://en.wikipedia.org/wiki/Application_layer) capabilities to a set of devices or users. You can also continue to define traditional [network layer](https://en.wikipedia.org/wiki/Network_layer) capabilities. For example, you can use a grant rule to give a group of users access to port `8443` on a server, _and_ define the files they can edit on that server.

The grants system combines network layer and application layer capabilities into a shared syntax. As a result, it offers enhanced flexibility and fine-grained control over resource access. Each grant only requires a source and a destination. Because Tailscale takes a deny-by-default approach, each grant has an implied _accept_ action.


[

#### Get started with grants

Grant access control permissions across both network connections and application permissions.



](https://tailscale.com/kb/1324/grants)

## [ACLs](#acls)

Tailscale now secures access to resources using [grants](https://tailscale.com/kb/1324/grants), a next-generation access control policy syntax. Grants provide [all original ACL functionality plus additional capabilities](https://tailscale.com/kb/1467/grants-vs-acls).

ACLs will continue to work **indefinitely**; Tailscale will not remove support for this first-generation syntax from the product. However, Tailscale recommends [migrating to grants](https://tailscale.com/kb/1542/grants-migration) and using grants for all new tailnet policy file configurations because ACLs will not receive any new features.

The `acls` section lists access rules for your tailnet. Each rule grants access from a set of sources to a set of destinations.

Access rules can use [groups](#groups) and [tags](https://tailscale.com/kb/1068/tags) to grant access to pre-defined sets of users and assign service role accounts to nodes. Together, groups and tags let you build powerful [role-based access control (RBAC)](https://tailscale.com/blog/rbac-like-it-was-meant-to-be) policies.

Tailscale automatically translates all ACLs to lower-level rules that allow traffic from a source IP address to a destination IP address and port.

The following example shows an access rule with an `action`, `src`, `proto`, and `dst`.

```json
{
  "action": "accept",
  "src": [ <list-of-sources> ],
  "proto": "tcp", // optional
  "dst": [ <list-of-destinations> ],
}
```

The `acl` section of the tailnet policy supports the legacy fields `users` and `ports`, but the best practice is to use `src` (instead of `users`) and `dst` (instead of `ports`).

### [`action`](#action)

Tailscale access rules deny access by default. As a result, the only possible `action` is `accept`. `accept` allows traffic from the source (`src`) to the destination (`dst`).

### [`src`](#src)

The `src` field specifies a list of sources to which the rule applies. Each element in the list can be one of the following:

**Type**

**Example**

**Description**

Any

`*`

All traffic originating from Tailscale devices in your tailnet, any approved subnets and `autogroup:shared`. It does not allow traffic originating from non-tailscale devices (unless it is an approved route).

User

`shreya@example.com`

Includes all the provided user's devices.

[Group](#groups)

`group:<group-name>`

Includes all users in the provided group.

Tailscale IP

`100.101.102.103`

Includes only the device that owns the provided Tailscale IP. IPv6 addresses must follow the format `[1:2:3::4]:80`.

[Subnet](https://tailscale.com/kb/1019/subnets) CIDR Range

`192.168.1.0/24`

Includes any IP address within the provided subnet.

[Host](#hosts)

`my-host`

Includes the Tailscale IP address or CIDR in the `hosts` section.

[Tag](https://tailscale.com/kb/1068/tags)

`tag:production`

Includes all devices with the provided tag.

[Autogroup](#autogroups)

`autogroup:<role|property>`

Includes devices of users, destinations, or usernames with the same properties or roles.

[Autogroup (all)](#autogroups)

`autogroup:danger-all`

A special autogroup that selects all sources including those outside your tailnet.

You can optionally include the `srcPosture` field to further restrict `src` devices to the ones matching a set of [device posture conditions](https://tailscale.com/kb/1288/device-posture#device-posture-conditions).

### [`proto`](#proto)

The `proto` field is an optional field you can use to specify the protocol to which the rule applies. Without a protocol, the access rule applies to all TCP and UDP traffic.

You can specify `proto` as an [IANA IP protocol number](https://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml) `1-255` (for example, `"16"`) or one of the supported named aliases.


Expand to view all named aliases.

**Protocol**

**`proto`**

**IANA protocol number**

Internet Group Management (IGMP)

`igmp`

`2`

IPv4 encapsulation

`ipv4`, `ip-in-ip`

`4`

Transmission Control (TCP)

`tcp`

`6`

Exterior Gateway Protocol (EGP)

`egp`

`8`

Any private interior gateway

`igp`

`9`

User Datagram (UDP)

`udp`

`17`

Generic Routing Encapsulation (GRE)

`gre`

`47`

Encap Security Payload (ESP)

`esp`

`50`

Authentication Header (AH)

`ah`

`51`

Stream Control Transmission Protocol (SCTP)

`sctp`

`132`

Notes about the `proto` field:

-   You must use Tailscale version v1.18.2 or later to use the `proto` field. Earlier versions of Tailscale will fail and block access rules with protocols.
-   If traffic is allowed for a given pair of IP addresses, then ICMP will also be allowed.
-   Only TCP, UDP, and SCTP traffic support specifying ports. All other protocols only support `*` as the protocol port.

### [`dst`](#dst)

The `dst` field specifies a list of destinations to which the rule applies. Each element in the list specifies a `host` and one or more `ports` in the format `<host>:<ports>`.

The `host` can be any of the following types:

**Type**

**Example**

**Description**

Any

`*`

Includes any destination (no restrictions).

User

`shreya@example.com`

Includes any device currently signed in as the provided user.

[Group](#groups)

`group:<group-name>`

Includes all users in the provided group.

Tailscale IP address

`100.101.102.103`

Includes only the device that owns the provided Tailscale IP address.

[Hosts](#hosts)

`example-host-name`

Includes the Tailscale IP address in the [`hosts` section](#hosts).

[Subnet](https://tailscale.com/kb/1019/subnets) CIDR Range

`192.168.1.0/24`

Includes any IP address within the given subnet.

[Tags](https://tailscale.com/kb/1068/tags)

`tag:<tag-name>`

Includes any device with the provided tag.

Internet access through an [exit node](https://tailscale.com/kb/1103/exit-nodes)

`autogroup:internet`

Includes devices with access to the internet through [exit nodes](https://tailscale.com/kb/1103/exit-nodes).

Own devices

`autogroup:self`

Select a user's devices. `autogroup:self` is a special autogroup selector that, when combined with a src selector of `autogroup:<role>`, `group:<name>`, or an individual user, lets you grant access to a user's own devices from their own devices.

Tailnet devices

`autogroup:member`

Includes devices in the tailnet where the user is a direct member (not a shared user) of the tailnet.

Admin devices

`autogroup:admin`

Includes devices where the user is an [Admin](https://tailscale.com/kb/1138/user-roles#admin).

Network admin devices

`autogroup:network-admin`

Includes devices where the user is a [Network admin](https://tailscale.com/kb/1138/user-roles#network-admin).

IT admin devices

`autogroup:it-admin`

Includes to devices where the user is an [IT admin](https://tailscale.com/kb/1138/user-roles#it-admin).

Billing admin devices

`autogroup:billing-admin`

Includes devices where the user is a [Billing admin](https://tailscale.com/kb/1138/user-roles#billing-admin).

Auditor devices

`autogroup:auditor`

Includes devices where the user is an [Auditor](https://tailscale.com/kb/1138/user-roles#auditor).

Owner devices

`autogroup:owner`

Includes devices where the user is the tailnet [Owner](https://tailscale.com/kb/1138/user-roles#owner).

[IP sets](https://tailscale.com/kb/1387/ipsets)

`ipset:<ip-set-name>`

Includes all targets in the IP set.

The `ports` field can be any of the following types:

**Type**

**Description**

**Example**

Any

Includes any port number.

`*`

Single

Includes a single port number.

`22`

Multiple

Includes two or more port numbers separated by commas.

`80,443`

Range

Includes a range of port numbers.

`1000-2000`

### [Subnet routers and exit nodes](#subnet-routers-and-exit-nodes)

ACLs don't limit the discovery of routes. If a device is a [subnet router](https://tailscale.com/kb/1019/subnets), you can restrict access to it independently from the subnet. If a device is an [exit node](https://tailscale.com/kb/1103/exit-nodes), you can restrict access to it independently from its public IP address.

To restrict access to a subnet, ensure that no ACL allows access to those routes. You can enforce this with a test that fails if any rule accidentally allows access. The following example demonstrates a test that fails if `not-allowed@example.com` is allowed access to `198.51.100.7:22`.

```json
"tests": [
   {
     "src": "not-allowed@example.com",
     "accept": ["192.0.2.100:22"], // allow access to the tailscale IP
     "deny": ["198.51.100.7:22"], // does not allow access to the subnet
   }
],
```

Only devices with access to `autogroup:internet` can use exit nodes. All other devices (without access to `autogroup:internet`) cannot use exit nodes. You can enforce this with a test that fails if any rule accidentally allows access to a public address. The following example test fails if `not-allowed@example.com` can access `198.51.100.8:22`.

```json
"tests": [
   {
     "src": "not-allowed@example.com",
     "accept": ["192.0.2.100:22"], // allow access to the tailscale IP
     "deny": ["198.51.100.8:22"], // does not allow access to a public IP
   }
],
```

You cannot restrict the use of specific exit nodes using ACLs. Refer to [issue #1567](https://github.com/tailscale/tailscale/issues/1567) for updates.

### [Taildrop precedence](#taildrop-precedence)

Taildrop permits you to share files between devices you're logged in to, even if you use ACLs to restrict access.

## [Reference users](#reference-users)

Users are available for [the Personal, Personal Plus, Premium, and Enterprise plans](https://tailscale.com/pricing).

You can specify users in an access rule's source (`src`) and destination (`dst`) fields. To specify a user, use one of the following formats (depending on how the user signs into Tailscale):

**Format**

**Description**

**Example**

`username@example.com`

Use if the user signs into Tailscale with an email address.

`alice@example.com`

`username@github`

Use if the user signs into Tailscale with a GitHub account.

`alice@github`

`username@passkey`

Use if the user signs into Tailscale with a Passkey.

`alice@passkey`

You can use groups to reference sets of users. Groups let you define role-based access controls. There are multiple types of groups:

-   Auto groups that reference all users with the same property.
-   Groups defined in the `groups` section of the tailnet policy file as a specific list of users.
-   Groups provisioned in the identity provider and synced through user and group provisioning.

## [Autogroups](#autogroups)

Autogroups are available for [all plans](https://tailscale.com/pricing).

An [autogroup](https://tailscale.com/kb/1396/targets#autogroups) is a special group that automatically includes users, destinations, or usernames with the same properties.

**Allowed**

**Autogroup**

**Description**

**Availability by plan**

As a `dst`

`autogroup:internet`

Use to allow access for any user through _any_ [exit node](https://tailscale.com/kb/1103/exit-nodes) in your tailnet.

Available on [all plans](https://tailscale.com/pricing)

As a `dst`

`autogroup:self`

Use to allow access for any user that is authenticated as the same user as the source. Does not apply to tags.

Available on [all plans](https://tailscale.com/pricing)

As a `src` or `dst`, `tagOwner`, or `autoApprover`

`autogroup:owner`

Use to allow access for the tailnet [Owner](https://tailscale.com/kb/1138/user-roles#owner).

Available on [all plans](https://tailscale.com/pricing)

As a `src` or `dst`, `tagOwner`, or `autoApprover`

`autogroup:admin`

Use to allow access for any user who has the role of [Admin](https://tailscale.com/kb/1138/user-roles#admin).

Available on [all plans](https://tailscale.com/pricing)

As a `src` or `dst`, `tagOwner`, or `autoApprover`

`autogroup:member`

Use to allow access for any user who is a direct member (including all invited users) of the tailnet. Does not include users from shared devices.

Available on [all plans](https://tailscale.com/pricing)

As a `src` or `dst`, `tagOwner`, or `autoApprover`

`autogroup:tagged`

Use to allow access for any user who is a device that is [tagged](https://tailscale.com/kb/1068/tags).

Available on [all plans](https://tailscale.com/pricing)

As a `src` or `dst`, `tagOwner`, or `autoApprover`

`autogroup:auditor`

Use to allow access for any user who has the role of [Auditor](https://tailscale.com/kb/1138/user-roles#auditor).

Available on [the Personal, Personal Plus, Premium, and Enterprise plans](https://tailscale.com/pricing)

As a `src` or `dst`, `tagOwner`, or `autoApprover`

`autogroup:billing-admin`

Use to allow access for any user who has the role of [Billing admin](https://tailscale.com/kb/1138/user-roles#billing-admin).

Available on [the Personal, Personal Plus, Premium, and Enterprise plans](https://tailscale.com/pricing)

As a `src` or `dst`, `tagOwner`, or `autoApprover`

`autogroup:it-admin`

Use to allow access for any user who has the role of [IT admin](https://tailscale.com/kb/1138/user-roles#it-admin).

Available on [the Personal, Personal Plus, Premium, and Enterprise plans](https://tailscale.com/pricing)

As a `src` or `dst`, `tagOwner`, or `autoApprover`

`autogroup:network-admin`

Use to allow access for any user who has the role of [Network admin](https://tailscale.com/kb/1138/user-roles#network-admin).

Available on [the Personal, Personal Plus, Premium, and Enterprise plans](https://tailscale.com/pricing)

As a `src` or `dst`, `tagOwner`, or `autoApprover`

`user:*@<domain>`

Use to allow access for any user whose login is in the specified domain and who is a direct member (including all invited users) of the tailnet. Does not include users from shared devices.

Available on [the Starter, Premium, and Enterprise plans](https://tailscale.com/pricing)

As a `src`

`autogroup:shared`

Use to allow access for any user who accepted a [sharing](https://tailscale.com/kb/1084/sharing) invitation to your network. This lets you write rules without knowing the email addresses in advance.

Available on [all plans](https://tailscale.com/pricing)

As an [SSH](#ssh) user

`autogroup:nonroot`

Use to allow [Tailscale SSH](https://tailscale.com/kb/1193/tailscale-ssh) access to any user that is not `root`.

Available on [the Personal, Personal Plus, Premium, and Enterprise plans](https://tailscale.com/pricing)

As an [SSH](#ssh) user

`localpart:*@<domain>`

Use to allow [Tailscale SSH](https://tailscale.com/kb/1193/tailscale-ssh) access to the user whose name matches the [local-part](https://datatracker.ietf.org/doc/html/rfc2822#section-3.4.1) of the user's login.

Available on [the Premium and Enterprise plans](https://tailscale.com/pricing)

`autogroup:self` only applies to user-owned devices. It does not apply to tagged devices. You cannot use `autogroup:self` with `autogroup:tagged`.

The legacy autogroup `autogroup:members` will continue to work, but it's best practice to use `autogroup:member` instead. You cannot use both `autogroup:member` and `autogroup:members` in the same tailnet policy file.

The following example [`ssh` rule](#ssh) allows all users Tailscale SSH access to devices they own (as non-root):

```json
"ssh": [
  {
    // All users can SSH to their own devices, as non-root
    "action": "accept",
    "src": ["autogroup:member"],
    "dst": ["autogroup:self"],
    "users": ["autogroup:nonroot"]
  },
]
```

In the default ACL, the `ssh` rule uses `autogroup:self` for the `dst` field and`autogroup:nonroot` in the `users` field. If you change the `dst` field from`autogroup:self` to some other destination, such as an [ACL tag](https://tailscale.com/kb/1068/acl-tags/), also consider replacing `autogroup:nonroot` in the `users` field. If you don't remove`autogroup:nonroot` from the `users` field, then anyone permitted by the `src` setting will be able to SSH in as any nonroot user on the `dst` device.

### [Domain based autogroups](#domain-based-autogroups)

Some autogroups include a specific domain name. For example, `user:*@example.com` or `localpart:*@example.com`. These autogroups include users who are both members of the tailnet and whose login is in the autogroup domain. For example, if the tailnet `example.com` uses the autogroup `user:*@altostrat.com`, this group includes all members of the `example.com` tailnet who log in as a user at `@altostrat.com` (such as `laura@altostrat.com`).

The following restrictions apply to the domains used in autogroups:

-   The provided domain must not be a known shared domain (such as `gmail.com`).
-   If a tailnet uses domain aliases, you must explicitly specify the aliased domains in the ACL. For example, if `example.io` is aliased to `example.com` and you want to include users from both `example.com` and `example.io`, use both `user:*@example.com` and `user:*@example.io`.
-   Although the expressions use the wildcard `*`, it does not support arbitrary wildcards. For example, `user:b*b@example.com` will not match `bob@example.com`.

## [Groups](#groups)

Groups are available for [the Personal, Personal Plus, Premium, and Enterprise plans](https://tailscale.com/pricing).

The `groups` section lets you create groups of users, which you can use in access rules (instead of listing users out explicitly). Any change you make to the membership of a group propagates to all the rules that reference that group.

The following example demonstrates creating an `engineering` group and a `sales` group.

```json
"groups": {
  "group:engineering": [
    "dave@example.com",
    "laura@example.com",
  ],
  "group:sales": [
    "brad@example.com",
    "alice@example.com",
  ],
},
```

Every group name must start with the prefix `group:`. Each group member is specified by their full email address, as explained in the [users section](#reference-users) above. To avoid the risk of obfuscating group membership, groups cannot contain other groups.

You can add or remove a user's group membership by editing the tailnet policy file, as shown in the example `groups` definition above, and directly from the [Users](https://login.tailscale.com/admin/users) page of the admin console.

### [Edit a user's group membership from the Users page](#edit-a-users-group-membership-from-the-users-page)

You must be an [Owner, Admin, or Network admin](https://tailscale.com/kb/1138/user-roles) to edit a user's group membership from the **Users** page.

1.  Open the [Users](https://login.tailscale.com/admin/users) page in the admin console.
2.  Find the user by name.
3.  Select the ![ellipsis icon](/files/images/icons/fa-ellipsis-h.svg) menu > **Edit group membership**.
4.  In the **Edit group membership** dialog:
    1.  To add a group, select **Add to a group**, then the group to add.
    2.  To remove a group, select the **X** next to the group to delete.
5.  When you finish editing the groups for the user, select **Save**.

### [Synced groups](#synced-groups)

You can create groups in your identity provider and sync them with Tailscale's access control policies with [user and group provisioning](https://tailscale.com/kb/1290/user-group-provisioning#syncing-group-membership).

You can use the same human-readable group names in your identity provider to refer to groups in your tailnet policy file. The following example shows an access rule that manages access for the `security-team` group.

```json
{
    "grants": [
        {
            "src": ["group:security-team@example.com"],
            "dst": ["tag:logging"],
            "ip": ["*"]
        }
    ],
    "tagOwners": {
        "tag:logging": ["group:security-team@example.com"]
    }
}
```

You can only edit groups defined in the tailnet policy file. You can use groups synced from a System for Cross-domain Identity Management (SCIM) integration or tailnet autogroups, but you cannot edit them.

## [Reference multiple devices](#reference-multiple-devices)

You can define access rules for sets of devices using tags or hosts. Tags let you define role-based access controls so that different services have different access rules. Hosts let you define controls based on a reference to an IP address.

-   Tags reference groups of non-user devices (such as applications or servers). For example, you might have a tag that groups all servers in a particular data center.
-   Hosts reference groups of devices by IP address ranges (both on and beyond the tailnet). For example, you can use hosts to address applications with fixed IP addresses that you might be unable to modify.

### [Tags](#tags)

Tags are available for [all plans](https://tailscale.com/pricing).

The `tags` section of the tailnet policy file lets you create [tags](https://tailscale.com/kb/1068/tags) that group non-human devices. You can then use the tags to select these devices in an ACL.

You must [define the tag](https://tailscale.com/kb/1068/tags#define-a-tag) in the [`tagOwners`](#tag-owners) section of the tailnet policy file before using it in an ACL. To tag a device, [authenticate as the tag on the device](https://tailscale.com/kb/1068/tags#apply-a-tag-to-a-device).

### [Hosts](#hosts)

Hosts are available for [all plans](https://tailscale.com/pricing).

The `hosts` section lets you define a human-friendly name for an IP address or CIDR range.

The following example shows two host definitions: one for a single IP address and one for a CIDR range.

```json
"hosts": {
  "example-host-1": "198.51.100.100",
  "example-network-1": "198.51.100.0/24",
},
```

The human-friendly hostname cannot include the character `@`.

## [Postures](#postures)

Postures are available for [all plans](https://tailscale.com/pricing).

The `postures` section lets you define a set of [device posture management](https://tailscale.com/kb/1288/device-posture) rules that a device must meet as part of a specific access rule.

The following example shows how to use `postures` to select macOS devices running `node` version 1.40 or later.

```json
"postures": {
    "posture:latestMac": [
        "node:os IN ['macos']",
        "node:tsReleaseTrack == 'stable'",
        "node:tsVersion >= '1.40'",
    ],
},
```

Each posture must start with the prefix `posture:` followed by a name, a set of [posture attributes](https://tailscale.com/kb/1288/device-posture#device-posture-attributes), and their allowed values, given as a list of strings.

Refer to [device posture management](https://tailscale.com/kb/1288/device-posture) for more information

## [Tag owners](#tag-owners)

Tags are available for [all plans](https://tailscale.com/pricing).

The `tagOwners` section of the tailnet policy file defines the tags assignable to devices and the list of users allowed to assign each tag.

The following example shows a `tagOwners` definition that:

-   Sets the `engineering` group as the owner of the `webserver` tag.
-   Sets `president@example.com` and the `security-admins` group as owners of the `secure-server` tag.
-   Sets the `autogroup:member` autogroup as the owner of the `corp` tag.

```json
"tagOwners": {
  "tag:webserver": [
    "group:engineering",
  ],
  "tag:secure-server": [
    "group:security-admins",
    "president@example.com",
  ],
  "tag:corp": [
    "autogroup:member",
  ],
}
```

Every tag name must start with the prefix `tag:`. A tag owner can be a user's full login email address (as defined in the [users section](#reference-users) above), a [group name](#groups), an [autogroup](#autogroups), or another tag.

A shorthand notation, `[]`, is available for `autogroup:admin`. That is, the following are equivalent:

```json
"tag:monitoring": [
  "autogroup:admin",
],
```

```json
"tag:monitoring": [],
```

The autogroups `autogroup:admin` and `autogroup:network-admin` can assign all tags, so `[]` implicitly allows only `autogroup:admin` and `autogroup:network-admin`.

## [Auto approvers](#auto-approvers)

Auto approvers are available for [all plans](https://tailscale.com/pricing).

The `autoApprovers` section of the tailnet policy file defines the list of users who can perform specific actions without further approval from the admin console. Some actions in Tailscale require double opt-in: an [Admin](https://tailscale.com/kb/1138/user-roles) must enable them on the device running Tailscale and in the Tailscale admin console. These actions include:

-   [Advertising a specified set of routes](https://tailscale.com/kb/1019/subnets/connect-to-tailscale-as-a-subnet-router) as a subnet router.
-   [Advertising an exit node](https://tailscale.com/kb/1103/exit-nodes#advertise-a-device-as-an-exit-node).

For routes, this also permits the auto approvers to advertise a subnet of the specified routes.

Tailscale stops advertising a route if one of the following occurs:

-   The device is re-authenticated by a different user (who cannot advertise the route or exit node).
-   The user who advertised the route is suspended or deleted.

To avoid a scenario where Tailscale stops advertising a route, consider using a [tag](https://tailscale.com/kb/1068/tags) as an auto approver.

The following example shows an `autoApprovers` definition that automatically approves the `192.0.2.0/24` routes for `alice@example.com`, members of the `engineering` group, and devices tagged with `foo`. It also automatically allows devices tagged with `foo` to use an exit node.

```json
"autoApprovers": {
  "routes": {
    "192.0.2.0/24": ["group:engineering", "alice@example.com", "tag:foo"],
  },
  "exitNode": ["tag:bar"],
}
```

The auto approver of a route or exit node can be a user's full login email address (as defined in the [users section](#reference-users) above), a [group name](#groups), an [autogroup](#autogroups) or a tag.

Auto-approver policies only apply when Tailscale first receives a subnet route advertisement. Updating the tailnet policy file to add or modify auto-approvers does not retroactively approve existing unapproved routes. To trigger auto-approval for an existing unapproved route, remove the route from the subnet router and advertise it again.

## [Tailscale SSH](#tailscale-ssh)

Tailscale SSH is available for [the Personal, Personal Plus, Premium, and Enterprise plans](https://tailscale.com/pricing).

The `ssh` section of the tailnet policy file defines lists of users and devices that can use [Tailscale SSH](https://tailscale.com/kb/1193/tailscale-ssh) (and the SSH users). To allow a connection, the tailnet policy file must contain rules permitting both network access and SSH access:

1.  An access rule to allow connections from the source to the destination on port 22.
2.  An SSH access rule to allow connections from the source to the destination and the given SSH users. Tailscale SSH uses this to distribute keys to authenticating SSH connections.

The following example shows an `ssh` definition that requires a list of sources, destinations, and SSH users to re-authenticate every 20 hours.

```json
{
  "action": "check", // "accept" or "check"
  "src": [ <list-of-sources> ],
  "dst": [ <list-of-destinations> ],
  "users": [ <list-of-ssh-users> ],
  "checkPeriod": "20h", // optional, only for check actions. default 12h
  "acceptEnv": [ "GIT_EDITOR", "GIT_COMMITTER_*", "CUSTOM_VAR_V?" ] // optional, allowlists environment variables that can be forwarded from clients to the host
},
```

### [`action`](#action-1)

Specifies whether to accept the connection or to perform additional checks on it.

-   `accept` accepts connections from users already authenticated in the tailnet.
-   `check` requires users to periodically reauthenticate according to the `checkPeriod`.

### [`src`](#src-1)

Specifies the source (where a connection originates from). You can only define an access rule's destination (`dst`) as yourself, a group, a tag, or an autogroup. You cannot use `*`, other users, IP addresses, or hostnames.

It's impossible to guarantee the ownership of an IP address or hostname when you create an access rule. As a security measure, Tailscale prevents using users, IP addresses, or hostnames in the `dst` field of access rules to protect against scenarios in which one user can unintentionally access a device that doesn't belong to them. Tailscale also prevents any `src` and `dst` combinations that allow multiple users to access a single user's device.

Granting access to `autogroup:members` also allows access to [external invited users](https://tailscale.com/kb/1271/invite-any-user) if the destination device is [shared](https://tailscale.com/kb/1084/sharing) with them, even if they have no devices in your tailnet.

### [`dst`](#dst-1)

Specifies the destination (where the connection goes). The destination can be a tag, `autogroup:self` (if the source contains only users or groups), or a single named user (if the source contains only the same named user). The reason for these limitations is Tailscale does not let a user start a Tailscale SSH session on a user-owned device, unless the source is a device owned by the same user.

You cannot specify a port for the destination because the only allowed port is `22`. You cannot specify `*` as the destination.

### [`users`](#users)

Specifies the set of allowed usernames on the host. Tailscale only uses user accounts that already exist on the host.

-   Specify `autogroup:nonroot` to allow any user that is not `root`.
-   Specify `localpart:*@<domain>` to allow the user on the host whose name matches the [local-part](https://datatracker.ietf.org/doc/html/rfc2822#section-3.4.1) of the user's login, if and only if the user's login email is in `<domain>`. Tailscale does not do any special processing on the local-part. For example, if the login is `dave+sshuser@example.com`, Tailscale will map this to the ssh user `dave+sshuser`.
-   If no user is specified, Tailscale will use the local host's user. That is, if the user is logged in as `alice` locally, then connects with SSH to another device, Tailscale SSH will try to log in as user `alice`.

### [`checkPeriod`](#checkperiod)

When `action` is `check`, `checkPeriod` specifies the time period for which to allow a connection before requiring a check. You can specify the time in minutes or hours. The time must be at least one minute and at most 168 hours (one week).

-   The default check period is 12 hours.
-   You can also specify `always` to require a check on every connection. Using `always` might cause unexpected behavior with automation tools that open many SSH connections in quick succession (such as [Ansible](https://ansible.com)).

### [`acceptEnv`](#acceptenv)

The host must be running Tailscale v1.76.0 or later to use `acceptEnv`.

Specifies the set of allowlisted environment variable names that clients can send to the host using [`SendEnv`](https://man.openbsd.org/ssh_config#SendEnv) or [`SetEnv`](https://man.openbsd.org/ssh_config#SetEnv).

Values can contain `*` and `?` wildcard characters. `*` matches zero or more characters and `?` matches a single character.

#### [`acceptEnv` examples](#acceptenv-examples)

acceptEnv

Permitted

Rejected

`*`

`FOO_A` `FOO_B` `FOO_OTHER` `BAZ`

`FOO_*`

`FOO_A` `FOO_B` `FOO_OTHER`

`BAZ`

`FOO_?`

`FOO_A` `FOO_B`

`FOO_OTHER` `BAZ`

`FOO_A`

`FOO_A`

`FOO_B` `FOO_OTHER` `BAZ`

### [Order of evaluation](#order-of-evaluation)

Tailscale evaluates SSH access rules using the most restrictive policies first:

-   Check policies
-   Accept policies

For example, if you have an access rule allowing the user `alice@example.com` to access a resource with an `accept` rule, and a rule allowing `group:devops` which `alice@example.com` belongs to, to access a resource with a `check` rule, then the `check` rule applies.

Tailnets that have not modified their tailnet policy file have a [default SSH policy](https://tailscale.com/kb/1193/tailscale-ssh#ssh-access-rules-in-default-acl) allowing users to access devices they own using check mode.

The only types of connections that are allowed are:

-   From a user to their own devices (as any user, including `root`).
-   From a user to a [tagged](https://tailscale.com/kb/1068/tags) device (as any user, including `root`).
-   From a tagged device to another tagged device (for any tags). An SSH access rule from a tagged device cannot be in [check mode](https://tailscale.com/kb/1193/tailscale-ssh#configure-tailscale-ssh-with-check-mode).
-   From a user to a tagged device that has been [shared](https://tailscale.com/kb/1084/sharing) with them, as long as the destination host has Tailscale configured with SSH and the destination's ACL allows the user to connect over SSH.

That is, the broadest policy allowed would be:

```json
{
    "grants": [
        {
            "src": ["*"],
            "dst": ["*"],
            "ip": ["*"]
        }
    ],
    "ssh": [
        {
            "action": "accept",
            "src": ["autogroup:member"],
            "dst": ["autogroup:self"],
            "users": ["root", "autogroup:nonroot"]
        },
        {
            "action": "accept",
            "src": ["autogroup:member"],
            "dst": ["tag:prod"],
            "users": ["root", "autogroup:nonroot"]
        },
        {
            "action": "accept",
            "src": ["tag:logging"],
            "dst": ["tag:prod"],
            "users": ["root", "autogroup:nonroot"]
        }
    ]
}
```

To allow a user to only SSH to their own devices (as non-`root`):

```json
{
    "grants": [
        {
            "src": ["*"],
            "dst": ["*"],
            "ip": ["*"]
        }
    ],
    "ssh": [
        {
            "action": "accept",
            "src": ["autogroup:member"],
            "dst": ["autogroup:self"],
            "users": ["autogroup:nonroot"]
        }
    ]
}
```

To allow `group:sre` to access devices in the production environment tagged `tag:prod`:

```json
{
 "groups": {
   "group:sre": ["alice@example.com", "bob@example.com"]
 },
 "grants": [
   {
     "src": ["group:sre"],
     "dst": ["tag:prod"],
     "ip": ["*"]
   }
 ],
 "ssh": [
   {
     "action": "accept",
     "src": ["group:sre"],
     "dst": ["tag:prod"],
     "users": ["ubuntu", "root"]
   }
 ],
 "tagOwners": {
   // users in group:sre can apply the tag tag:prod
   "tag:prod": ["group:sre"]
 }
}
```

To allow Alice to access devices in the development environment tagged `tag:dev` that have been [shared](https://tailscale.com/kb/1084/sharing) with them:

```json
{
  "ssh": [
    {
      "action": "accept",
      "src": ["alice@example.com"],
      "dst": ["tag:dev"],
      "users": ["root", "alice"]
    },
  ]
}
```

It might be useful to match host users with login emails. For example, you can allow `dave@example.com` to authenticate as the host user `dave`.

To allow any tailnet member in the login domain `example.com` to access devices in the production environment that are tagged `tag:prod`, as a user that matches their login email local-part:

```json
{
   "grants": [
       {
           "src": ["user:*@example.com"],
           "dst": ["tag:prod"],
           "ip": ["*"]
       }
   ],
   "ssh": [
       {
           "action": "accept",
           "src": ["user:*@example.com"],
           "dst": ["tag:prod"],
           "users": ["localpart:*@example.com"]
       }
   ]
}
```

## [Node attributes](#node-attributes)

The `nodeAttrs` section of the tailnet policy file defines additional attributes that apply to specific devices in your tailnet.

One way you could use node attributes would be to set different [NextDNS configurations](https://tailscale.com/kb/1218/nextdns) for different devices in your tailnet. The following example shows a `nodeAttrs` definition that targets `my-kid@my-home.com` and `tag:server` with the attributes `nextdns:abc123` and `nextdns:no-device-info`.

```json
"nodeAttrs": [
    {
        "target": ["my-kid@my-home.com", "tag:server"],
        "attr": [
            "nextdns:abc123",
            "nextdns:no-device-info",
        ],
    },
],
```

### [`target`](#target)

Specifies which nodes (devices) the attributes apply to. You can select the devices using a tag (`tag:server`), user (`alice@example.com`), group (`group:kids`), or `*`.

### [`attr`](#attr)

Specifies which attributes apply to those nodes (devices).

For example:

-   The attribute `nextdns:abc123` specifics the NextDNS configuration ID `abc123`. If this is used, the attribute overrides the global NextDNS configuration.
-   The attribute `nextdns:no-device-info` disables sending device metadata to NextDNS.

The following example allows members of the tailnet to use [Tailscale Funnel](https://tailscale.com/kb/1223/funnel) on their nodes:

```json
"nodeAttrs": [
    {
         "target": ["autogroup:members"],
         "attr":   ["funnel"],
     },
],
```

You can use a `nodeAttrs` policy to enable the`randomize-client-port` setting for specific devices instead of using a [network-wide policy setting](#randomizeclientport).

```json
"nodeAttrs": [
  {
    "target": ["tag:office-network", "group:sea-office"],
    "attr":   ["randomize-client-port"],
  },
],
```

### [`app`](#app)

Specifies which application layer capabilities apply to these nodes (devices).

The following example node attribute definition configures the `example-connector` tag for the `example.com` domains.

```json
{
  "target": ["*"],
  "app": {
    "tailscale.com/app-connectors": [
      {
        "name": "example-app",
        "connectors": ["tag:example-connector"],
        "domains": ["example.com"],
        "routes": ["192.0.2.0/24"],
      },
    ],
  },
}
```

The specific application defines the names of capabilities in the format `<domainName>/<capabilityName>`. The example uses `tailscale.com/app-connectors`.

The value associated with each capability is an array of JSON objects, each containing capability-specific configuration options.

Refer to the [How app connectors work](https://tailscale.com/kb/1281/app-connectors) and [Best practices for using app connectors](https://tailscale.com/kb/1332/app-connectors-best-practices) topics.

## [Tests](#tests)

Tests are available for [all plans](https://tailscale.com/pricing).

The `tests` section lets you write assertions about your access control policies (grants and ACLs) that run as checks each time the tailnet policy file changes. If an assertion fails, the Tailscale rejects the updated tailnet policy file with an error. The error message indicates the failing tests.

Tests let you ensure you don't accidentally revoke important permissions or expose a critical system.

A `tests` definition looks like this:

```json
"tests": [
  {
    "src": "dave@example.com",
    "srcPostureAttrs": {
      "node:os": "windows",
    },
    "proto": "tcp",
    "accept": ["example-host-1:22", "vega:80"],
    "deny": ["192.0.2.3:443"],
  },
],
```

### [`src`](#src-2)

Specifies the user identity to test, which can be a [user's email address](#reference-users), a [group](#groups), a [tag](https://tailscale.com/kb/1068/tags), or a [host](#hosts) that maps to an IP address. The test case runs from the perspective of a device authenticated with the provided identity.

### [`srcPostureAttrs`](#srcpostureattrs)

Specifies the [device posture attributes](https://tailscale.com/kb/1288/device-posture) as key-value pairs to use when evaluating posture conditions in access rules. You only need to use this field if the access rules contain [device posture conditions](https://tailscale.com/kb/1288/device-posture#device-posture-conditions).

### [`proto`](#proto-1)

Specifies the IP protocol for `accept` and `deny` rules, similar to the `proto` field in [ACL rules](#acls). When omitted, the test checks for either TCP or UDP access.

When testing Internet Control Message Protocol (ICMP) access, set `"proto": "icmp"` and use port `0` in your destinations since ICMP doesn't use ports. The following example tests that user `alice@example.com` can `ping` devices tagged with `tag:production`:

```json
"tests": [
  {
    "src": "alice@example.com",
    "proto": "icmp",
    "accept": ["tag:production:0"],
  },
],
```

### [`accept` and `deny` destinations](#accept-and-deny-destinations)

Specifies destinations to accept or deny. Each destination in the list is of the form `host:port` where `port` is a single numeric port and `host` is one of the following:

**Type**

**Example**

**Description**

Tailscale IP

`100.101.102.103`

Includes the device with the provided Tailscale IP address. IPv6 addresses must follow the format `[1:2:3::4]:80`.

[Host](#hosts)

`my-host`

Includes the Tailscale IP address in the `hosts` section.

User

`shreya@example.com`

Includes the Tailscale IP addresses of devices signed in as the provided user.

[Group](#groups)

`group:security@example.com`

Includes the Tailscale IP addresses of devices signed in as a representative member of the provided group.

[Tag](https://tailscale.com/kb/1068/tags)

`tag:production`

Includes the Tailscale IP addresses of devices tagged with the provided tag.

You cannot use CIDR (subnet) notation to test subnet ranges. For example, `192.168.1.0/24` is not valid. Instead, you must specify the individual IP addresses or hostnames.

Sources in `src` and destinations in `accept` and `deny` must refer to specific entities and do not support `*` wildcards. For example, an `accept` destination cannot be `tags:*`.

The legacy `allow` (instead of `accept`) continues to work in ACLs. However, it is best practice to use `accept`.

## [SSH Tests](#ssh-tests)

SSH tests are available for [all plans](https://tailscale.com/pricing).

The `sshTests` section lets you write assertions about your [Tailscale SSH](https://tailscale.com/kb/1193/tailscale-ssh) access rules. SSH tests function similarly to ACL [tests](#tests).

SSH tests run when the tailnet policy file changes. If an assertion fails, Tailscale rejects the updated tailnet policy file with an error detailing the failing tests.

The following example shows a `sshTests` definition performs the following tests on connections from `dave@example.com` to `example-host-1`:

-   If the user is `dave`, it accepts the connection.
-   If the user is `admin`, it checks the connection.
-   If the user is `root`, it denies the connection.

```json
"sshTests": [
  {
    "src": "dave@example.com",
    "dst": ["example-host-1"],
    "accept": ["dave"],
    "check": ["admin"],
    "deny": ["root"],
  },
],
```

### [`src`](#src-3)

Specifies the user identity that's attempting to connect as SSH, which can be a [user's email address](#reference-users), a [group](#groups), a [tag](https://tailscale.com/kb/1068/tags), or a [host](#hosts) that maps to an IP address. The test case runs from the perspective of a device authenticated with the provided identity.

### [`dst`](#dst-2)

Specifies one or more destinations to which the `src` user is connecting, which can be a [user's email address](#reference-users), a [group](#groups), a [tag](https://tailscale.com/kb/1068/tags), or a [host](#hosts) that maps to an IP address.

### [`accept`](#accept)

Specifies zero, one, or more usernames to disallow on the `dst` host without requiring an additional check. Refer to [action `accept`](#action-1).

### [`check`](#check)

Specifies zero, one, or more usernames to disallow on the `dst` host if the `src` user passes an additional check. Refer to [action `check`](#action-1).

### [`deny`](#deny)

Specifies zero, one, or more usernames to disallow on the `dst` host (under any circumstances).

## [IP sets](#ip-sets)

An IP set is a way to manage groups of IP addresses. It can encapsulate a collection of IP addresses, CIDRs, hosts, autogroups, and other IP sets. The primary benefit of IP sets is that they let you group multiple network parts into a single collection, enabling you to apply access control policies to the collection rather than the individual IP addresses, hosts, or subnets.

Refer to the [IP sets documentation](https://tailscale.com/kb/1387/ipsets).

## [Network policy options](#network-policy-options)

Network policy options are available for [all plans](https://tailscale.com/pricing).

In addition to access rules, the tailnet policy file includes a few network-wide policy settings for specialized purposes. Most networks should never need to specify these.

### [`derpMap`](#derpmap)

The `derpMap` section lets you add [custom DERP servers](https://tailscale.com/kb/1118/custom-derp-servers) to your network, which your devices will use as needed to relay traffic. You can also use this section to disable using Tailscale-provided DERP servers. For example, you might want to disable tailnet-provided DERP servers to meet corporate compliance requirements. Refer to [running custom DERP servers](https://tailscale.com/kb/1118/custom-derp-servers) for more information.

### [`disableIPv4`](#disableipv4)

Instead of the `disableIPv4` field, it is recommended to use the `disable-ipv4` node attribute as described in [CGNAT conflicts](https://tailscale.com/kb/1023/troubleshooting#cgnat-conflicts).

The `disableIPv4` field (if set to `true`) stops assigning Tailscale IPv4 addresses to your devices. When IPv4 is disabled, all devices in your network receive exclusively IPv6 Tailscale addresses. Devices that do not support IPv6 (for example, systems that have IPv6 disabled in the operating system) will be unreachable. This option is intended for users with a pre-existing conflicting use of the `100.64.0.0/10` carrier-grade NAT address range.

### [`OneCGNATRoute`](#onecgnatroute)

The `OneCGNATRoute` field controls the routes that Tailscale clients generate.

Tailscale clients can have either:

-   One large `100.64/10` route to avoid churn in the routing table as devices go online and offline. (The churn is [disruptive](https://bugs.chromium.org/p/chromium/issues/detail?id=1076619) to Chromium-based browsers on macOS.)
-   Fine-grained `/32` routes.

The possible values for `OneCGNATRoute` are:

-   An empty string or not provided: Use default heuristics for each platform.
    -   For all platforms (other than macOS), Tailscale adds fine-grained `/32` routes for each device.
    -   On macOS (for Tailscale v1.28 or later), Tailscale adds one `100.64/10` route. Tailscale won't use one `100.64/10` route if other interfaces also route IP addresses in that range.
-   `"mac-always"`: macOS clients always add one `100.64/10` route.
-   `"mac-never"`: macOS clients always add fine-grained `/32` routes.

### [`randomizeClientPort`](#randomizeclientport)

You should only use the `randomizeClientPort` field as a workaround for some [firewall devices](https://tailscale.com/kb/1181/firewalls) after consulting with [Tailscale Support](https://tailscale.com/contact/support).

Setting the `randomizeClientPort` field to `true` makes devices use a random port for [WireGuard](https://tailscale.com/kb/1035/wireguard) traffic rather than the default static port `41641`.
```



### File: 1342-app-connectors-setup.md

```markdown
# Set up an app connector

App connectors are available for [all plans](https://tailscale.com/pricing).

App connectors let you route Tailscale network (known as a tailnet) traffic to your software as a service (SaaS), cloud, and self-hosted applications, letting users and devices on the tailnet access applications by domain names instead of IP addresses. You can also incorporate monitoring, optimization, security, and reliability into your app connector setup.

For more in-depth information about app connectors, refer to [How app connectors work](https://tailscale.com/kb/1281/app-connectors).

You can also [deploy an app connector to your Kubernetes cluster using the Kubernetes Operator](https://tailscale.com/kb/1517/kubernetes-operator-app-connector).

## [Requirements](#requirements)

To set up an app connector, you must have the following:

-   An existing tailnet and user account with the [Owner, Admin, or Network admin](https://tailscale.com/kb/1138/user-roles) role for editing the tailnet policy file and managing the app connector settings in the admin console.
-   The Linux device to use as the app connector with the following:
    -   A publicly accessible IP address.
    -   IP forwarding is enabled.
    -   You can use a physical device or a VM as the app connector device.
-   A SaaS or self-hosted application with administrative access.

## [Get started](#get-started)

To add a [preset app](#add-a-preset-app) type app connector in your tailnet, you must complete the following steps:

1.  Add the app connector in the admin console to route traffic to your application. When you add a preset app, the `nodeAttrs` section of your [tailnet policy file](https://tailscale.com/kb/1395/tailnet-policy-file) will automatically add a new `target` entry for the app connector. The `tagOwners`, `autoApprovers`, and `grants` entries must be manually added in the tailnet policy file.
2.  Update your tailnet policy file with the `tagOwners`, `autoApprovers`, and `grants` entries to let devices in your tailnet use the app connector.
3.  Configure a Linux node in your tailnet as an app connector device.
4.  (Optional) Restrict application access to only the app connector device by configuring an IP allowlist in your application.

To add a [custom app](#add-a-custom-app) type app connector in your tailnet, you must complete the following steps:

1.  Update your [tailnet policy file](https://tailscale.com/kb/1395/tailnet-policy-file) to let devices in your tailnet use the app connector, by adding entries to the `nodeAttrs`, `tagOwners`, `autoApprovers`, and `grants` sections.
2.  Configure a Linux node in your tailnet as an app connector device.
3.  Add the app connector settings in the admin console to route traffic to your application.
4.  (Optional) Restrict application access to only the app connector device by configuring an IP allowlist in your application.

### [Update the tailnet policy file](#update-the-tailnet-policy-file)

Configure your tailnet policy file with the necessary permissions to let devices use the app connector device.

You need to be an [Owner, Admin, or Network admin](https://tailscale.com/kb/1138/user-roles) to edit a tailnet policy file.

1.  Go to the [Access controls](https://login.tailscale.com/admin/acls) page of the admin console.

2.  Add a [`tagOwners`](https://tailscale.com/kb/1068/tags) rule to define the tag name and specify which users can assign that tag to other devices, letting them connect to the app connector. The following example defines the `github-admins` group as an owner of the `github-app-connector` tag.

    ```json
    "tagOwners": {
      "tag:github-app-connector": [
        "group:github-admins",
      ],
    },
    ```

    You can use the [visual policy editor](https://tailscale.com/kb/1550/visual-editor) to manage your tailnet policy file. Refer to the [visual editor reference](https://tailscale.com/kb/1587/visual-editor-reference) for guidance on using the visual editor.

3.  Add an [`autoApprovers`](https://tailscale.com/kb/1337/policy-syntax#autoapprovers) rule to automatically approve specific routes for the app connector tag. After you configure app traffic to route through an app connector, any DNS request to the configured app domains triggers route discovery.

    Preset apps, in most cases, do not require an `autoApprovers` rule for routes. Tailscale updates and manages the routes for preset apps and these are automatically approved.

    However, preset apps may also learn new routes through DNS. These learned routes are not automatically approved and will require an `autoApprovers` rule.

    Custom apps routes always require an `autoApprovers` rule.

    The following auto-approval policy example automatically approves all IPv4 and IPv6 routes for devices using the `github-app-connector` tag.

    ```json
    "autoApprovers": {
      "routes": {
        "0.0.0.0/0": ["tag:github-app-connector"],
        "::/0": ["tag:github-app-connector"],
      },
    },
    ```

    You can use the [visual policy editor](https://tailscale.com/kb/1550/visual-editor) to manage your tailnet policy file. Refer to the [visual editor reference](https://tailscale.com/kb/1587/visual-editor-reference) for guidance on using the visual editor.

4.  Add a [`grants`](https://tailscale.com/kb/1337/policy-syntax#grants) rule to route application-specific traffic through the app connector tag.

    You must allow tailnet devices to access the routes an app connector advertises. One way to do this is to add an access control policy to your tailnet policy file that grants access to `autogroup:internet` (any port number) for members of the tailnet, which will also grant users access to any exit nodes in the tailnet.

    ```json
    "grants": [
      {
        "src": ["autogroup:member"],
        "dst": ["autogroup:internet"],
        "ip": ["*"]
      }
    ]
    ```

    You can use the [visual policy editor](https://tailscale.com/kb/1550/visual-editor) to manage your tailnet policy file. Refer to the [visual editor reference](https://tailscale.com/kb/1587/visual-editor-reference) for guidance on using the visual editor.

    Devices require access to the app connector tag for DNS discovery. App connectors use the PeerAPI to perform DoH calls. Grant minimal access using TCP or UDP on port `53` to enable peer discovery:

    ```json
    "grants": [
      {
        "src": ["autogroup:member"],
        "dst": ["tag:github-app-connector"],
        "ip": ["tcp:53", "udp:53"]
      }
    ]
    ```

    You can use the [visual policy editor](https://tailscale.com/kb/1550/visual-editor) to manage your tailnet policy file. Refer to the [visual editor reference](https://tailscale.com/kb/1587/visual-editor-reference) for guidance on using the visual editor.

5.  Add a [`nodeAttrs`](https://tailscale.com/kb/1337/policy-syntax#nodeattrs) rule to map the app connector tag to the application-specific domains. The following example node attribute definition configures the `github-app-connector` tag for GitHub domains.

    If you are configuring a preset app type app connector, the `nodeAttrs` section is in your tailnet policy file is automatically updated, and you can skip this step.

    ```json
    "nodeAttrs": [
      {
        "target": ["*"],
        "app": {
          "tailscale.com/app-connectors": [
            {
              "name": "GitHub",
              "connectors": ["tag:github-app-connector"],
              "domains": [
                "github.com",
                "*.github.com"
              ]
            }
          ]
        }
      }
    ]
    ```

    You can use the [visual policy editor](https://tailscale.com/kb/1550/visual-editor) to manage your tailnet policy file. Refer to the [visual editor reference](https://tailscale.com/kb/1587/visual-editor-reference) for guidance on using the visual editor.


### [Configure a device as an app connector](#configure-a-device-as-an-app-connector)

After updating the [tailnet policy file](#requirements-for-the-tailnet-policy-file), configure the device to function as an app connector.

The app connector device must be running Linux, already added to your tailnet, have a public IP address, and IP port forwarding enabled.

Run the following Tailscale CLI command, making sure to replace the variables in the angle brackets (`<>`) with the actual app connector tag name.

```shell
tailscale up --advertise-connector --advertise-tags=tag:<connector-tag-name>
```

The `--advertise-connector` flag enables the device to route traffic for specific domains according to the configuration in the tailnet policy file. The `--advertise-tags` flag tells the Tailscale client to authenticate the device with the provided tags.

#### [Add a preset app](#add-a-preset-app)

Preset apps are the applications we support for automatically adding the necessary domains needed for your application, and can reduce the time needed for app connector configuration. After set up, preset apps periodically fetch domains and routes from the application's authoritative configuration and propagate any changes to the tailnet.

Tailscale supports the following preset apps:

-   AWS CloudFront (global)
-   AWS Elastic Compute Cloud (EC2) / Elastic Load Balancing (ELB)
-   AWS Simple Storage Service (S3)
-   Confluence
-   GitHub
-   Google Workspace
-   Jira
-   Microsoft 365
-   Okta
-   Salesforce (Hyperforce environment)
-   Salesforce (Salesforce-hosted)
-   Stripe

You need to be an [Owner, Admin, or Network admin](https://tailscale.com/kb/1138/user-roles) of a tailnet to configure a preset app.

1.  Open the [Apps](https://login.tailscale.com/admin/apps) page of the admin console.

2.  In the **Add an app** dialog, enter the following details.

    1.  **Name**: Enter a unique name for identifying the application.
    2.  **Target**: Select a preset app to automatically add the domains for your application.
    3.  **Connectors**: Select a tag or set of tags that you configured for your app connector in your tailnet policy file.
3.  Select **Save**.


A green icon next to the app connector name indicates that it is currently active and working as expected.

Select the app connector you added for additional details you can use to administer settings on both your tailnet and your application.

![App connector details for a preset app.](/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fapp-connector-preset.633ee96a.png&w=3840&q=75)

Traffic to configured domains routes through tagged app connectors before reaching target domains on the internet. This routing occurs even when the originating device uses an exit node. The source IP address for this traffic appears as one of the public IP addresses from the devices running as app connectors.

#### [Add a custom app](#add-a-custom-app)

If your application is not available as a preset app in the admin console, you can manually configure the settings.

You need to be an [Owner, Admin, or Network admin](https://tailscale.com/kb/1138/user-roles) of a tailnet to add and edit app connectors.

1.  Open the [Apps](https://login.tailscale.com/admin/apps) page of the admin console.

2.  In the **Add an app** dialog, enter the following details.

    1.  **Name**: Enter a unique name for identifying the application.
    2.  **Target**: Select **Custom** and manually enter the application domain names. If you need to add multiple domain entries, separate each one with a comma. When specifying domains, you can use wildcards for subdomains but not for top-level domains (TLDs). For example, `*.example.com`, `*.example.co.uk`, `*.example.info` are valid while `*.com`, `*.co.uk`, `*.info` are not valid.
    3.  **Connectors**: Select a tag or set of tags that you configured for your app connector in your tailnet policy file.
3.  Select **Save**.


A green icon next to the app connector name indicates that it is currently active and working as expected.

Select the app connector you added for additional details you can use to administer settings on both your tailnet and your application.

![App connector details for a custom app.](/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fapp-connector-custom.633b5ac7.png&w=3840&q=75)

#### [Edit preset apps](#edit-preset-apps)

The [Apps](https://login.tailscale.com/admin/apps) page of the admin console is the primary way to set up a preset app and automatically updates the `presetAppID` when you add an app connector. You can also manually modify the `presetAppID` for an app in your tailnet policy file.

The following shows an example snippet with GitHub as a preset app.

```json
"nodeAttrs": [
  {
    "target": ["*"],
    "app": {
      "tailscale.com/app-connectors": [
        {
          "name": "github app",
          "connectors": ["tag:code", "tag:ci-cd"],
          "presetAppID": "github"
        }
      ]
    }
  }
]
```

You can use the [visual policy editor](https://tailscale.com/kb/1550/visual-editor) to manage your tailnet policy file. Refer to the [visual editor reference](https://tailscale.com/kb/1587/visual-editor-reference) for guidance on using the visual editor.

The following is the list of the supported preset apps as they appear in the tailnet policy file.

**Preset app name**

**`presetAppID` value**

AWS CloudFront (global)

`aws-cloudfront-global`

AWS EC2/ELB

`aws-ec2-<region>-<availability-zone>-<local-zone>`

AWS S3

`aws-s3-<region>-<availability-zone>-<local-zone>`

Confluence

`confluence`

GitHub

`github`

Google Workspace

`google-workspace`

Jira

`jira`

Microsoft 365

`microsoft-365`

Okta

`okta`

Salesforce (Hyperforce environment)

`salesforce-hyperforce`

Salesforce (Salesforce-hosted)

`salesforce`

Stripe

`stripe`

#### [Remove an app connector](#remove-an-app-connector)

You must be an [Owner, Admin, or Network admin](https://tailscale.com/kb/1138/user-roles) of a tailnet to remove an app connector.

1.  Open the [Apps](https://login.tailscale.com/admin/apps) page of the admin console.
2.  Select the ![ellipsis icon](/files/images/icons/fa-ellipsis-h.svg) menu next to the app connector you want to remove, and select **Remove**.

After you remove an app connector, traffic to the application no longer routes through the app connector. Instead, traffic to the application's domain names routes directly from the client device or through an exit node if the device uses one.

If you no longer need the app connector device in your tailnet, you can [remove it](https://tailscale.com/kb/1260/device-remove).

### [Restrict application access by IP address](#restrict-application-access-by-ip-address)

Many applications let you control access by specifying which IP addresses can connect to them. When you use an app connector, all traffic from your tailnet to the target application appears to come from the app connector's public egress IP address. This means you can add the app connector's egress IP address to your target application's trusted list of ingress IP addresses (called an IP allowlist). This ensures only users with access to the app connector can access the target application.

To set this up, find your application's IP allowlist settings and add the public IP address of each device running as an app connector. If you use multiple app connectors for redundancy, add all their public IP addresses. You can find these IP addresses in your cloud provider's management interface.

The following is a list of Tailscale's supported preset apps and links for configuring specific IP addresses (IP allowlisting) for providing exclusive access to your app connector devices.

-   [AWS](https://docs.aws.amazon.com/dtconsole/latest/userguide/connections-ip-address.html)
-   [Confluence](https://support.atlassian.com/security-and-access-policies/docs/specify-ip-addresses-for-product-access/)
-   [GitHub](https://docs.github.com/en/enterprise-cloud@latest/organizations/keeping-your-organization-secure/managing-security-settings-for-your-organization/managing-allowed-ip-addresses-for-your-organization)
-   [Google Workspace](https://support.google.com/a/answer/12642752?hl=en)
-   [Jira](https://support.atlassian.com/security-and-access-policies/docs/specify-ip-addresses-for-product-access/)
-   [Microsoft 365](https://learn.microsoft.com/en-us/microsoft-365/enterprise/urls-and-ip-address-ranges?view=o365-worldwide)
-   [Okta](https://support.okta.com/help/s/article/How-to-Allow-Access-to-the-Okta-Applications-Only-From-a-Specific-IP-Range)
-   [Salesforce](https://help.salesforce.com/s/articleView?id=000386441&type=1)
-   [Stripe](https://docs.stripe.com/keys#limit-api-secret-keys-ip-address)

Tailscale automatically finds the preset app's IP addresses. Go to the [Apps](https://login.tailscale.com/admin/apps) page in the admin console, select the app details you'd like to configure, and copy the **Egress IPs** listed. This list includes all IP addresses of all connectors configured on the associated tags. Remember to update your IP allowlist if you add new app connectors.

App connector devices have two different IP addresses. The [Tailscale IP address](https://tailscale.com/kb/1015/100.x-addresses), which is private to your tailnet, and the public IP address, which other applications on the internet can reach. When configuring IP access controls, you need the public IP address, not the Tailscale IP address.

## [Limitations](#limitations)

-   Linux is the only operating system that can be used as an app connector device in a tailnet.
-   App connectors cannot be shared across multiple tailnets.
-   Advertising more than 10K routes on any instance, or across the whole tailnet, will cause significant functionality issues for connecting clients.
-   Tailnets are limited to advertising 250 domains across all applications.
-   Using frequently changing or [ephemeral](https://tailscale.com/kb/1111/ephemeral-nodes) resources as app connectors is not recommended. App connectors learn over time and build routes to connected domains, so using a stable routing infrastructure is more performant and reliable.
```



### File: 1346-start.md

```markdown
# Tailscale quickstart

Welcome! Follow the steps below to create your own private Tailscale network (known as a tailnet), or watch the video to learn how to get started with Tailscale and set up some useful features.

## [Create a tailnet](#create-a-tailnet)

1.  Go to [`tailscale.com`](https://tailscale.com/) and select **Get Started**. Alternatively, you can [download and install](https://tailscale.com/kb/1347/installation) the Tailscale client on your device, then [sign up](https://login.tailscale.com/start).

2.  On the **Sign up with your identity provider** page, log in using a [single sign-on (SSO) identity provider](https://tailscale.com/kb/1013/sso-providers) account.

    If you sign up using a custom-owned domain, you are automatically enrolled in the [Enterprise](https://tailscale.com/pricing) plan for a 14-day trial. If you sign up using a public domain email account such as `@gmail.com`, you are automatically enrolled in the [Personal](https://tailscale.com/pricing) plan, which entitles you to three free users and many of the features offered in the Enterprise plan. You can always change your plan. For details, refer to [Modify billing](https://tailscale.com/kb/1182/billing-information).

3.  On the **Welcome to Tailscale** page, select either **Business use** or **Personal use**.

4.  On the **Let's add your first device** page, select the OS that corresponds to the device you are using to download and install the client. Authenticate the client using the same credentials that you used to create the tailnet in step 2.

    Once you are authenticated, the device will appear in the browser window.

5.  On the **Next, add a second device** page, select the OS for another machine to add to the tailnet. Copy the link and send it to the second device. After the second device is authenticated, both devices will display.

6.  Select **Take me home**. You will be redirected to the Tailscale [admin console](https://login.tailscale.com/admin). This interface lets you control most aspects of your tailnet including users, devices, DNS, permissions, authentication keys, and more.


## [Rename devices](#rename-devices)

Every device added to a tailnet, including servers, nodes, phones, and personal computers is assigned a unique name generated from the device's OS hostname. This name is displayed in the [Machines](https://login.tailscale.com/admin/machines) page of the admin console. You can also [rename a device](https://tailscale.com/kb/1098/machine-names#renaming-a-machine) to help you locate and organize devices in the **Machines** page list.

## [Use MagicDNS](#use-magicdns)

[MagicDNS](https://tailscale.com/kb/1081/magicdns) makes communicating with devices across your tailnet easier by allowing you to use the name listed in the **Machines** page of the admin console instead of an IP address. This works using automatically assigned OS hostnames or renamed device names. MagicDNS is enabled by default, and we recommend you keep it enabled.

## [Invite users](#invite-users)

There are two types of tailnet user invites.

Team member invites are for users who will authenticate using the same identity provider you used when creating the tailnet.

External invites are for users who are not part of your custom domain, such as contractors, friends, and family.

### [Team members](#team-members)

If your tailnet uses a custom domain (`example.com`), users with email addresses with the same domain can log in without needing an invite. Alternatively, you can send [team member invites](https://tailscale.com/kb/1064/invite-team-members) to notify them to join.

### [External users](#external-users)

To invite external users to a tailnet, open the [Users](https://login.tailscale.com/admin/users) page of the admin console, select **Invite external users**, and choose one of the following options:

-   **Invite via email** to send one or more invites.
-   **Copy invite link** to share the invite link with others.

When users select the link, they will be directed to the Tailscale login page, where they can authenticate using a [supported single sign-on (SSO) identity provider](https://tailscale.com/kb/1013/sso-providers) account. Once they are authenticated, users are added on the **Users** page of the admin console.

For more information, refer to [Invite any user to your tailnet](https://tailscale.com/kb/1271/invite-any-user).

## [Add devices](#add-devices)

You can add more devices to your tailnet using one of the following methods:

-   [Login](https://login.tailscale.com/login) to the tailnet from other devices using an existing user account.
-   Add servers to a tailnet using a [tag](https://tailscale.com/kb/1068/tags) as the identity of the server, and provision the server using an [authentication key](https://tailscale.com/kb/1085/auth-keys). For more information, refer to [Setting up a server on your Tailscale network](https://tailscale.com/kb/1245/set-up-servers).
-   Incorporate your existing system policies such as mobile device management (MDM) to control device management. For more information, refer to [Integrate with an MDM solution](https://tailscale.com/kb/1362/mdm).

Tailscale automatically assigns each device on your network a [unique 100.x.y.z IP address](https://tailscale.com/kb/1033/ip-and-dns-addresses), to establish stable connections between machines no matter where they are in the world, even when they switch networks or are [behind a firewall](https://tailscale.com/blog/how-nat-traversal-works).

To learn more about adding devices, refer to [Add a device](https://tailscale.com/kb/1316/device-add).

## [Secure traffic using exit nodes](#secure-traffic-using-exit-nodes)

Keep your internet activity private on an untrusted network by designating devices in your tailnet as exit nodes, then configure your tailnet devices to use those exit nodes.

-   For details on how to quickly configure and use exit nodes, refer to [Use exit nodes](https://tailscale.com/kb/1408/quick-guide-exit-nodes).
-   For more in-depth information about exit nodes, refer to the main [Exit nodes](https://tailscale.com/kb/1103/exit-nodes) topic.

## [Route traffic using subnets](#route-traffic-using-subnets)

You can provide tailnet access to existing resources in your network using a subnet router. This can be useful if you need to access devices on which the Tailscale client cannot be installed, such as printers.

-   For details on how to quickly configure and use a subnet router, refer to [Configure a subnet router](https://tailscale.com/kb/1406/quick-guide-subnets).
-   For more in-depth information about subnet routers, refer to the main [Subnet routers](https://tailscale.com/kb/1019/subnets) topic.

## [Manage permissions with access control policies](#manage-permissions-with-access-control-policies)

You can define your own custom permission for the users and devices in your tailnet, using [access control policies](https://tailscale.com/kb/1393/access-control) (such as [ACLs](https://tailscale.com/kb/1018/acls) or [grants](https://tailscale.com/kb/1324/grants)). These permissions are configured in the tailnet policy file, which is located on the [Access controls](https://login.tailscale.com/admin/acls) page of the admin console.

## [Monitor and log traffic](#monitor-and-log-traffic)

You can monitor and log tailnet activity such as network traffic, client activity, tailnet configuration changes, and SSH session recordings.

For more information, refer to [Logging, auditing, and streaming](https://tailscale.com/kb/1011/log-mesh-traffic).

## [Use cases](#use-cases)

Need some inspiration? Tailscale can be used for a wide variety of users and environments. This section provides guidance for some common scenarios that you may want to use in your tailnet.

### [Developers](#developers)

-   Interact with tailnet resources from Visual Studio Code using our [Visual Studio Code extension](https://tailscale.com/kb/1265/vscode-extension).
-   Deploy, scale, and manage containerized applications such as [Kubernetes](https://tailscale.com/kb/1185/kubernetes), [Docker](https://tailscale.com/kb/1282/docker), and [Proxmox](https://tailscale.com/kb/1133/proxmox).
-   [Connect to serverless apps](https://tailscale.com/kb/1364/serverless) such as AWS App Runner, AWS Lambda, Google Cloud Run, and Heroku.
-   [Connect to cloud services](https://tailscale.com/kb/1357/cloud-server) such as AWS, Azure, Google Compute Engine, Hetzner, and Oracle Cloud.
-   Share local services on your machine such as web applications, accessible only from your tailnet using [Tailscale Serve](https://tailscale.com/kb/1312/serve) or share publicly over the internet using [Tailscale Funnel](https://tailscale.com/kb/1223/funnel).
-   [Share prototype servers](https://tailscale.com/kb/1034/local-team-server) with other colleagues without needing to modify firewall settings.

### [IT admins](#it-admins)

-   Manage the authentication and authorization of SSH connections in your tailnet using [Tailscale SSH](https://tailscale.com/kb/1193/tailscale-ssh).
-   Integrate Tailscale deployments on [AWS](https://tailscale.com/kb/1296/aws-reference-architecture) and [Azure](https://tailscale.com/kb/1314/azure-reference-architecture).
-   Control device and user access to your third-party applications without requiring any end-user configuration using [app connectors](https://tailscale.com/kb/1281/app-connectors).
-   Control what users can access in their Tailscale client using [system policies](https://tailscale.com/kb/1315/mdm-keys).
-   Use [Tailscale SSH session recording](https://tailscale.com/kb/1246/tailscale-ssh-session-recording) to stream recordings of Tailscale SSH sessions from the destination node to a recorder node in your tailnet.
-   Automate aspects of your Tailscale network using the [Tailscale API](https://tailscale.com/kb/1101/api).
-   Share an existing service with your peers outside your domain with [node sharing](https://tailscale.com/kb/1084/sharing).
-   Administer a computer remotely and lock down your [connections to a Microsoft Remote Desktop Protocol (RDP) server](https://tailscale.com/kb/1095/secure-rdp-windows).

### [Personal users](#personal-users)

-   Connect an [Apple TV](https://tailscale.com/kb/1280/appletv) to your tailnet for viewing your media server files, use your Apple TV as an [exit node](https://tailscale.com/kb/1103/exit-nodes) to route traffic through your home internet connection when you're away, or choose an exit node to route your Apple TV's traffic through.
-   Receive files from a [network attached storage](https://tailscale.com/kb/1307/nas) (NAS) server using FTP, and access media files from players such as VLC, Plex, and JellyFin.
-   Implement DNS-based ad blocking for your tailnet using [Control D](https://tailscale.com/kb/1403/control-d), [NextDNS](https://tailscale.com/kb/1218/nextdns) or a [Pi-hole](https://tailscale.com/kb/1114/pi-hole) server.
-   Share files between your own devices, even across operating systems, with [Taildrop](https://tailscale.com/kb/1106/taildrop).
-   Host a private server for you and your peers to play [Minecraft](https://tailscale.com/kb/1137/minecraft) or chat on IRC.

## [Troubleshooting and support](#troubleshooting-and-support)

Visit our [Support](https://tailscale.com/contact/support) page to read common questions and answers, file bugs, request new features, observe Tailscale's operational status, or engage directly with our Support team.

Here are some links that provide assistance for common inquiries:

-   [Troubleshooting guide](https://tailscale.com/kb/1023/troubleshooting)
-   [Production best practices](https://tailscale.com/kb/1300/production-best-practices)
-   [Security best practices](https://tailscale.com/kb/1196/security-hardening)
-   [Using Tailscale with your firewall](https://tailscale.com/kb/1181/firewalls)
```



### File: 1347-installation.md

```markdown
# Install Tailscale

[Download Tailscale](https://tailscale.com/download)

New users can follow the instructions in [Tailscale quickstart](https://tailscale.com/kb/1017/install) to create an account, install the Tailscale client, and configure some commonly used features.

## [Install and update instructions](#install-and-update-instructions)

The following topics provide platform-specific client update and installation instructions.

-   [Update Tailscale](https://tailscale.com/kb/1067/update)
-   [Uninstall Tailscale](https://tailscale.com/kb/1069/uninstall)
-   [Install on Linux](https://tailscale.com/kb/1031/install-linux)
-   [Install on macOS](https://tailscale.com/kb/1016/install-mac)
-   [Three ways to run Tailscale on macOS](https://tailscale.com/kb/1065/macos-variants)
-   [Install on Windows](https://tailscale.com/kb/1022/install-windows)
-   [Install on Windows with MSI](https://tailscale.com/kb/1189/install-windows-msi)
-   [Install on Windows with WSL 2](https://tailscale.com/kb/1295/install-windows-wsl2)
-   [Install on a Chromebook](https://tailscale.com/kb/1267/install-chromebook)
-   [Install on an Apple TV](https://tailscale.com/kb/1280/appletv)
-   [Install on iOS](https://tailscale.com/kb/1020/install-ios)
-   [Install on Android](https://tailscale.com/kb/1079/install-android)
-   [Install on Amazon Fire devices](https://tailscale.com/kb/1394/install-amazon-fire)
-   [Deploy and configure Tailscale with mobile device management (MDM) solutions](https://tailscale.com/kb/1362/mdm)

## [Install and update options](#install-and-update-options)

There are multiple ways to download, install, and update versions of the Tailscale client.

### [Manual installs and updates](#manual-installs-and-updates)

You can manually install and update your Tailscale clients using one of the following methods:

-   **Download page**: Install or update from the Tailscale [Download](https://tailscale.com/download) page.
-   **Client user interface**: Update from the [user interface of an installed client](https://tailscale.com/kb/1067/update#manual-updates) where an update option is available, including Windows and macOS.
-   **Tailscale CLI**: Update using the [`tailscale update`](https://tailscale.com/kb/1080/cli#update) command where [Tailscale CLI](https://tailscale.com/kb/1080/cli) functionality is available, including Linux, Windows, and macOS.
-   **App stores**: Install and update from app stores for the platforms that we support, such as Apple App Store, Google Play, and Amazon Appstore.
-   **Packages site**: Install and update from the [Tailscale Packages](https://pkgs.tailscale.com/) site. This lets you choose the stable, release candidate, or unstable build track to suit your needs. For more information, refer to [Tailscale client versions and release tracks](https://tailscale.com/kb/1168/versions#client-release-tracks).

### [Auto updates](#auto-updates)

You can configure your Tailscale clients to automatically update and deploy updates to devices using one of the following methods:

-   **Admin console**: Configure [automatic updates](https://tailscale.com/kb/1067/update#enable-auto-updates-on-devices) from the admin console.
-   **Client settings**: Configure [automatic updates](https://tailscale.com/kb/1067/update#enable-auto-updates-on-devices) from the UI settings of a client or device app store settings.
-   **System policies**: Use an [MDM solution](https://tailscale.com/kb/1315/mdm-keys#configure-the-auto-update-settings) such as Google Workspace, Jamf, Kandji, or Microsoft Intune to automatically update devices.

For more information, refer to [Update Tailscale](https://tailscale.com/kb/1067/update).
```



### File: 1348-guides.md

```markdown
# How-to Guides

[

#### Manage access

Learn how to manage access to your Tailscale resources.



](https://tailscale.com/kb/1350/manage)[

#### Route traffic

Learn about Tailscale routing features, such as subnet routers, exit nodes, and MagicDNS.



](https://tailscale.com/kb/1351/route)[

#### Set up servers

Securely set up servers using tags, pre-authorization keys, ephemeral nodes, and more.



](https://tailscale.com/kb/1352/servers)[

#### Access and share services

View services, share machines, and share files in your tailnet.



](https://tailscale.com/kb/1354/share)[

#### Share a web server

Learn how to share resources including websites from tailnet devices.



](https://tailscale.com/kb/1353/share-web-server)[

#### Logging, streaming, and events

Learn about Tailscale logging features and events for webhooks.



](https://tailscale.com/kb/1349/log-events)[

#### Solutions

See solutions for scenarios that span multiple products.



](https://tailscale.com/kb/1355/solutions)
```



### File: 1349-log-events.md

```markdown
# Logging, streaming, and events

Manage the logs and events within your Tailscale network, known as a tailnet.

## [Capture logs and events](#capture-logs-and-events)

You can capture configuration changes to your tailnet as well as network traffic flow.

[

#### Configuration audit logs

Configure audit logging to capture configuration changes, such as a new device added to your tailnet.



](https://tailscale.com/kb/1203/audit-logging)[

#### Network audit logs

Configure network flow logging to capture connection information between nodes in your tailnet.



](https://tailscale.com/kb/1219/network-flow-logs)

## [Stream logs and events to a SIEM or storage bucket](#stream-logs-and-events-to-a-siem-or-storage-bucket)

Stream configuration audit logs and network flow logs to your preferred log streaming integration, such as a security information and event management (SIEM) system and Amazon S3 or S3-compatible storage buckets. You can also stream Tailscale SSH session recordings to another node in your tailnet or storage buckets.

[

#### Log streaming

Send configuration audit logs and network flow logs to a streaming integration.



](https://tailscale.com/kb/1255/log-streaming)[

#### Tailscale SSH sessions

Send Tailscale SSH activity to another node in your tailnet.



](https://tailscale.com/kb/1246/tailscale-ssh-session-recording)[

#### Tailscale SSH session recording

Send Tailscale SSH activity to a storage bucket.



](https://tailscale.com/kb/1263/session-recording-s3)

## [Integrate log events with your infrastructure](#integrate-log-events-with-your-infrastructure)

Use webhooks to integrate log events with your infrastructure, such as with apps like Slack.

[

#### Webhooks

Configure and manage webhooks in your tailnet.



](https://tailscale.com/kb/1213/webhooks)
```



### File: 1350-manage.md

```markdown
# Manage access

Use Tailscale access features to control how users access resources in your Tailscale network, known as a tailnet. You also control how devices access other devices.

## [Manage access policy](#manage-access-policy)

Access control lists (ACLs) and grants let you precisely define permissions for users and devices in your tailnet. Tailscale manages access rules for your network in the [tailnet policy file](https://tailscale.com/kb/1155/terminology-and-concepts#tailnet-policy-file).

[

#### Manage permissions using ACLs

Define permissions for your users and devices at the network layer.



](https://tailscale.com/kb/1018/acls)[

#### Manage permissions using grants

Define permissions for your users and devices at the network or application layer.



](https://tailscale.com/kb/1324/grants)[

#### Tailnet policy file

Get details about the syntax and structure of the tailnet policy file.



](https://tailscale.com/kb/1337/policy-syntax)[

#### Just-in-time (JIT) access

Use automation to provide Just-in-time (JIT) access, also known as on-demand access, to someone for a limited time, allowing them to perform a task.



](https://tailscale.com/kb/1443/just-in-time-access)

## [Manage devices](#manage-devices)

You control which devices are in your tailnet, including whether you want a tailnet admin to approve new devices before they are allowed access. You can also use device posture with mobile device management (MDM) solutions to enforce device rules.

[

#### Add, remove, and manage devices

Learn how to manage devices, enforce admin approval for new devices, and use device posture for enforcing device rules.



](https://tailscale.com/kb/1372/manage-devices)

## [Manage users and user roles](#manage-users-and-user-roles)

You control which users are in your tailnet, how they are invited, and their access to your tailnet resources.

[

#### Add, remove, and manage users

See how to add and manage users, delete users, and enforce review of new users before they can join your tailnet.



](https://tailscale.com/kb/1373/manage-users)

## [Manage domain ownership](#manage-domain-ownership)

When you create your tailnet, your user domain becomes part of your Tailscale identity.

[

#### Domain ownership

Learn how your user domain is used for Tailscale identity, and how to mitigate tailnet risk from a malicious takeover.



](https://tailscale.com/kb/1259/domain-ownership)
```



### File: 1351-route.md

```markdown
# Route traffic

Use Tailscale routing features to control how network traffic is routed to, from, and within your Tailscale network, known as a tailnet.

## [Access non-Tailscale devices](#access-non-tailscale-devices)

In cases where you can't install Tailscale on every device on your physical network, you can set up a _subnet router_ to access these devices from your tailnet. Subnet routers respect features like [access control policies](https://tailscale.com/kb/1393/access-control), which make it easy to migrate a large network to Tailscale without installing the Tailscale client on every device.

[

#### Subnet routers

Learn how to access non-Tailscale devices from your network.



](https://tailscale.com/kb/1019/subnets)

## [Route all internet traffic](#route-all-internet-traffic)

Routing internet traffic through an _exit node_ is useful when accessing untrusted Wi-Fi in a cafe or using an online service (such as banking) only available in your home country from overseas.

Exit nodes route **all** your network traffic, which is often not what you want. To configure Tailscale to only route traffic to certain subnets (the more common configuration), read about [Accessing non-Tailscale devices from your network](#access-non-tailscale-devices) instead.

[

#### Exit nodes

Learn how to route traffic through a specific device in your tailnet.



](https://tailscale.com/kb/1103/exit-nodes)[

#### Mullvad exit nodes

Learn how to use Mullvad VPN endpoints as exit nodes for your tailnet.



](https://tailscale.com/kb/1258/mullvad-exit-nodes)

## [Control access to third-party applications](#control-access-to-third-party-applications)

App connectors let you control device and user access to applications without any end-user setup. They let you manage and monitor access to both SaaS and self-hosted apps across your tailnet.

[

#### How app connectors work

Learn how to route your tailnet traffic to your applications using app connectors.



](https://tailscale.com/kb/1281/app-connectors)

## [Manage DNS](#manage-dns)

You can map Tailscale IP addresses to human-readable and memorable names using the Domain Name System (DNS). For example, instead of remembering which IP address maps to an internal expense report server hosted in your tailnet, you can use DNS to map the IP address to the server's name, like "Expenses".

[

#### DNS in Tailscale

Learn how to manage DNS for your tailnet.



](https://tailscale.com/kb/1054/dns)
```



### File: 1352-servers.md

```markdown
# Set up servers

A server in Tailscale is a device that provides resources or services to other devices in your Tailscale network (known as a tailnet). Unlike user devices which authenticate through your identity provider, servers are typically non-human devices that require different authentication methods, such as tags and auth keys. Servers can be physical machines, virtual machines, or cloud instances that run services like web applications, databases, or file shares.

## [Authenticate devices and verify identity](#authenticate-devices-and-verify-identity)

Unlike user devices, which authenticate through identity providers, servers need a different approach. Tailscale provides tags for server identify management and auth keys for automated authentication.

[

#### Setting up a server on your Tailscale network

Add a server to your tailnet and verify its connection.



](https://tailscale.com/kb/1245/set-up-servers)[

#### Group devices with tags

Create and manage tags to identify servers and other non-human devices.



](https://tailscale.com/kb/1068/tags)[

#### Auth keys

Generate and manage authentication keys for automated server deployment.



](https://tailscale.com/kb/1085/auth-keys)[

#### Ephemeral nodes

Configure servers that automatically remove themselves from your tailnet.



](https://tailscale.com/kb/1111/ephemeral-nodes)

## [Secure remote access and enable TLS connections](#secure-remote-access-and-enable-tls-connections)

After you authenticate your servers, you need secure ways to access and manage them. Tailscale provides built-in support for both SSH and HTTPS access.

Tailscale SSH eliminates the complexity of traditional SSH key management. It automatically handles key distribution and user authentication based on your existing identity provider permissions.

[

#### Tailscale SSH

Configure zero-configuration SSH access using your identity provider credentials.



](https://tailscale.com/kb/1193/tailscale-ssh)

Tailscale secures connections between tailnet devices with end-to-end encryption. However, some applications are not aware of that and might warn users or disable features based on the fact that HTTP URLs to your tailnet services look unencrypted because they're not using TLS certificates. You can prevent these problems by configuring your tailnet to use HTTPS.

[

#### Enabling HTTPS

Enable HTTPS for your tailnet so servers can provision TLS certificates.



](https://tailscale.com/kb/1153/enabling-https)
```



### File: 1353-share-web-server.md

```markdown
# Share a web server

Tailscale lets you share a local service running on a device in your Tailscale network (known as a tailnet). For example, you can provide access to a web server. You decide whether traffic is allowed from the wider internet or only from your tailnet.

[

#### Tailscale Funnel

Route traffic from the wider internet to a local service.



](https://tailscale.com/kb/1223/funnel)[

#### Tailscale Serve

Route traffic from your tailnet to a local service.



](https://tailscale.com/kb/1312/serve)
```



### File: 1354-share.md

```markdown
# Access and share services

View machine services, securely share machines with people outside your Tailscale network (known as a tailnet), and send files between devices in your tailnet.

[

#### View endpoints on your network

Monitor and connect to endpoints running on machines in your tailnet.



](https://tailscale.com/kb/1100/services)[

#### Share machines with other users

Grant access to specific machines for people outside your tailnet, while maintaining security and privacy.



](https://tailscale.com/kb/1084/sharing)[

#### Taildrop

Send files between devices in your tailnet.



](https://tailscale.com/kb/1106/taildrop)
```



### File: 1355-solutions.md

```markdown
# Solutions

[

#### Secure your internet traffic on public Wi-Fi using an Apple TV

Route Tailscale traffic through your Apple TV for secure, private browsing and access to region-locked content.



](https://tailscale.com/kb/1598/apple-tv-route-traffic)[

#### Block ads on all your devices from anywhere using a Raspberry Pi

Increase privacy, security, and browsing performance in a cost-effective way by using a Raspberry Pi with Pi-hole to block ads.



](https://tailscale.com/kb/1114/pi-hole)[

#### Access remote desktops using RustDesk

Set up secure remote desktop access using RustDesk and Tailscale for connecting devices directly over your private tailnet, no servers needed.



](https://tailscale.com/kb/1599/rustdesk)[

#### Create a secure connection to MongoDB Atlas

Securely connect to a MongoDB Atlas database and permit access only to your Tailscale network.



](https://tailscale.com/kb/1601/connect-mongodb-atlas)[

#### Code on iPad using Visual Studio Code, Caddy, and code-server

Code from your iPad from anywhere with a secure private connection to your own remote coding environment.



](https://tailscale.com/kb/1166/vscode-ipad)[

#### Set up a dog camera with Tailscale, Raspberry Pi, and Motion

Set up a dog camera that you can securely access from anywhere.



](https://tailscale.com/kb/1076/dogcam)[

#### Use UFW to lock down an Ubuntu server

Learn how to accept connections from Tailscale and ignore internet traffic to a server.



](https://tailscale.com/kb/1077/secure-server-ubuntu)[

#### Access PiKVM from anywhere

Learn how to set up Tailscale on PiKVM.



](https://tailscale.com/kb/1292/pikvm)[

#### Run a private Minecraft server with Tailscale

See how to share a Minecraft server with the people you want from anywhere.



](https://tailscale.com/kb/1137/minecraft)[

#### Tailscale on NixOS: A New Minecraft Server in Ten Minutes

Set up a Minecraft server on NixOS.



](https://tailscale.com/kb/1096/nixos-minecraft)[

#### Connect to external services with IP block lists

Learn how to control access to SaaS applications hosted on servers that aren't running Tailscale.



](https://tailscale.com/kb/1059/ip-blocklist-relays)[

#### Infrastructure as code

Infrastructure as Code integrations let you deploy infrastructure programmatically.



](https://tailscale.com/kb/1370/infrastructure-as-code)
```



### File: 1356-integrations.md

```markdown
# Integrations

-   [Connect to a cloud server](https://tailscale.com/kb/1357/cloud-server)
-   [Integrate with containers or virtualized environments](https://tailscale.com/kb/1358/containers-and-virtualization)
-   [Connect to a serverless app](https://tailscale.com/kb/1364/serverless)
-   [Connect to a database](https://tailscale.com/kb/1359/database)
-   [Connect to your remote code environment](https://tailscale.com/kb/1363/remote-code)
-   [Access or share resources from within your development environment](https://tailscale.com/kb/1360/developer-tools)
-   [Integrate with a firewall](https://tailscale.com/kb/1361/firewall)
-   [Integrate with a web server](https://tailscale.com/kb/1365/webserver)
-   [Connect to network attached storage (NAS)](https://tailscale.com/kb/1307/nas)
-   [Integrate with your MDM solution](https://tailscale.com/kb/1362/mdm)
```



### File: 1357-cloud-server.md

```markdown
# Connect to a cloud server

-   [AWS Lightsail](https://tailscale.com/kb/1128/aws-lightsail)
-   [AWS VPC](https://tailscale.com/kb/1021/install-aws)
-   [Azure App Services](https://tailscale.com/kb/1126/azure-app-services)
-   [Azure Linux VMs](https://tailscale.com/kb/1142/cloud-azure-linux)
-   [Azure Windows VMs](https://tailscale.com/kb/1143/cloud-azure-windows)
-   [Google Compute Engine VMs](https://tailscale.com/kb/1147/cloud-gce)
-   [Hetzner VMs](https://tailscale.com/kb/1150/cloud-hetzner)
-   [Oracle Cloud VMs](https://tailscale.com/kb/1149/cloud-oracle)
```



### File: 1358-containers-and-virtualization.md

```markdown
# Containers and virtualization

[

#### Using Tailscale with Docker

Connect your container to Tailscale using Tailscale's official Docker image.



](https://tailscale.com/kb/1282/docker)[

#### Tailscale on Kubernetes

Learn how to use Tailscale to simplify your Kubernetes cluster deployments.



](https://tailscale.com/kb/1185/kubernetes)[

#### Kubernetes operator

Learn how to expose your Kubernetes cluster to your Tailscale network.



](https://tailscale.com/kb/1236/kubernetes-operator)[

#### Tailscale in LXC containers

Learn how to use Tailscale in LXC containers.



](https://tailscale.com/kb/1130/lxc-unprivileged)[

#### Tailscale on a Proxmox host

See how to optimally configure Proxmox for use with Tailscale.



](https://tailscale.com/kb/1133/proxmox)
```



### File: 1359-database.md

```markdown
# Connect to a database

-   [AWS RDS](https://tailscale.com/kb/1141/aws-rds)
-   [Crunchy Bridge](https://tailscale.com/kb/1231/crunchy-bridge)
```



### File: 1360-developer-tools.md

```markdown
# Access or share resources from within your development environment

-   [Access or share resources from Visual Studio Code](https://tailscale.com/kb/1265/vscode-extension)
-   [Access or share resources from a GitHub Actions workflow](https://tailscale.com/kb/1276/tailscale-github-action)
-   [Access or share resources from a GitLab CI/CD runner](https://tailscale.com/kb/1287/tailscale-gitlab-ci)
-   [Access or share resources from Docker Desktop](https://tailscale.com/kb/1184/docker-desktop)
```



### File: 1361-firewall.md

```markdown
# Integrate with a firewall

-   [Overview](https://tailscale.com/kb/1181/firewalls)
-   [Use OPNsense with Tailscale](https://tailscale.com/kb/1097/install-opnsense)
-   [Use Palo Alto Networks firewalls with Tailscale](https://tailscale.com/kb/1333/firewall-palo-alto-networks)
-   [Use pfSense with Tailscale](https://tailscale.com/kb/1146/pfsense)
-   [Firewall mode for tailscaled](https://tailscale.com/kb/1294/firewall-mode)
```



### File: 1363-remote-code.md

```markdown
# Connect to your remote code environment

-   [Connect from code-server](https://tailscale.com/kb/1164/codeserver)
-   [Connect from Coder](https://tailscale.com/kb/1163/coder)
-   [Connect from CodeSandbox](https://tailscale.com/kb/1221/codesandbox)
-   [Connect from GitHub Codespaces](https://tailscale.com/kb/1160/github-codespaces)
-   [Connect from Gitpod](https://tailscale.com/kb/1161/gitpod)
-   [Connect from OpenVSCode](https://tailscale.com/kb/1162/openvscode)
```



### File: 1364-serverless.md

```markdown
# Connect to a serverless app

-   [AWS App Runner](https://tailscale.com/kb/1127/aws-app-runner)
-   [AWS Lambda](https://tailscale.com/kb/1113/aws-lambda)
-   [Fly.io](https://tailscale.com/kb/1132/flydotio)
-   [Google Cloud Run](https://tailscale.com/kb/1108/cloudrun)
-   [Heroku](https://tailscale.com/kb/1107/heroku)
-   [Koyeb](https://tailscale.com/kb/1547/koyeb)
```



### File: 1365-webserver.md

```markdown
# Integrate with a web server

-   [Caddy Server](https://tailscale.com/kb/1190/caddy-certificates)
-   [Traefik Proxy](https://tailscale.com/kb/1234/traefik-certificates)
```



### File: 1366-faq.md

```markdown
# FAQ

## [Getting started](#getting-started)

-   [What is Tailscale?](https://tailscale.com/kb/1151/what-is-tailscale)
-   [What is a tailnet?](https://tailscale.com/kb/1136/tailnet)
-   [What are these `100.x.y.z` addresses?](https://tailscale.com/kb/1015/100.x-addresses)

## [Deploying Tailscale](#deploying-tailscale)

-   [Can I use Tailscale alongside other VPNs?](https://tailscale.com/kb/1105/other-vpns)
-   [I can't install Tailscale. How can I connect?](https://tailscale.com/kb/1109/devices-without-tailscale)
-   [What firewall ports should I open to use Tailscale?](https://tailscale.com/kb/1082/firewall-ports)

## [Reliability](#reliability)

-   [What happens if the coordination server is down?](https://tailscale.com/kb/1091/what-happens-if-the-coordination-server-is-down)
-   [Is my traffic routed through your servers?](https://tailscale.com/kb/1094/is-all-traffic-routed-through-tailscale)

Learn more about [how Tailscale works](https://tailscale.com/blog/how-tailscale-works).

## [Security and privacy](#security-and-privacy)

-   [Can Tailscale decrypt my traffic?](https://tailscale.com/kb/1093/can-tailscale-decrypt-my-traffic)
-   [If I use Tailscale on my work device, will my personal devices be visible to my co-workers?](https://tailscale.com/kb/1087/device-visibility)

Learn more about Tailscale [security](https://tailscale.com/security).

## [Other](#other)

-   [Does Tailscale support IPv6?](https://tailscale.com/kb/1121/ipv6)
-   [Why is MagicDNS fetching records on port `433`?](https://tailscale.com/kb/1253/dns-over-https)
-   [Do admin console sessions expire?](https://tailscale.com/kb/1321/admin-console-session-expiry)
-   [What is STUN?](https://tailscale.com/kb/1462/what-is-stun)
```



### File: 1367-reference.md

```markdown
# Technical reference

These topics provide technical reference about Tailscale tools and features in your Tailscale network (known as a tailnet).

## [Access control policies](#access-control-policies)

You can use access control policies to enforce access for users, devices, and applications in your tailnet.

[

#### Tailnet policy file syntax

Use tailnet policy file syntax options to configure user and device access in your tailnet policy file.



](https://tailscale.com/kb/1337/policy-syntax)[

#### Tailnet policy file samples

Use our samples to help you create custom tailnet policy files.



](https://tailscale.com/kb/1192/acl-samples)

## [Tailscale command line interface (CLI)](#tailscale-command-line-interface-cli)

The Tailscale client includes a built-in CLI tool you can use to manage and troubleshoot your device within your Tailscale network (known as a tailnet).

[

#### Tailscale CLI

Use the CLI to update the client, generate a certificate, and more.



](https://tailscale.com/kb/1080/cli)

## [Tailscale application programming interface (API)](#tailscale-application-programming-interface-api)

You can use the Tailscale API to automate and manage various aspects of your tailnet.

[

#### API

Use the Tailscale API in your tailnet.



](https://tailscale.com/kb/1101/api)[

#### OAuth clients

Use OAuth clients for delegated and scoped access to the Tailscale API.



](https://tailscale.com/kb/1215/oauth-clients)[

#### tsnet

Use the tsnet library to embed Tailscale inside a Go program in your tailnet.



](https://tailscale.com/kb/1244/tsnet)

## [Technical overviews and production best practices](#technical-overviews-and-production-best-practices)

Read in-depth topics about Tailscale networking, security, and production best practices.

[

#### Technical overviews

Get in-depth understanding of networking and security in your tailnet.



](https://tailscale.com/kb/1376/tech-overviews)[

#### Production best practices

Get recommendations for deploying Tailscale in a production environment.



](https://tailscale.com/kb/1300/production-best-practices)

## [Terminology and concepts](#terminology-and-concepts)

Familiarize yourself with Tailscale terminology and concepts.

[

#### Terminology and concepts

View Tailscale terminology and concepts.



](https://tailscale.com/kb/1155/terminology-and-concepts)
```



### File: 1368-resources.md

```markdown
# Resources

## [Software changes and release stages](#software-changes-and-release-stages)

We regularly release updates to the Tailscale client and service, and provide information for each version.

[

#### View the changelog

Keep up to date on changes to the Tailscale client and service.



](https://tailscale.com/changelog)[

#### Get version numbering and release details

View the Tailscale client version numbering and release track methodology.



](https://tailscale.com/kb/1168/versions)[

#### View the release stages

View the different stages and where they apply.



](https://tailscale.com/kb/1167/release-stages)

## [Comparisons and security](#comparisons-and-security)

You can view comparisons of Tailscale to other products, and get an understanding of the security features in Tailscale.

[

#### View comparisons

Compare Tailscale with other products.



](https://tailscale.com/compare)[

#### View security aspects of Tailscale

Get information about how Tailscale addresses security, privacy, and compliance needs.



](https://tailscale.com/security)

## [Tailscale Community Projects](#tailscale-community-projects)

[Tailscale Community Projects](https://tailscale.com/community/community-projects) is a curated collection of community-supported open source projects built on Tailscale's platform.

[

#### Read about Tailscale Community Projects

Get information about open source offerings provided by Tailscale and community contributors, and how to contribute.



](https://tailscale.com/kb/1531/community-projects)
```



### File: 1372-manage-devices.md

```markdown
# Manage devices

Tailscale provides several ways for you to manage which devices are allowed on your Tailscale network (known as a tailnet). A device can be a personal computer, mobile device, server, or other type of client.

[

#### Add a device

Learn how to add a device to your tailnet.



](https://tailscale.com/kb/1316/device-add)[

#### Device approval

Learn how to ensure a Tailscale network administrator reviews and approves any new devices before they can join your tailnet.



](https://tailscale.com/kb/1099/device-approval)

You can configure Tailscale settings without needing to use the Tailscale command-line interface (CLI), and when a device does not have a built-in GUI.

[

#### Manage devices using the web interface

Find out how to configure Tailscale settings without needing to use the CLI.



](https://tailscale.com/kb/1325/device-web-interface)

Use device posture to collect device attributes and use them as part of connectivity rules within your tailnet.

[

#### Device posture management

Understand how to limit access for devices in your tailnet that do not meet security requirements.



](https://tailscale.com/kb/1288/device-posture)

Integrate your endpoint detection and response (EDR) and mobile device management (MDM) tools with Tailscale's device posture management capabilities:

-   [CrowdStrike Falcon](https://tailscale.com/kb/1289/crowdstrike-zta)
-   [SentinelOne](https://tailscale.com/kb/1390/sentinelone)
-   [1Password XAM](https://tailscale.com/kb/1407/kolide)
-   [Jamf Pro](https://tailscale.com/kb/1409/jamf-pro)
-   [Microsoft Intune](https://tailscale.com/kb/1410/intune)
-   [Kandji](https://tailscale.com/kb/1405/kandji)
```



### File: 1373-manage-users.md

```markdown
# Manage users

Managing users and user access is an essential part of maintaining your Tailscale network (known as a tailnet).

## [Invite users to your tailnet](#invite-users-to-your-tailnet)

There are different ways that you can invite users to join your tailnet.

[

#### Email an invite to users on your custom domain

Learn how to send a team invite by email to one or more email addresses simultaneously.



](https://tailscale.com/kb/1371/invite-users)[

#### Invite any user, independent of your domain

Learn how to send end a one-time use invitation to any user you want to join your tailnet.



](https://tailscale.com/kb/1271/invite-any-user)

## [Manage user access](#manage-user-access)

Control how users are approved to join your tailnet, what access they have to the Tailscale [admin console](https://login.tailscale.com/admin), and when they are removed from your tailnet.

[

#### Enable user approval

Learn how to require that a network administrator review and approve a user before they can join the network.



](https://tailscale.com/kb/1239/user-approval)[

#### Assign roles to users

Learn about the user Identity & Access Management (IAM) roles used to restrict access to the admin console.



](https://tailscale.com/kb/1138/user-roles)[

#### Delete and suspend users

Learn how to remove access for a user previously allowed to use your tailnet.



](https://tailscale.com/kb/1145/remove-team-members)[

#### Configure admin console session timeout

Learn how to configure session timeout in the Tailscale admin console.



](https://tailscale.com/kb/1461/admin-console-session-timeout)

## [Switch the active user in the Tailscale client](#switch-the-active-user-in-the-tailscale-client)

Use fast user switching to quickly switch between two or more logged-in accounts on the same device, without requiring you to re-authenticate.

[

#### Switch between accounts

Learn how to switch between Tailscale accounts on the same device.



](https://tailscale.com/kb/1225/fast-user-switching)
```



### File: 1375-pb-lp.md

```markdown
# Pricing and billing

Use the resources in this section to learn about Tailscale pricing plans and how to manage billing for your Tailscale account.

[

#### Pricing ↗

View and compare all current Tailscale plans.



](https://tailscale.com/pricing)[

#### Pricing & Plans FAQ

View common questions and answers about Tailscale pricing and billing.



](https://tailscale.com/kb/1251/pricing-faq)[

#### Free pricing plans and discounts

Learn about free plans and discount pricing offered by Tailscale.



](https://tailscale.com/kb/1154/free-plans-discounts)[

#### Modify billing information

Learn how to modify your Tailscale billing information.



](https://tailscale.com/kb/1182/billing-information)[

#### Tailscale on Azure Marketplace

Learn how to purchase Tailscale in the Microsoft Azure Marketplace.



](https://tailscale.com/kb/1220/azure-marketplace)
```



### File: 1376-tech-overviews.md

```markdown
# Technical overviews

This section contains in-depth topics about networking and security in a Tailscale network (known as a tailnet).

## [Networking and device connectivity](#networking-and-device-connectivity)

Tailscale modernizes your network through underlying technology to securely connect users, services, and devices.

[

#### Tailscale IP addresses

How IP addresses are assigned in a tailnet.



](https://tailscale.com/kb/1033/ip-and-dns-addresses)[

#### Device connectivity

How devices establish direct or relayed connections in a tailnet.



](https://tailscale.com/kb/1411/device-connectivity)[

#### Designated Encrypted Relay for Packets (DERP) servers

How DERP servers relay tailnet traffic between devices when direct communication isn't possible.



](https://tailscale.com/kb/1232/derp-servers)[

#### IPv4 vs. IPv6

The differences between IPv4 and IPv6 and avoiding misconceptions.



](https://tailscale.com/kb/1134/ipv6-faq)

## [Security, authentication, and encryption](#security-authentication-and-encryption)

Tailscale enforces secure authorization and encryption for tailnet traffic.

[

#### SSH servers

How Tailscale protects SSH servers in a tailnet.



](https://tailscale.com/kb/1009/protect-ssh-servers)[

#### Node keys

How Tailscale uses node keys for secure device authorization.



](https://tailscale.com/kb/1010/node-keys)[

#### Traffic encryption

How Tailscale uses end-to-end encryption for tailnet traffic.



](https://tailscale.com/kb/1504/encryption)
```



### File: 1377-use-cases.md

```markdown
# Use cases

-   [Add multifactor authentication to any legacy service](https://tailscale.com/kb/1005/multifactor-anything)
-   [Connect to colleagues' local servers from anywhere](https://tailscale.com/kb/1034/local-team-server)
-   [Connect to your corporate laptop no matter where you left it](https://tailscale.com/kb/1007/laptop-anywhere)
-   [Corporate VPN, explained](https://tailscale.com/kb/1144/corporate-vpn)
-   [Deploy internal apps anywhere, without changing firewall settings](https://tailscale.com/kb/1012/internal-apps-anywhere)
-   [Deprecate complex physical network (wired and Wi-Fi) security schemes](https://tailscale.com/kb/1006/deprecate-physical-security)
-   [Replacing site-to-site VPNs, AWS VPN, GCP VPN with WireGuard](https://tailscale.com/kb/1120/subnet-site-to-site)
-   [Transparently interconnect microservices between data centers and pods](https://tailscale.com/kb/1008/interconnect-microservices)
-   [VPN from the couch to the office and HQ](https://tailscale.com/kb/1004/all-your-offices)
-   [WireGuard VPN with a dynamic IP address](https://tailscale.com/kb/1122/wireguard-dynamic-ip)
```



### File: 1393-access-control.md

```markdown
# Access control

Tailscale's approach to access control embodies the principles of [least privilege](https://tailscale.com/learn/principle-of-least-privilege) and [zero trust security](https://tailscale.com/kb/1123/zero-trust). By default, all connections between devices in your Tailscale network (known as a [tailnet](https://tailscale.com/kb/1136/tailnet)) are denied unless explicitly permitted through your [tailnet policy file](https://tailscale.com/kb/1395/tailnet-policy-file). This ensures that only authorized users and devices can communicate with each other, with precise controls over what specific resources they can access.

There are two primary methods for creating access control policies: [Grants](https://tailscale.com/kb/1324/grants) and [access control lists (ACLs)](https://tailscale.com/kb/1018/acls). Grants are the recommended method and offer more functionality. However, ACLs will always be supported. Refer to [Grants vs. ACLs](https://tailscale.com/kb/1467/grants-vs-acls).

Access control in Tailscale uses various [targets and selectors](https://tailscale.com/kb/1396/targets) to identify resources, which are also defined in the tailnet policy file. These include autogroups, custom groups, tags, IP addresses, and individual users, and let you create flexible policies that adapt to your organization's structure.

Explore the following resources to learn more:

-   [Tailnet policy file](https://tailscale.com/kb/1395/tailnet-policy-file)
-   [Policy syntax](https://tailscale.com/kb/1337/policy-syntax)
-   [Targets and selectors](https://tailscale.com/kb/1396/targets)
-   [Grants vs. ACLs](https://tailscale.com/kb/1467/grants-vs-acls)

## [Grants](#grants)

Grants represent Tailscale's modern approach to access control, providing a unified syntax for managing permissions across both network and application layers. Each grant defines which sources can access which destinations, along with the specific capabilities they're allowed to use at both the network and application levels.

Explore the grants documentation:

-   [Grants overview](https://tailscale.com/kb/1324/grants)
-   [Grant syntax reference](https://tailscale.com/kb/1538/grants-syntax)
-   [Application capabilities](https://tailscale.com/kb/1537/grants-app-capabilities)
-   [Troubleshooting grants](https://tailscale.com/kb/1468/grants-troubleshooting)
-   [Example grants](https://tailscale.com/kb/1458/grant-samples)

## [Access control lists (ACLs)](#access-control-lists-acls)

Tailscale recommends [migrating to grants](https://tailscale.com/kb/1542/grants-migration).

Access control lists ([ACLs](https://tailscale.com/kb/1018/acls)) represent Tailscale's original approach to network layer security. The recommended approach is to use grants. However, Tailscale will always support ACLs.

Explore the ACLs documentation:

-   [ACLs overview](https://tailscale.com/kb/1018/acls)
-   [ACL syntax reference](https://tailscale.com/kb/1337/policy-syntax)
-   [Example ACL policies](https://tailscale.com/kb/1192/acl-samples)

## [Tailscale SSH](#tailscale-ssh)

Tailscale SSH integrates with the access control system to provide secure SSH access between devices in your tailnet. Instead of managing SSH keys, Tailscale SSH leverages your tailnet's identity system to authenticate and authorize connections based on the rules defined in your tailnet policy file.

[Learn more about Tailscale SSH](https://tailscale.com/kb/1193/tailscale-ssh).
```



### File: 1415-quick-guides.md

```markdown
# Tailscale quick guides

This section provides condensed topics to help you quickly set up specific parts of your tailnet. For additional guidance on getting started, see [Tailscale quickstart](https://tailscale.com/kb/1017/install).

[

#### Use exit nodes

Learn how to quickly configure exit nodes to route traffic through a specific device in your tailnet, and configure devices to use an exit node.



](https://tailscale.com/kb/1408/quick-guide-exit-nodes)[

#### Configure a subnet router

Learn how to quickly configure a subnet router you to relay access in your network, including resources where Tailscale cannot be installed.



](https://tailscale.com/kb/1406/quick-guide-subnets)[

#### Host a website using a tailnet device

Learn how to host a website from a device in your tailnet.



](https://tailscale.com/kb/1310/quick-guide-host-websites)[

#### Install Tailscale on an AWS VM

Install the Tailcale client on an AWS Linux VM and use some common features.



](https://tailscale.com/kb/1449/quick-guide-aws)[

#### SSH into a Linux VM

Learn how to SSH into a Linux VM.



](https://tailscale.com/kb/1308/quick-guide-ssh-linux-vm)[

#### Access your virtual private cloud (VPC)

Learn how to access your virtual private cloud (VPC) and configure a subnet router.



](https://tailscale.com/kb/1309/quick-guide-access-vpc)[

#### Add a Docker container

Quickly connect a Docker container to a tailnet.



](https://tailscale.com/kb/1453/quick-guide-docker)
```



### File: 1430-automations.md

```markdown
# Automations

Streamline and [automate your Tailscale workflow](https://tailscale.com/learn/provision-manage-and-query-tailscale-resources-programmatically-as-code) using official infrastructure as code (IaC) providers and integrations.

## [Infrastructure as code](#infrastructure-as-code)

[Infrastructure as code (IaC)](https://tailscale.com/kb/1370/infrastructure-as-code) is a method of managing infrastructure using machine-readable definition files rather than physical hardware or interactive configuration tools. Tailscale offers official providers for Terraform and Pulumi that let you interact with the [Tailscale API](https://tailscale.com/kb/1101/api) to manage various Tailscale resources, such as access control policies, devices, nameservers, and other configurations.

[

#### Manage Tailscale resources using Terraform

Use the Terraform Tailscale provider to interact with the Tailscale API.



](https://tailscale.com/kb/1210/terraform-provider)[

#### Manage Tailscale resources using Pulumi

Learn how to use the Pulumi Tailscale provider to interact with the Tailscale API.



](https://tailscale.com/kb/1211/pulumi-provider)

## [Tailscale Shortcuts for macOS and iOS](#tailscale-shortcuts-for-macos-and-ios)

Tailscale works with the Shortcuts app on macOS and iOS to provide several built-in shortcut actions, allowing you to automate tasks. For example, you can create shortcuts to connect your device to a tailnet, use an exit node, or switch user accounts.

[

#### macOS and iOS shortcuts

Learn how Tailscale works with the Shortcuts app, allowing you to automate tasks.



](https://tailscale.com/kb/1233/mac-ios-shortcuts)
```



### File: 1431-manage-account.md

```markdown
# Manage your organization

Use these resources to manage your contact, billing, tailnet name, and domain name information.

## [Manage your contact information](#manage-your-contact-information)

We may need to contact you for matters related to general account information, security, and billing. You can customize your contact information, depending on the type of interaction.

[

#### Contact preferences

Learn how to manage your Tailscale contact information.



](https://tailscale.com/kb/1224/contact-preferences)

## [Manage your plan and billing](#manage-your-plan-and-billing)

Use the following resources to learn more about the plans we offer and how to modify an existing Tailscale account based on your needs.

[

#### Pricing ↗

View and compare all current Tailscale plans.



](https://tailscale.com/pricing)[

#### Pricing and plans FAQ

View common questions and answers about Tailscale pricing and billing.



](https://tailscale.com/kb/1251/pricing-faq)[

#### Free pricing plans and discounts

Learn about free plans and discount pricing offered by Tailscale.



](https://tailscale.com/kb/1154/free-plans-discounts)[

#### Modify billing information

Learn how to modify your Tailscale billing information.



](https://tailscale.com/kb/1182/billing-information)[

#### Tailscale on Azure Marketplace

Learn how to purchase Tailscale in the Microsoft Azure Marketplace.



](https://tailscale.com/kb/1220/azure-marketplace)

## [Manage your tailnet names and domain](#manage-your-tailnet-names-and-domain)

Learn how to manage tailnet names and domains with Tailscale.

[

#### Tailnet DNS name

A tailnet DNS name identifies your tailnet and is used in features such as MagicDNS, HTTPS certificates, and sharing.



](https://tailscale.com/kb/1217/tailnet-name)[

#### Domain ownership

Learn how your tailnet is tied to your domain.



](https://tailscale.com/kb/1259/domain-ownership)
```



### File: 1432-get-support.md

```markdown
# Get support

Use the various resources that Tailscale offers to help you troubleshoot your issues and interact with our support resources.

## [Read our troubleshooting guides](#read-our-troubleshooting-guides)

Are you encountering issues or have questions about using Tailscale? Our troubleshooting content covers a wide variety of topics and is continuously updated.

[

#### Troubleshooting guide

Learn how to troubleshoot common tailnet scenarios.



](https://tailscale.com/kb/1023/troubleshooting)[

#### Troubleshooting device connectivity

Learn how to troubleshoot device connectivity.



](https://tailscale.com/kb/1411/device-connectivity)

## [Contact support](#contact-support)

There are multiple ways of interacting with the Tailscale Support team. Choose the option that best suits your needs.

[

#### Support options

Explore options for resolving an issue.



](https://tailscale.com/kb/1250/support-options)[

#### Contact support

Request assistance from the Support team.



](https://tailscale.com/contact/support)

## [Send us a bug report](#send-us-a-bug-report)

One of the most effective ways we can help resolve an issue is to have you generate and send us a bug report. This provides useful insights to determine the cause and help fix your issue.

[

#### Generate a bug report

Learn how to generate a bug report to help troubleshoot issues.



](https://tailscale.com/kb/1227/bug-report)
```



### File: 1443-just-in-time-access.md

```markdown
# Just-in-time access

Tailscale provides several ways for you to provide just-in-time (JIT) access to resources in your Tailscale network (known as a tailnet). For example, you can provide an appropriate level of access to an engineer for a limited amount of time so they can perform maintenance on a server.

JIT access works in conjunction with access control policies to determine access for users and devices in your tailnet. You manage access control policies in the [tailnet policy file](https://tailscale.com/kb/1395/tailnet-policy-file). For JIT access, you use automation to provide access to someone for a limited time, allowing them to perform a task. There are a few ways to achieve this.

## [Provide just-in-time access](#provide-just-in-time-access)

Tailscale lets you manage JIT access to network resources based on device posture attributes, which are key-value pairs of data attached to devices that can be used as part of the tailnet policy file.

[

#### Use device posture attributes.

Manage JIT access with device posture attributes.



](https://tailscale.com/kb/1383/device-posture-for-jit)

Tailscale partners with other companies for JIT access workflow integrations.

[

#### Use a third-party integration.

Manage JIT access by using a third-party integration.



](https://tailscale.com/kb/1374/jit-access-integrations)

The Tailscale API lets you manage tailnet policy files, including for JIT access. For details, refer to the [Policy File](https://tailscale.com/api#tag/policyfile) section in the Tailscale API documentation.

[

#### Use the Tailscale API.

Manage JIT access by using the Tailscale API.



](https://tailscale.com/kb/1101/api)

Tailscale lets you manage access to network resources based on [group membership](https://tailscale.com/kb/1290/user-group-provisioning#syncing-group-membership) by syncing groups from SCIM-integrated identity providers to Tailscale.

[

#### Use group membership syncing.

Use group membership syncing and grant JIT access by adding a user to a group.



](https://tailscale.com/kb/1290/user-group-provisioning)
```



### File: 1458-grant-examples.md

```markdown
# Grant examples

[Grants](https://tailscale.com/kb/1324/grants) are the modern way to define access control rules in the [tailnet policy file](https://tailscale.com/kb/1395/tailnet-policy-file). They replace the [legacy ACL format](https://tailscale.com/kb/1018/acls) with a more flexible and feature-rich syntax.

This topic provides a comprehensive collection of grant examples for Tailscale tailnet policies, organized from simplest to most complex scenarios. Each example includes context, the complete configuration (as notes or a complete tailnet policy file), and implementation notes to help you understand how to apply similar patterns in your environment.

Example

Description

[Allow all](#allow-all)

Provides the default policy that lets all connections between devices in your tailnet. Devices shared from another network can only respond to incoming connections.

[Allow users access to their own devices](#allow-users-access-to-their-own-devices)

Enables members of your tailnet to access their own devices. This is a basic access control setup focusing on self-device management.

[Allow using exit nodes](#allow-using-exit-nodes)

Permits all members of your tailnet to route internet traffic through any available exit nodes.

[Allow based on purpose using tags](#allow-based-on-purpose-using-tags)

Enforces communication boundaries between application components, allowing traffic only between adjacent tiers for secure multi-tier applications.

[Allow access to different environments by group](#allow-access-to-different-environments-by-group)

Implements group-based access control with port restrictions for shared resources, giving different teams varying privilege levels.

[Route traffic through exit nodes based on location](#route-traffic-through-exit-nodes-based-on-location)

Segments exit node usage based on user geographical location, directing users to use exit nodes closest to them for optimal performance.

[Allow access to resources based on device posture](#allow-access-to-resources-based-on-device-posture)

Controls access to resources through different subnet routers based on device compliance, ensuring only compliant devices can access sensitive resources.

[Route group traffic through app connectors](#route-group-traffic-through-app-connectors)

Segments application access through specific app connectors for different user groups, providing secure access to applications without direct exposure.

[Customize `autogroup:internet`](#customize-autogroup-internet)

Creates custom internet access rules using IP sets and routes traffic through specific subnet routers, allowing more granular control over external resource access.

[Allow access to different environments using device posture](#allow-access-to-different-environments-using-device-posture)

Controls access to different infrastructure environments based on device security posture, enforcing stricter security for more sensitive environments.

[Allow access to Kubernetes Operator with privileges](#allow-access-to-kubernetes-operator-with-privileges)

Manages Kubernetes Operator access with different privilege levels, granting administrative or read-only access to different users through Tailscale's Kubernetes capability.

[Application peering](#application-peering)

Enables connections between applications across cloud providers and SaaS applications, allowing secure service-to-service communication across environments.

[CI/CD development pipeline](#cicd-development-pipeline)

Restricts access to deployment pipeline components based on team roles, securing the deployment pipeline while enabling automated deployments.

[Monitor application access](#monitor-application-access)

Enables monitoring server access to services on specific ports across the tailnet, balancing observability needs with security.

[Network microsegmentation](#network-microsegmentation)

Implements logical tailnet segmentation with support team access across segments, limiting the blast radius of potential security incidents.

[VPC access](#vpc-access)

Enables developer access to VPC resources with subnet peering capabilities, providing secure access to cloud resources without public exposure.

[Use Tailscale Peer Relays](#use-tailscale-peer-relays)

Enables devices in your tailnet to act as high-throughput relay servers.

## [Allow all](#allow-all)

Availability

Related concepts

[All plans](https://tailscale.com/pricing)

[grants](https://tailscale.com/kb/1324/grants)

This example represents the most permissive default policy for a Tailscale tailnet (known as a [tailnet](https://tailscale.com/kb/1136/tailnet)). Use this when you want minimal restrictions for a trusted environment, such as for small teams or personal tailnets where all devices should freely communicate with each other. This example is often used as a starting point before implementing more restrictive policies.

```json
{
  "grants": [
    {
      "src": ["*"],
      "dst": ["*"],
      "ip": ["*"]
    }
  ]
}
```

You can use the [visual policy editor](https://tailscale.com/kb/1550/visual-editor) to manage your tailnet policy file. Refer to the [visual editor reference](https://tailscale.com/kb/1587/visual-editor-reference) for guidance on using the visual editor.

This example uses wildcards for all three key parameters. The source (`src`) wildcard lets any device or user start connections. The destination (`dst`) wildcard permits connections to any device in the tailnet. The IP protocol (`ip`) wildcard lets all types of traffic, including TCP, UDP, and ICMP on any port.

Even with this permissive policy, devices [shared](https://tailscale.com/kb/1084/sharing) with you from another tailnet cannot access devices in your tailnet. Shared devices can only respond to incoming connections from your tailnet, not start them.

## [Allow users access to their own devices](#allow-users-access-to-their-own-devices)

Availability

Related concepts

[Personal, Personal Plus, Starter, Premium, and Enterprise](https://tailscale.com/pricing)

[autogroups](https://tailscale.com/kb/1396/targets#autogroups), [grants](https://tailscale.com/kb/1324/grants)

This example implements a basic form of user isolation while maintaining self-access using [autogroups](https://tailscale.com/kb/1396/targets#autogroups). It's an excellent starting point for implementing the [principle of least privilege](https://tailscale.com/learn/principle-of-least-privilege) while ensuring users can still access their remote workstations, servers, or other personal resources. This approach is suitable for organizations where data separation between users is important.

```json
{
  "grants": [
    {
      "src": ["autogroup:member"],
      "dst": ["autogroup:self"],
      "ip": ["*"]
    }
  ]
}
```

You can use the [visual policy editor](https://tailscale.com/kb/1550/visual-editor) to manage your tailnet policy file. Refer to the [visual editor reference](https://tailscale.com/kb/1587/visual-editor-reference) for guidance on using the visual editor.

The `autogroup:member` source represents all authenticated users in your tailnet, while `autogroup:self` dynamically refers to devices owned by the connecting user. This creates natural isolation between users while maintaining full self-access. You don't need to create [custom groups](https://tailscale.com/kb/1396/targets#groups) because these autogroups are built into Tailscale.

This example prevents lateral movement between user devices but does not establish rules for shared resources. To allow access to common resources like file servers, you would need to add additional grants with appropriate [tags](https://tailscale.com/kb/1068/tags) or [groups](https://tailscale.com/kb/1396/targets#groups). This example also doesn't prevent a user from accessing another user's device if they are explicitly invited through Tailscale [sharing](https://tailscale.com/kb/1084/sharing).

## [Allow using exit nodes](#allow-using-exit-nodes)

Availability

Related concepts

[Personal, Personal Plus, Starter, Premium, and Enterprise](https://tailscale.com/pricing)

[autogroups](https://tailscale.com/kb/1396/targets#autogroups), [grants](https://tailscale.com/kb/1324/grants)

This example uses [autogroups](https://tailscale.com/kb/1396/targets#autogroups) to enable users to route their internet traffic through [exit nodes](https://tailscale.com/kb/1103/exit-nodes) in your tailnet. This is particularly useful for accessing region-restricted content, protecting traffic on untrusted tailnets, or maintaining a consistent outbound IP address. You can configure exit nodes on dedicated servers, cloud instances, or even personal devices (such as Apple TVs) with sufficient bandwidth.

```json
{
  "grants": [
    {
      "src": ["autogroup:member"],
      "dst": ["autogroup:internet"],
      "ip": ["*"]
    }
  ]
}
```

You can use the [visual policy editor](https://tailscale.com/kb/1550/visual-editor) to manage your tailnet policy file. Refer to the [visual editor reference](https://tailscale.com/kb/1587/visual-editor-reference) for guidance on using the visual editor.

The `autogroup:member` source lets all authenticated users in your tailnet use exit nodes. The `autogroup:internet` destination represents all possible internet destinations outside your tailnet. The wildcard IP protocol lets all types of traffic route through the exit nodes.

For this example to be effective, you must have at least one device in your tailnet configured as an [exit node](https://tailscale.com/kb/1103/exit-nodes). This grant only permits the routing relationship; you still need to configure and approve exit nodes separately in the Tailscale admin console or through device configuration. Users will also need to select the exit node in their Tailscale client settings to use the exit node.

## [Allow based on purpose using tags](#allow-based-on-purpose-using-tags)

Availability

Related concepts

[All plans](https://tailscale.com/pricing)

[grants](https://tailscale.com/kb/1324/grants), [tags](https://tailscale.com/kb/1068/tags)

This example enforces communication boundaries between application components, ensuring each tier can only communicate with adjacent tiers. It's ideal for implementing [zero-trust architectures](https://tailscale.com/kb/1123/zero-trust) where you want strict control over the flow of traffic between application layers. This approach is commonly used in multi-tier applications like web services with frontend, backend, and database components.

```json
{
  "grants": [
    {
      "src": ["tag:frontend"],
      "dst": ["tag:backend"],
      "ip": ["*"]
    },
    {
      "src": ["tag:backend"],
      "dst": ["tag:logging"],
      "ip": ["*"]
    }
  ]
}
```

You can use the [visual policy editor](https://tailscale.com/kb/1550/visual-editor) to manage your tailnet policy file. Refer to the [visual editor reference](https://tailscale.com/kb/1587/visual-editor-reference) for guidance on using the visual editor.

The first grant lets devices tagged as `frontend` communicate with devices tagged as `backend`. The second grant lets `backend` devices communicate with `logging` services. This creates a directed flow of traffic that matches the intended application architecture, preventing devices from bypassing intermediate layers.

To implement this example, you need to define the [tags](https://tailscale.com/kb/1068/tags) using the `tagOwners` section in your tailnet policy file to control who can assign these tags to devices. You also need to explicitly tag each device with its appropriate role.

## [Allow access to different environments by group](#allow-access-to-different-environments-by-group)

Availability

Related concepts

[Premium and Enterprise](https://tailscale.com/pricing)

[grants](https://tailscale.com/kb/1324/grants), [groups](https://tailscale.com/kb/1396/targets#groups), [tags](https://tailscale.com/kb/1068/tags)

This example implements [group](https://tailscale.com/kb/1396/targets#groups)\-based access control with port restrictions. It's commonly used when you have shared resources (like internal tools) that different teams need to access, but with varying privilege levels. This approach enables precise control over which protocols and ports each group can use, balancing accessibility with security.

```json
{
  "grants": [
    {
      "src": ["group:eng"],
      "dst": ["tag:internal-tools"],
      "ip": ["*"]
    },
    {
      "src": ["group:sales"],
      "dst": ["tag:internal-tools"],
      "ip": ["tcp:443", "tcp:22"]
    },
    {
      "src": ["*"],
      "dst": ["tag:dns"],
      "ip": ["udp:53"]
    }
  ]
}
```

You can use the [visual policy editor](https://tailscale.com/kb/1550/visual-editor) to manage your tailnet policy file. Refer to the [visual editor reference](https://tailscale.com/kb/1587/visual-editor-reference) for guidance on using the visual editor.

The first grant gives the engineering team (`group:eng`) unrestricted access to internal tools, allowing all protocols and ports. The second grant provides limited access to the sales team (`group:sales`), restricting them to only HTTPS (port `443`) and SSH (port `22`). The third grant ensures everyone in the tailnet can access DNS services (UDP port `53`).

To implement this example, you need to define the [groups](https://tailscale.com/kb/1396/targets#groups) and [tags](https://tailscale.com/kb/1068/tags) referenced in your tailnet policy file. The groups would list the email addresses of team members, while the tags would be applied to the relevant devices. This approach requires ongoing maintenance as team memberships change. Consider implementing automation for group management if your organization has frequent personnel changes or a large number of users.

## [Route traffic through exit nodes based on location](#route-traffic-through-exit-nodes-based-on-location)

Availability

Related concepts

[Premium and Enterprise](https://tailscale.com/pricing)

[autogroups](https://tailscale.com/kb/1396/targets#autogroups), [grants](https://tailscale.com/kb/1324/grants), [groups](https://tailscale.com/kb/1396/targets#groups), [tags](https://tailscale.com/kb/1068/tags), [via](https://tailscale.com/kb/1378/via)

This example segments exit node usage based on user geographical location. When you have exit nodes in different locations, you might want to direct users to use the exit node closest to them for optimal performance. This approach helps ensure users connect through exit nodes in appropriate jurisdictions for compliance purposes or to optimize tailnet latency.

```json
{
  "grants": [
    {
      "src": ["group:nyc"],
      "dst": ["autogroup:internet"],
      "via": ["tag:exit-node-nyc"],
      "ip": ["*"]
    },
    {
      "src": ["group:sea"],
      "dst": ["autogroup:internet"],
      "via": ["tag:exit-node-sea"],
      "ip": ["*"]
    },
    {
      "src": ["group:eng"],
      "dst": ["autogroup:internet"],
      "ip": ["*"]
    }
  ]
}
```

You can use the [visual policy editor](https://tailscale.com/kb/1550/visual-editor) to manage your tailnet policy file. Refer to the [visual editor reference](https://tailscale.com/kb/1587/visual-editor-reference) for guidance on using the visual editor.

This example uses the `via` field to force traffic through specific devices (this is known as [route filtering](https://tailscale.com/kb/1378/via)). Users in the Toronto office (`group:tor`) and Seattle office (`group:sea`) must use exit nodes in their respective locations, while the engineering team (`group:eng`) can use any exit node or connect directly. This example enforces the routing path without requiring users to manually select the appropriate exit node.

For this example to work, you need to define the referenced groups in your policy and tag the appropriate exit nodes. Each exit node must also be properly configured in the Tailscale admin console. Without the `via` field, users could choose any available exit node, potentially leading to suboptimal routing or compliance issues.

If a specified exit node becomes unavailable, users in that group will not be able to access the internet through Tailscale until the exit node becomes available, or you update the policy.

## [Allow access to resources based on device posture](#allow-access-to-resources-based-on-device-posture)

Availability

Related concepts

[Enterprise](https://tailscale.com/pricing)

[autogroups](https://tailscale.com/kb/1396/targets#autogroups), [grants](https://tailscale.com/kb/1324/grants), [groups](https://tailscale.com/kb/1396/targets#groups), [postures](https://tailscale.com/kb/1288/device-posture), [srcPosture](https://tailscale.com/kb/1288/device-posture), [tags](https://tailscale.com/kb/1068/tags), [via](https://tailscale.com/kb/1378/via)

This example controls access to resources through different [subnet routers](https://tailscale.com/kb/1019/subnets) based on device compliance. [Device posture](https://tailscale.com/kb/1288/device-posture) checks ensure that only compliant devices can access sensitive resources. This approach demonstrates controlling subnet access based on device security status, allowing direct access for compliant devices while routing others through controlled gateways.

```json
{
  "postures": {
    "posture:latestMac": [
      "node:os == 'macos'",
      "node:osVersion == '13.4.0'",
      "node:tsReleaseTrack == 'stable'"
    ]
  },
  "grants": [
    {
      "src": ["group:eng"],
      "srcPosture": ["posture:latestMac"],
      "dst": ["192.0.2.0/24"],
      "ip": ["*"]
    },
    {
      "src": ["autogroup:member"],
      "dst": ["192.0.2.0/24"],
      "via": ["tag:office-router"],
      "ip": ["*"]
    }
  ]
}
```

You can use the [visual policy editor](https://tailscale.com/kb/1550/visual-editor) to manage your tailnet policy file. Refer to the [visual editor reference](https://tailscale.com/kb/1587/visual-editor-reference) for guidance on using the visual editor.

The example defines a posture check called `posture:latestMac` that verifies the device is running macOS version 13.4.0 with a stable [Tailscale client version](https://tailscale.com/kb/1168/versions). The first grant lets engineering team members with compliant devices access the subnet directly. The second grant routes all other users through the office router, adding an additional security layer for non-compliant devices.

To implement this example, you need to define the posture check parameters, create the referenced [group](https://tailscale.com/kb/1396/targets#groups), and [tag](https://tailscale.com/kb/1068/tags) at least one device as the office subnet router. The posture checks evaluate in real-time, allowing automatic privilege adjustment as device status changes.

This example requires careful maintenance of the posture requirements as OS and Tailscale versions evolve. Setting version requirements too restrictively could accidentally block legitimate users who haven't yet updated their systems.

## [Route group traffic through app connectors](#route-group-traffic-through-app-connectors)

Availability

Related concepts

[Premium and Enterprise](https://tailscale.com/pricing)

[autogroups](https://tailscale.com/kb/1396/targets#autogroups), [grants](https://tailscale.com/kb/1324/grants), [groups](https://tailscale.com/kb/1396/targets#groups), [tags](https://tailscale.com/kb/1068/tags), [via](https://tailscale.com/kb/1378/via)

This example segments application access through specific [app connectors](https://tailscale.com/kb/1281/app-connectors) for different user groups. App connectors provide secure access to specific applications without exposing them directly to users. This approach ensures that users can only access certain applications through designated secure channels, adding authentication and monitoring points in the connection path.

```json
{
  "grants": [
    {
      "src": ["group:github-users"],
      "dst": ["autogroup:internet"],
      "ip": ["*"],
      "via": ["tag:github-appconnector"]
    },
    {
      "src": ["group:salesforce-users"],
      "dst": ["autogroup:internet"],
      "ip": ["*"],
      "via": ["tag:salesforce-appconnector"]
    }
  ]
}
```

You can use the [visual policy editor](https://tailscale.com/kb/1550/visual-editor) to manage your tailnet policy file. Refer to the [visual editor reference](https://tailscale.com/kb/1587/visual-editor-reference) for guidance on using the visual editor.

This example directs different user groups through different app connectors based on their service needs. Users in the `github-users` group must go through the GitHub app connector, while `salesforce-users` must go through the Salesforce app connector. The `via` field enforces these routing paths, ensuring traffic uses the secure connection method.

For this example to work, you need to define the user groups and set up the app connectors with appropriate tags. You must also configure each app connector for its specific application.

This example requires maintaining separate connectors for each application, which can increase operational overhead but provides strong security isolation. If an app connector fails, users will lose access to that application until the connector becomes available, or you update the policy.

## [Customize autogroup internet](#customize-autogroup-internet)

Availability

Related concepts

[Premium and Enterprise](https://tailscale.com/pricing)

[grants](https://tailscale.com/kb/1324/grants), [groups](https://tailscale.com/kb/1396/targets#groups), [ipsets](https://tailscale.com/kb/1387/ipsets), [tags](https://tailscale.com/kb/1068/tags), [via](https://tailscale.com/kb/1378/via)

This example creates custom internet access rules using [IP sets](https://tailscale.com/kb/1387/ipsets) and routes traffic through specific [subnet routers](https://tailscale.com/kb/1019/subnets). Sometimes you need more granular control over which external resources users can access. This approach lets you define custom subsets of internet addresses and apply different routing rules to each subset, useful for excluding specific services from general internet access rules.

```json
{
  "ipsets": {
    "ipset:internet": [
      "add autogroup:internet",
      "remove ipset:cdn-edge",
      "remove ipset:partner-net"
    ],
    "ipset:cdn-edge": ["198.51.100.6", "198.51.100.7", "198.51.100.13", "198.51.100.14"],
    "ipset:partner-net": ["203.0.113.0/24"]
  },
  "grants": [
    {
      "src": ["group:sea"],
      "dst": ["ipset:internet"],
      "ip": ["*"],
      "via": ["tag:officerouter-sea"]
    },
    {
      "src": ["group:lon"],
      "dst": ["ipset:internet"],
      "ip": ["*"],
      "via": ["tag:officerouter-lon"]
    }
  ]
}
```

You can use the [visual policy editor](https://tailscale.com/kb/1550/visual-editor) to manage your tailnet policy file. Refer to the [visual editor reference](https://tailscale.com/kb/1587/visual-editor-reference) for guidance on using the visual editor.

This example creates a custom `ipset:internet` that includes all internet addresses except specific CDN edge nodes and partner networks. The IP set definitions use `add` and `remove` operations to compose the final set. Users in Seattle (`group:sea`) and London (`group:lon`) are routed through their respective office routers to access this customized internet definition.

To implement this example, you need to define the IP sets with the appropriate network addresses, create user groups for different locations, and tag the office routers accordingly. This example requires careful management of IP address lists, especially if the excluded networks change frequently. Consider using automation to keep these IP sets updated if they reference dynamic cloud resources or frequently changing partner networks.

## [Allow access to different environments using device posture](#allow-access-to-different-environments-using-device-posture)

Availability

Related concepts

[Enterprise](https://tailscale.com/pricing)

[grants](https://tailscale.com/kb/1324/grants), [groups](https://tailscale.com/kb/1396/targets#groups), [ipsets](https://tailscale.com/kb/1387/ipsets), [postures](https://tailscale.com/kb/1288/device-posture), [srcPosture](https://tailscale.com/kb/1288/device-posture), [tags](https://tailscale.com/kb/1068/tags), [via](https://tailscale.com/kb/1378/via)

This example controls access to different infrastructure environments based on device security posture. In environments with multiple stages (development, staging, production), you often want stricter security requirements for accessing more sensitive environments. This approach enforces progressive security postures based on environment sensitivity.

```json
{
  "grants": [
    {
      "src": ["group:devs"],
      "dst": ["ipset:prod-infra"],
      "ip": ["*"],
      "via": ["tag:prod-connector"],
      "srcPosture": ["posture:strict-mac"]
    },
    {
      "src": ["group:devs"],
      "dst": ["ipset:stg-infra"],
      "ip": ["*"],
      "via": ["tag:stg-connector"],
      "srcPosture": ["posture:semi-strict-mac"]
    },
    {
      "src": ["group:devs"],
      "dst": ["ipset:dev-infra"],
      "ip": ["*"],
      "via": ["tag:dev-connector"],
      "srcPosture": ["posture:any-mac"]
    }
  ]
}
```

You can use the [visual policy editor](https://tailscale.com/kb/1550/visual-editor) to manage your tailnet policy file. Refer to the [visual editor reference](https://tailscale.com/kb/1587/visual-editor-reference) for guidance on using the visual editor.

This example routes developer traffic through different app connectors based on the destination environment and the device's security [posture](https://tailscale.com/kb/1288/device-posture). Production infrastructure requires the strictest device security policy, staging has moderate requirements, and development has minimal requirements. Users access each environment through a dedicated connector that can implement additional security controls.

To implement this example, you need to define the posture checks, IP sets for each environment, and tag the appropriate connector devices. The referenced postures, IP sets, groups, and tags that you need to define elsewhere in your tailnet policy file. This example provides defense in depth by combining device security validation with network path control. Maintaining separate security posture definitions requires careful coordination when updating requirements to avoid accidentally blocking access to critical environments.

## [Allow access to the Kubernetes Operator with privileges](#allow-access-to-the-kubernetes-operator-with-privileges)

Availability

Related concepts

[Premium and Enterprise](https://tailscale.com/pricing)

app, [grants](https://tailscale.com/kb/1324/grants), [groups](https://tailscale.com/kb/1396/targets#groups), [tags](https://tailscale.com/kb/1068/tags)

This example manages [Kubernetes Operator](https://tailscale.com/kb/1236/kubernetes-operator) access with different privilege levels. When running Kubernetes clusters in your tailnet, you might want to grant different users different levels of access. This example shows how to grant administrative privileges to the production team and read-only access to other users through Tailscale's Kubernetes capability.

```json
{
  "grants": [
    {
      "src": [
        "group:prod"
      ],
      "dst": [
        "tag:k8s-operator"
      ],
      "app": {
        "tailscale.com/cap/kubernetes": [
          {
            "impersonate": {
              "groups": [
                "system:masters"
              ]
            }
          }
        ]
      }
    },
    {
      "src": [
        "group:k8s-readers"
      ],
      "dst": [
        "tag:k8s-operator"
      ],
      "app": {
        "tailscale.com/cap/kubernetes": [
          {
            "impersonate": {
              "groups": [
                "tailnet-readers"
              ]
            }
          }
        ]
      }
    }
  ]
}
```

You can use the [visual policy editor](https://tailscale.com/kb/1550/visual-editor) to manage your tailnet policy file. Refer to the [visual editor reference](https://tailscale.com/kb/1587/visual-editor-reference) for guidance on using the visual editor.

This example uses the `app` field to grant specific Kubernetes capabilities. The production team (`group:prod`) can impersonate the `system:masters` group with admin privileges, while the readers group (`group:k8s-readers`) can only impersonate the `tailnet-readers` group with read-only access. You must tag the Kubernetes Operator device with `tag:k8s-operator`.

To implement this example, you need to define the user [groups](https://tailscale.com/kb/1396/targets#groups) and [tag](https://tailscale.com/kb/1068/tags) the Kubernetes Operator device. You also need to configure the Kubernetes cluster to recognize the impersonated groups and grant them appropriate permissions. This example lets you manage Kubernetes access through Tailscale without modifying the underlying Kubernetes configuration. The `tailnet-readers` group must exist in your Kubernetes configuration with appropriate read-only permissions for this to work properly.

## [Application peering](#application-peering)

Availability

Related concepts

[Premium and Enterprise](https://tailscale.com/pricing)

[grants](https://tailscale.com/kb/1324/grants), [groups](https://tailscale.com/kb/1396/targets#groups), [tags](https://tailscale.com/kb/1068/tags)

Application peering refers to establishing a bidirectional peer-to-peer connection between two applications or application environments.

This example enables connections between applications across cloud providers and SaaS applications. This approach is useful for connecting applications or services across multiple cloud environments. For example, you might want to stream data between databases in different cloud providers or enable secure service-to-service communication across environments without exposing services publicly.

```json
{
  "groups": {
    "group:infra": ["carl@example.com"]
  },
  "grants": [
    {
      "src": ["tag:database", "tag:gcp", "tag:aws"],
      "dst": ["tag:database"],
      "ip": ["*"]
    }
  ],
  "tagOwners": {
    "tag:database": ["group:infra"],
    "tag:gcp": ["group:infra"],
    "tag:aws": ["group:infra"]
  }
}
```

You can use the [visual policy editor](https://tailscale.com/kb/1550/visual-editor) to manage your tailnet policy file. Refer to the [visual editor reference](https://tailscale.com/kb/1587/visual-editor-reference) for guidance on using the visual editor.

This example enables bidirectional communication between databases and lets devices tagged with cloud provider tags access the databases. The infrastructure team (`group:infra`) can manage which devices get which [tags](https://tailscale.com/kb/1068/tags), giving them control over which services can communicate. This example uses a combination of tags to identify both the function of a device (`database`) and its environment (`gcp`, `aws`).

To implement this example, you need to define the infrastructure team group and apply appropriate tags to your cloud resources. Each cloud resource needs a running Tailscale client to join the tailnet. This example creates a secure overlay tailnet across cloud providers without requiring complex VPN configurations or public IP exposure.

Be aware that this example lets any device with the `database` tag to communicate with any other database, which might be too permissive for environments with strict data isolation requirements.

## [CI/CD development pipeline](#cicd-development-pipeline)

Availability

Related concepts

[Premium and Enterprise](https://tailscale.com/pricing)

[grants](https://tailscale.com/kb/1324/grants), [groups](https://tailscale.com/kb/1396/targets#groups), [tags](https://tailscale.com/kb/1068/tags)

This example restricts access to deployment pipeline components based on team roles. DevOps and SRE (site reliability engineering) teams often need to secure deployment pipelines, ensuring that developers can access development tools while restricting production access to the DevOps team. This setup creates appropriate boundaries in your software delivery process while enabling automated deployments.

```json
{
  "groups": {
    "group:dev": ["alice@example.com", "bob@example.com"],
    "group:devops": ["carl@example.com"]
  },
  "grants": [
    {
      "src": ["group:dev"],
      "dst": ["tag:dev"],
      "ip": ["*"]
    },
    {
      "src": ["group:devops"],
      "dst": ["tag:ci", "tag:prod"],
      "ip": ["*"]
    }
  ],
  "tagOwners": {
    "tag:ci": ["group:devops"],
    "tag:dev": ["group:devops", "tag:ci"],
    "tag:prod": ["group:devops", "tag:ci"]
  }
}
```

You can use the [visual policy editor](https://tailscale.com/kb/1550/visual-editor) to manage your tailnet policy file. Refer to the [visual editor reference](https://tailscale.com/kb/1587/visual-editor-reference) for guidance on using the visual editor.

This example separates access to development, CI/CD, and production environments. Developers can access development resources, while the DevOps team can access build tools and production. The interesting part is that devices [tagged](https://tailscale.com/kb/1068/tags) with `tag:ci` can also manage device tags, enabling automated deployment processes to tag resources appropriately as they progress through environments.

To implement this example, you need to define the developer and DevOps groups and tag the appropriate resources in each environment. This example provides a balance between security separation and automation capabilities. The CI/CD system can manage tags, allowing it to handle the entire deployment pipeline without direct human intervention. This approach does require careful security around the CI/CD system itself, as it has elevated privileges in the tailnet.

## [Monitor application access](#monitor-application-access)

Availability

Related concepts

[Premium and Enterprise](https://tailscale.com/pricing)

[grants](https://tailscale.com/kb/1324/grants), [groups](https://tailscale.com/kb/1396/targets#groups), [tags](https://tailscale.com/kb/1068/tags)

This example enables monitoring server access to services on specific ports across the tailnet. DevOps or SRE teams often need monitoring tools to query logs and metrics from services in the tailnet. This approach lets monitoring servers to access specific application ports without granting full tailnet access, balancing observability needs with security.

```json
{
  "groups": {
    "group:devops": ["carl@example.com"]
  },
  "grants": [
    {
      "src": ["tag:monitoring"],
      "dst": ["tag:logging"],
      "ip": ["80", "443", "9100"]
    },
    {
      "src": ["group:devops"],
      "dst": ["tag:monitoring", "tag:logging"],
      "ip": ["*"]
    }
  ],
  "tagOwners": {
    "tag:monitoring": ["group:devops"],
    "tag:logging": ["group:devops"]
  }
}
```

You can use the [visual policy editor](https://tailscale.com/kb/1550/visual-editor) to manage your tailnet policy file. Refer to the [visual editor reference](https://tailscale.com/kb/1587/visual-editor-reference) for guidance on using the visual editor.

This example lets monitoring servers access specific ports (HTTP, HTTPS, and Prometheus node exporter) on logging devices. The DevOps team has full access to both monitoring and logging infrastructure and can manage which devices have [tags](https://tailscale.com/kb/1068/tags) for these roles. This creates a clean separation between the monitoring infrastructure and the monitored services.

To implement this example, you need to define the DevOps group and tag the appropriate devices for monitoring and logging roles. This example restricts monitoring access to only the necessary ports, reducing the attack surface while maintaining observability. You should tailor the port restrictions to your specific monitoring tools and protocols.

This approach might require updates as monitoring requirements change or new monitoring ports are introduced.

## [Network microsegmentation](#network-microsegmentation)

Availability

Related concepts

[Premium and Enterprise](https://tailscale.com/pricing)

[grants](https://tailscale.com/kb/1324/grants), [groups](https://tailscale.com/kb/1396/targets#groups), [tags](https://tailscale.com/kb/1068/tags), [autogroups](https://tailscale.com/kb/1396/targets#autogroups)

[Network microsegmentation](https://tailscale.com/learn/network-microsegmentation) involves dividing a tailnet into small, isolated segments to enhance security and limit the spread of potential attacks.

This example implements logical tailnet segmentation with support team access across segments. Network microsegmentation divides your tailnet into logical units for security purposes, limiting the blast radius of potential security incidents. Each segment exists in isolation, but support teams might need controlled access across segments.

```json
{
  "grants": [
    {
      "src": ["group:support"],
      "dst": ["tag:segment-abc", "tag:segment-xyz"],
      "ip": ["443"]
    },
    {
      "src": ["tag:support"],
      "dst": ["tag:segment-abc", "tag:segment-xyz"],
      "ip": ["443"]
    }
  ],
  "groups": {
    "group:support": ["alice@example.com", "bob@example.com"]
  },
  "tagOwners": {
    "tag:support": ["autogroup:admin"]
  }
}
```

You can use the [visual policy editor](https://tailscale.com/kb/1550/visual-editor) to manage your tailnet policy file. Refer to the [visual editor reference](https://tailscale.com/kb/1587/visual-editor-reference) for guidance on using the visual editor.

This example creates isolated tailnet segments with controlled cross-segment access. Support team members and devices tagged for support can access both segments, but only on port `443` (HTTPS). This lets the support team access web interfaces and APIs in each segment without granting broader access to all protocols.

To implement this example, you need to define the support team [group](https://tailscale.com/kb/1396/targets#groups), [tag](https://tailscale.com/kb/1068/tags) devices in each segment, and tag support tools. [Admin](https://tailscale.com/kb/1138/user-roles)s can assign the support tag to devices as needed. This example does not define communication within each segment; you would need additional grants to let devices within a segment to communicate with each other. This approach provides strong isolation with controlled exceptions for support access, reducing the risk of lateral movement during security incidents.

## [VPC access](#vpc-access)

Availability

Related concepts

[Premium and Enterprise](https://tailscale.com/pricing)

[grants](https://tailscale.com/kb/1324/grants), [groups](https://tailscale.com/kb/1396/targets#groups), [tags](https://tailscale.com/kb/1068/tags), [autogroups](https://tailscale.com/kb/1396/targets#autogroups), [autoApprovers](https://tailscale.com/kb/1337/policy-syntax#autoapprovers)

This example enables developer access to VPC resources with [subnet](https://tailscale.com/kb/1019/subnets) peering capabilities. When your organization uses VPCs in cloud providers, you might want to let developers access these resources while maintaining proper subnet isolation and routing. This approach is particularly useful for secure access to cloud resources without public exposure.

```json
{
  "groups": {
    "group:dev": ["alice@example.com", "bob@example.com"]
  },
  "grants": [
    {
      "src": ["autogroup:admin"],
      "dst": ["tag:vpc-peering:*"],
      "ip": ["*"]
    },
    {
      "src": ["group:dev", "192.0.2.0/24", "198.51.100.0/24"],
      "dst": ["192.0.2.0/24:*", "198.51.100.0/24:*"],
      "ip": ["*"]
    }
  ],
  "tagOwners": {
    "tag:vpc-peering": ["autogroup:admin"]
  },
  "autoApprovers": {
    "routes": {
      "192.0.2.0/24": ["tag:vpc-peering", "autogroup:admin"],
      "198.51.100.0/24": ["tag:vpc-peering", "autogroup:admin"]
    }
  }
}
```

You can use the [visual policy editor](https://tailscale.com/kb/1550/visual-editor) to manage your tailnet policy file. Refer to the [visual editor reference](https://tailscale.com/kb/1587/visual-editor-reference) for guidance on using the visual editor.

This example enables bidirectional communication between two VPC subnets and grants developers access to both. [Admin](https://tailscale.com/kb/1138/user-roles)s can access and manage the VPC peering devices. The `autoApprovers` section automatically approves subnet routes for the VPCs, eliminating the need for manual approval in the Tailscale admin console.

To implement this example, you need to define the developer [group](https://tailscale.com/kb/1396/targets#groups), [tag](https://tailscale.com/kb/1068/tags) the VPC peering devices, and configure [subnet routing](https://tailscale.com/kb/1019/subnets). For this to work properly with subnet routing, you might need to disable subnet route masquerading to allow direct communication between subnets. This example lets both human users and devices within the subnets communicate with each other, enabling complex hybrid cloud architectures. This example requires careful management of subnet addressing to avoid conflicts and proper configuration of cloud tailnet settings.

You can also use [auto approvers](https://tailscale.com/kb/1337/policy-syntax#autoapprovers) to automatically approve routes.

## [Use Tailscale Peer Relays](#use-tailscale-peer-relays)

The following example lets all devices with the tag `tag:us-east-vpc` use [Tailscale Peer Relays](https://tailscale.com/kb/1591/peer-relays) tagged with `tag:us-east-relays` as underlay network relays when communicating with other devices on the tailnet. That means that other devices in the tailnet can use a device tagged with `tag:us-east-relays` as an underlay network relay when communicating with devices tagged with `tag:us-east-vpc`. It uses the `tailscale.com/cap/relay` [application capability](https://tailscale.com/kb/1537/grants-app-capabilities) to enable peer relay functionality.

```json
{
  "grants": [
    {
      "src": ["tag:us-east-vpc"],
      "dst": ["tag:us-east-relays"],
      "app": {
        "tailscale.com/cap/relay": []
      }
    }
  ]
}
```

For this to work, you must also [configure the peer relay devices](https://tailscale.com/kb/1591/peer-relays#step-1) using the `tailscale set` command and create a basic grant policy that permits overlay network access to devices with the `tag:us-east-vpc` tag. For example, this grant policy lets all members of the tailnet access devices with the `tag:us-east-vpc` tag on TCP ports 80 and 443.

```json
{
  "grants": [
    {
      "src": ["autogroup:member"],
      "dst": ["tag:us-east-vpc"],
      "ip": ["tcp:80","tcp:443"]
    }
  ]
}
```

## [Conclusion](#conclusion)

Remember that grants operate on a default-deny basis, so you must explicitly allow any connections you want to permit (unless you keep the default allow all policy). The flexibility of the grant system lets you implement granular access controls that follow security best practices while still enabling the connectivity your organization needs.
```



### File: 1469-unencrypted-macbooks-postgres.md

```markdown
# Protect production PostgreSQL databases from unencrypted MacBooks

Production database access typically requires encrypted devices, but development teams often include members whose MacBooks don't yet meet encryption requirements. Security policies force a binary choice: grant full access or deny it completely. Teams end up choosing between blocking critical work or creating security exceptions that undermine compliance.

Tailscale's [conditional routing](https://tailscale.com/kb/1378/via) solves this dilemma by routing database traffic [based on device encryption status](https://tailscale.com/kb/1288/device-posture). Unencrypted MacBooks don't get denied access. Their [PostgreSQL](https://www.postgresql.org/) connections go through security gateways ([subnet routers](https://tailscale.com/kb/1019/subnets)) that can apply enhanced logging and controls. Encrypted devices connect directly for optimal performance, while unencrypted devices maintain connectivity through monitored paths.

When you finish this guide, you'll have an automatic PostgreSQL routing system that maintains connectivity for all developers while applying security controls proportional to device compliance status.

The examples in this guide use a security gateway pattern for engineering teams using MacBooks to access production PostgreSQL databases. You can use this pattern to create other security gateway patterns for other teams or use cases.

## [Prerequisites](#prerequisites)

Before you begin, make sure you have:

-   A Tailscale account. [Create a free Personal account](https://login.tailscale.com/start) if you don't have one already.
-   [Admin](https://tailscale.com/kb/1138/user-roles) privileges to modify the tailnet policy file and manage device tags.
-   An understanding of [tailnet policy file syntax](https://tailscale.com/kb/1337/policy-syntax), particularly the `grants`, `postures`, and `tagOwners` sections.
-   At least one Linux server that can function as a [subnet router](https://tailscale.com/kb/1019/subnets) for your database monitoring gateway infrastructure.
-   Production PostgreSQL databases.
-   The Tailscale client is installed and running on your server. Follow the [Install Tailscale on Linux](https://tailscale.com/kb/1031/install-linux) instructions to install the Tailscale client.
-   Test devices with different encryption characteristics (each with a Tailscale client installed and running):
    -   At least one MacBook with [FileVault](https://support.apple.com/guide/deployment/intro-to-filevault-dep82064ec40/web) encryption enabled and macOS 13.4 or later.
    -   At least one MacBook with FileVault encryption disabled for testing routing behavior.
-   (Optional) PostgreSQL client tools are installed on your test devices for connection verification.

## [Step 1: Define device encryption requirements](#step-1-define-device-encryption-requirements)

The first step is to define the device encryption requirements using [device posture policies](https://tailscale.com/kb/1288/device-posture). These policies establish which MacBooks qualify for direct database access versus gateway routing by evaluating [FileVault](https://support.apple.com/guide/deployment/intro-to-filevault-dep82064ec40/web) encryption status (and other security attributes that Tailscale can detect on connected devices).

To get started, open your [tailnet policy file](https://tailscale.com/kb/1395/tailnet-policy-file) from the admin console. Then, locate the `postures` section in your tailnet policy file (or create it if it doesn't exist) and add the following posture definition:

```json
"postures": {
    "posture:encryptedMacBook": [
        "node:os == 'macos'",
        "node:osVersion >= '13.4.0'",
        "node:tsReleaseTrack == 'stable'",
        "node:diskEncrypted == true"
    ]
}
```

You can use the [visual policy editor](https://tailscale.com/kb/1550/visual-editor) to manage your tailnet policy file. Refer to the [visual editor reference](https://tailscale.com/kb/1587/visual-editor-reference) for guidance on using the visual editor.

This `encyptedMacBook` posture policy validates that devices run macOS version 13.4.0 or later, use stable [Tailscale releases](https://tailscale.com/kb/1083/releases), and have FileVault disk encryption enabled. All conditions must evaluate to true for a MacBook to be compliant with this posture and qualify for direct database access. MacBooks that fail any condition in the posture definition will not match grants requiring that posture, causing them to fall through to other applicable grants that route through monitoring infrastructure.

Save the policy file to apply the posture definition to your tailnet.

After you define the encryption requirements, you can create a tag for the database monitoring gateway.

## [Step 2: Create an identity for the security gateway and databases](#step-2-create-an-identity-for-the-security-gateway-and-databases)

In this step, you'll set up identifiers for the working parts of the system, including the security gateway, the developers using MacBooks, and the databases. You'll use [tags](https://tailscale.com/kb/1068/tags) for the database monitoring gateway and the databases because they're service-based. And you'll use a `group` for the developers.

First, create the tag-based identities for the security gateway and the databases. You do this by defining `tagOwners` in the tailnet policy file. Tag owners can apply tags to devices and manage the lifecycle of tagged infrastructure.

Locate the `tagOwners` section in your tailnet policy file (or create it if it doesn't exist) and define the tag for your database monitoring gateway:

```json
"tagOwners": {
    "tag:db-gateway": ["security-admin@yourcompany.com"]
}
```

You can use the [visual policy editor](https://tailscale.com/kb/1550/visual-editor) to manage your tailnet policy file. Refer to the [visual editor reference](https://tailscale.com/kb/1587/visual-editor-reference) for guidance on using the visual editor.

Then, define the tag for the databases:

```json
"tagOwners": {
    "tag:prod-database": ["security-admin@yourcompany.com"]
}
```

You can use the [visual policy editor](https://tailscale.com/kb/1550/visual-editor) to manage your tailnet policy file. Refer to the [visual editor reference](https://tailscale.com/kb/1587/visual-editor-reference) for guidance on using the visual editor.

In this example, only the user with the email address `security-admin@yourcompany.com` can manage the `tag:db-gateway` and `tag:prod-database` tags. However, you can add multiple users, groups, or even other tags as tag owners depending on your needs.

Next, use the [Tailscale CLI](https://tailscale.com/kb/1080/cli) to assign the `tag:db-gateway` tag to the monitoring gateway server by running the following command from the monitoring gateway server:

```shell
sudo tailscale login --advertise-tags=tag:db-gateway
```

This command assigns the `tag:db-gateway` tag to the monitoring gateway server.

You've configured the tag. Now you'll create a group for your team so you can manage permissions for your developers from a single place.

## [Step 3: Create an identity for your development team](#step-3-create-an-identity-for-your-development-team)

In this step, you'll create a group for your development team that you can use to identify the developers in your tailnet without referencing each of their email addresses.

In the tailnet policy file, create a group named `group:developers` and add the email addresses of the developers to the group. This example uses two email addresses, but you can add as many as you need.

```json
"groups": {
    "group:developers": ["user1@yourcompany.com", "user2@yourcompany.com"]
}
```

You can use the [visual policy editor](https://tailscale.com/kb/1550/visual-editor) to manage your tailnet policy file. Refer to the [visual editor reference](https://tailscale.com/kb/1587/visual-editor-reference) for guidance on using the visual editor.

Save the policy file to apply the group definition to your tailnet.

After you create the group, you can configure conditional database grants.

## [Step 4: Set up conditional access policies](#step-4-set-up-conditional-access-policies)

In this step, you will configure conditional grants that route database connections based on device encryption status.

[Grants](https://tailscale.com/kb/1324/grants) define access control policies that determine both what database resources developers can access and how their PostgreSQL traffic reaches those resources. By combining posture requirements with the `via` field, you can create grants that route database connections based on device encryption status.

First, locate the `grants` section in your tailnet policy file (or create it if it doesn't exist) and add the grant for encrypted MacBooks:

```json
"grants": [
    {
        "src": ["group:developers"],
        "dst": ["tag:prod-database"],
        "srcPosture": ["posture:encryptedMacBook"]
    }
]
```

You can use the [visual policy editor](https://tailscale.com/kb/1550/visual-editor) to manage your tailnet policy file. Refer to the [visual editor reference](https://tailscale.com/kb/1587/visual-editor-reference) for guidance on using the visual editor.

This grant provides direct PostgreSQL database access for development team members (`group:developers`) whose MacBooks meet the encrypted device posture requirements (`posture:encryptedMacBook`). The `srcPosture` field ensures only compliant devices match this grant, providing them with optimized routing that reduces latency and improves performance.

Then, add the fallback grant after the encrypted device grant:

```json
"grants": [
    {
        "src": ["group:developers"],
        "dst": ["tag:prod-database"],
        "srcPosture": ["posture:encryptedMacBook"]
    },
    {
        "src": ["group:developers"],
        "dst": ["tag:prod-database"],
        "via": ["tag:db-gateway"]
    }
]
```

You can use the [visual policy editor](https://tailscale.com/kb/1550/visual-editor) to manage your tailnet policy file. Refer to the [visual editor reference](https://tailscale.com/kb/1587/visual-editor-reference) for guidance on using the visual editor.

The second grant functions as a monitoring fallback that captures any development team PostgreSQL traffic not matched by the first grant. Because it lacks a `srcPosture` requirement, it matches devices regardless of encryption status. The [`via`](https://tailscale.com/kb/1378/via) field routes this traffic through the device tagged as the database gateway, where you can apply additional logging and controls.

Save and apply the policy changes to your tailnet.

After you configure the grants, you can deploy the database monitoring gateway.

## [Step 5: Start the security gateway](#step-5-start-the-security-gateway)

The database monitoring gateway is a [subnet router](https://tailscale.com/kb/1019/subnets) that intercepts and routes PostgreSQL traffic from unencrypted MacBooks. You must configure this server as a subnet router to handle traffic forwarding and then assign the `tag:db-gateway` to enable it for routing duty. The monitoring gateway server receives all PostgreSQL traffic from unencrypted MacBooks attempting to access production databases. Consider the network positioning, performance requirements, and logging capabilities of this server when selecting hardware and deployment locations.

Database monitoring gateways require subnet router functionality because they must forward PostgreSQL traffic between your tailnet and production database networks. Regular tailnet devices can only send and receive their own traffic. Subnet routers advertise additional network routes, enabling them to forward traffic on behalf of other devices.

First, choose a Linux server to function as your database monitoring gateway based on your network topology and expected PostgreSQL traffic volume. This server should have sufficient network capacity and storage for comprehensive database connection logging. Then, on the selected monitoring gateway server, enable [subnet router](https://tailscale.com/kb/1019/subnets) functionality and assign the database gateway [tag](https://tailscale.com/kb/1068/tags) by running:

```shell
sudo tailscale up --advertise-routes=<subnet-range> --advertise-tags=tag:db-gateway
```

Replace `<subnet-range>` with the actual subnet range (such as `10.0.100.0/24`) that contains your production PostgreSQL databases. This advertises the database network to your tailnet and enables the server to forward traffic to those resources.

Then, approve the subnet routes in the admin console by navigating to the [Machines](https://login.tailscale.com/admin/machines) page, finding the monitoring gateway server, and enabling the advertised routes.

After you deploy the database monitoring gateway, you can verify that the database routing behavior is working as expected by testing the connection path from an encrypted and an unencrypted MacBook.

## [Step 6: Verify database routing behavior](#step-6-verify-database-routing-behavior)

With the database monitoring gateway infrastructure deployed, when a developer's MacBook attempts to access production PostgreSQL databases, Tailscale checks device attributes against `posture:encryptedMacBook`. If the device uses encryption, the first grant matches, granting direct database access. If the device is unencrypted, the first grant fails, and the second grant matches, routing the traffic through the monitoring gateway. Let's test this behavior.

First, identify an encrypted MacBook that meets all requirements in your `posture:encryptedMacBook` definition. Verify its compliance status by running the [`tailscale status` command](https://tailscale.com/kb/1080/cli) directly from the MacBook:

```shell
tailscale status --json | grep -E "(OS|Version|DiskEncrypted)"
```

Confirm that the output shows `"OS": "macos"`, a version number of 13.4.0 or higher, and `"DiskEncrypted": true`.

Then, check the connection path to confirm it bypasses the monitoring gateway:

```shell
tailscale ping <database-name>.<tailnet-name>.ts.net
```

Replace `<database-name>` and `<tailnet-name>` with the actual values of your production database and tailnet name.

Look for direct connectivity to the production database without intermediate hops through the monitoring gateway server. The `tailscale ping` result should show a direct path to your database infrastructure.

Next, from an unencrypted MacBook (one with FileVault disabled), attempt to access the same production database, then verify that PostgreSQL traffic routes through your monitoring gateway infrastructure by checking the connection path:

```shell
tailscale ping <database-name>.<tailnet-name>.ts.net
```

The `tailscale ping` result should show connectivity through your monitoring gateway server rather than direct connectivity. This confirms that unencrypted MacBooks route through the monitoring infrastructure as intended.

## [Conclusion](#conclusion)

You've implemented device encryption-based database routing that automatically enforces security boundaries while maintaining PostgreSQL access for development teams. The system evaluates MacBook encryption status and routes traffic through appropriate network paths without manual intervention.

The final version of your tailnet policy file should look like this:

```json
"postures": {
    "posture:encryptedMacBook": [
        "node:os == 'macos'",
        "node:osVersion >= '13.4.0'",
        "node:tsReleaseTrack == 'stable'",
        "node:diskEncrypted == true"
    ]
}
"tagOwners": {
    "tag:db-gateway": ["security-admin@yourcompany.com"],
    "tag:prod-database": ["security-admin@yourcompany.com"]
}
"groups": {
    "group:developers": ["user1@yourcompany.com", "user2@yourcompany.com"]
}
"grants": [
    {
        "src": ["group:developers"],
        "dst": ["tag:prod-database"],
        "srcPosture": ["posture:encryptedMacBook"]
    },
    {
        "src": ["group:developers"],
        "dst": ["tag:prod-database"],
        "via": ["tag:db-gateway"]
    }
]
```

You can use the [visual policy editor](https://tailscale.com/kb/1550/visual-editor) to manage your tailnet policy file. Refer to the [visual editor reference](https://tailscale.com/kb/1587/visual-editor-reference) for guidance on using the visual editor.

## [Further exploration](#further-exploration)

You can expand this solution to meet your specific security requirements. For example:

-   Configure [logging](https://tailscale.com/kb/1011/log-mesh-traffic) on security gateways and integrate with your SIEM system for anomaly detection.
-   Add [just-in-time access](https://tailscale.com/kb/1383/device-posture-for-jit) workflows for emergency access from non-compliant devices with audit trails.
-   Expand posture checks to include certificates, antivirus status, or [MDM](https://tailscale.com/kb/1448/mdm-integration-partners) integration.
-   Deploy regional gateway infrastructure to reduce latency.
-   Create tiered access levels based on compliance levels rather than binary decisions.
```



### File: 1482-client-metrics.md

```markdown
# Tailscale client metrics

You can expose and collect Tailscale client metrics for use with monitoring systems such as [Prometheus](https://prometheus.io/) or [Grafana](https://tailscale.com/kb/1523/grafana) for your Tailscale network (known as a tailnet). These metrics provide insights into client behavior, health, and performance. For example, you can view information about client connectivity to [subnet routers](https://tailscale.com/kb/1019/subnets) configured in your tailnet.

Tailscale client metrics are supported in Tailscale v1.78.0 and later.

## [Available metrics](#available-metrics)

The following metrics can be collected from the Tailscale clients in your tailnet:

### [Subnet router](#subnet-router)

Use the metrics in this section to collect Tailscale client information related to subnet routes.

`tailscaled_advertised_routes`

-   The metric type is `gauge`.
-   Displays the number of routes advertised by the client.
-   Includes routes that are not approved.
-   Does not include exit nodes.

`tailscaled_approved_routes`

-   The metric type is `gauge`.
-   Displays number of advertised routes that have been [approved](https://tailscale.com/kb/1019/subnets#enable-subnet-routes-from-the-admin-console) by an administrator.

### [Health](#health)

Use the metrics in this section to collect Tailscale client information related to health.

`tailscaled_health_messages`

-   The metric type is `gauge`.
-   Displays the number of health messages currently reported by the Tailscale client.
-   This metric has a `type` label, reporting health message type. For example, `warning`.

More details about the health messages can be found by running [`tailscale status`](https://tailscale.com/kb/1080/cli#status).

### [Throughput](#throughput)

Use the metrics in this section to collect Tailscale client information related to throughput.

`tailscaled_inbound_packets_total`

-   The metric type is `counter`.
-   Displays the number of packets received by the node from other peers.

`tailscaled_inbound_bytes_total`

-   The metric type is `counter`.
-   Displays the number of bytes received by the node from other peers.

`tailscaled_outbound_packets_total`

-   The metric type is `counter`.
-   Displays the number of packets sent by the device to other peers.

`tailscaled_outbound_bytes_total`

-   The metric type is `counter`.
-   Displays the number of bytes sent by the node to other peers.

All throughput metrics contain a `path` label, indicating [the type of connection](https://tailscale.com/kb/1257/connection-types) that a packet took. The `path` label can contain one of the following values:

-   `direct_ipv4`: Packets sent or received directly over IPv4.
-   `direct_ipv6`: Packets sent or received directly over IPv6.
-   `derp`: Packets sent or received through a [DERP relay](https://tailscale.com/kb/1232/derp-servers).

### [Dropped packets](#dropped-packets)

Use the metrics in this section to collect Tailscale client information related to dropped packets.

`tailscaled_inbound_dropped_packets_total`

-   The metric type is `counter`.
-   Displays the number of packets dropped after being received from other peers.

`tailscaled_outbound_dropped_packets_total`

-   The metric type is `counter`.
-   Displays the number of packets dropped while being sent to other peers.

Both the `tailscaled_inbound_dropped_packets_total` and `tailscaled_outbound_dropped_packets_total` metrics contain a `reason` label with one of the following values:

-   `acl`: The reported packets dropped by [Tailscale access control](https://tailscale.com/kb/1393/access-control).
-   `multicast`: The reported packets dropped because they were multicast.
-   `link_local_unicast`: The reported packets dropped because they were link-local unicast.
-   `too_short`: The reported packets dropped because they were too short.
-   `fragment`: The reported packets dropped because they were IP fragments.
-   `unknown_protocol`: The reported packets dropped because they had an unknown protocol.
-   `error`: The reported packets dropped because of an error.

## [Collect metrics](#collect-metrics)

Tailscale metrics can be collected either from the Tailscale [web interface](https://tailscale.com/kb/1325/device-web-interface) or the [Tailscale CLI](https://tailscale.com/kb/1080/cli#metrics).

### [Web interface](#web-interface)

The Tailscale [web interface](https://tailscale.com/kb/1325/device-web-interface) exposes client metrics on the conventional `/metrics` path.

#### [Access metrics locally](#access-metrics-locally)

Each client exposes metrics locally through the [`http://100.100.100.100/metrics`](https://tailscale.com/kb/1381/what-is-quad100) URL. You can use this URL when the monitoring server (or agent) is running on the same host as the Tailscale client.

#### [Collect metrics over Tailscale](#collect-metrics-over-tailscale)

To collect metrics over your tailnet, you must do the following:

-   Enable the Tailscale [web interface](https://tailscale.com/kb/1325/device-web-interface) on each device that you want to expose metrics by running using the [`tailscale set --webclient`](https://tailscale.com/kb/1080/cli#set) command.
-   Grant your monitoring server access to port `5252` of the client in your [tailnet policy file](https://tailscale.com/kb/1395/tailnet-policy-file).

We recommend using this method when your monitoring server is running on another machine on your Tailscale network.

#### [Expose metrics to other networks](#expose-metrics-to-other-networks)

You can make the web interface available through another network interface on your machine by running the [`tailscale web`](https://tailscale.com/kb/1080/cli#web) command. For example, if you have a local interface with an IP address 203.0.113.5, running `tailscale web --readonly --listen 203.0.113.5:8080` will make metrics accessible at `http://203.0.113.5:8080/metrics`.

The `tailscale web --readonly` command starts a separate server that listens only on the provided IP address and port number, and will not expose metrics over a Tailscale IP.

### [Command line](#command-line)

To use metrics in a script or to inspect them in the [Tailscale CLI](https://tailscale.com/kb/1080/cli) command:

```shell
tailscale metrics print
```

#### [Write metrics to a file](#write-metrics-to-a-file)

You can use the `tailscale metrics write` command to write metric values to a text file provided as its only argument. This can be used alongside [Prometheus node exporter](https://github.com/prometheus/node_exporter) to allow Tailscale client metrics to be consumed and exported by the [textfile collector](https://github.com/prometheus/node_exporter#textfile-collector).

For example:

```shell
tailscale metrics write /var/lib/prometheus/node-exporter/tailscaled.prom
```
```



### File: 1526-openvpn-migration-guide.md

```markdown
# Migrate from OpenVPN to Tailscale

## [Introduction](#introduction)

OpenVPN is a popular choice for a virtual private network (VPN), but needs more setup, management, and maintenance compared to Tailscale. Tailscale is a mesh VPN service designed for protection of modern and legacy networks. Tailscale is built on the WireGuard® protocol, providing performance, privacy, and security by default.

To start your migration, you'll create a small network by installing and configuring Tailscale on two devices. Unlike a traditional VPN, you won't need a central gateway server. Next, you'll explore access controls to customize access within your network, and you'll explore how to configure Domain Name System (DNS) settings for handling DNS queries. When you complete the steps in this guide, you'll have a mesh network with end-to-end encrypted connections. You can build upon this network to completely migrate from OpenVPN to Tailscale.

This guide applies to running Tailscale on your entire network. Benefits of running a Tailscale network instead of only replacing an OpenVPN concentrator include:

-   End-to-end encryption using WireGuard.
-   Fewer re-authentications required.
-   More reliable connectivity.
-   No hardware required.
-   Automatic encryption key management.
-   Better network performance.
-   Easier maintenance of access controls.
-   More comprehensive logging.
-   Automatically registered DNS names for devices in your network (through [MagicDNS](https://tailscale.com/kb/1081/magicdns)).

## [How Tailscale differs from OpenVPN](#how-tailscale-differs-from-openvpn)

OpenVPN uses a central server maintained by the user to create and manage encryption keys and client setup, and also to tunnel all network traffic between devices.

Tailscale uses WireGuard for creation of encryption keys, and the control plane handles key management. Tailscale provides client downloads and scripts to streamline installation. Tailscale facilitates direct connections between devices where possible. In the cases where it is not possible, a global set of relay servers to facilitate the network traffic, but these relays never decrypt the WireGuard tunnels between your devices.

## [Prerequisites](#prerequisites)

To follow this guide, you need:

-   An email account. Tailscale natively supports the following identity providers:

    -   Apple
    -   Google, including Gmail and Google Workspace (G Suite)
    -   GitHub
    -   Microsoft, including Microsoft Accounts, Microsoft 365, Active Directory, and Microsoft Entra ID

    If you are using a different identity provider, you need to take additional steps. Refer to [Setting up Okta](https://tailscale.com/kb/1066/sso-okta), [Setting up OneLogin](https://tailscale.com/kb/1070/sso-onelogin), or [Custom OIDC providers](https://tailscale.com/kb/1240/sso-custom-oidc), depending on which identity provider you use.

-   Two devices on which to install the Tailscale client. For example, you can use laptops, desktops, servers, and cell phones as the devices. Tailscale runs on most operating systems, including Linux, Windows, macOS, iOS, and Android.


## [Create your first tailnet](#create-your-first-tailnet)

Begin your migration to a Tailscale network (known as a tailnet) by installing the Tailscale client on a single device and logging in with the identity provider that you already use. This process automatically creates the tailnet for you.

1.  Go to the [Sign up](https://login.tailscale.com/start) page of the admin console and log in using a [single sign-on (SSO) identity provider](https://tailscale.com/kb/1013/sso-providers) account.

2.  On the **Welcome to Tailscale** page, select **Business use** or **Personal use**. If you plan to use this network with a team at work, select **Business use**. If you plan to use this network at home or with friends and family, select **Personal use**.

    ![Choosing use case for tailnet creation.](/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fwelcome-page.f3b91c91.png&w=1080&q=75)

    After you make your selection, select **Next**.

3.  On the **Let's add your first device** page, select the operating system (OS) that corresponds to the device you are using.

    ![Choosing an operating system for client installation.](/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fadd-first-device.faa6c43a.png&w=1080&q=75)

    Depending on your OS, you have an opportunity to download the Tailscale client or copy a command script. Install the client by using the download or script as needed for your device.

4.  When prompted to authenticate the client, log in using the same credentials that you used to create the tailnet in Step 1. Once authenticated, your device appears in the browser window.

    ![First device displayed in the browser window.](/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fadd-second-device.80198dfe.png&w=1080&q=75)


With your tailnet created and one device added, you'll connect another device so you can make a network connection between the two devices.

## [Add a second device to your tailnet](#add-a-second-device-to-your-tailnet)

To observe connectivity within your tailnet, add another device.

1.  On another device, go to [https://tailscale.com/download](https://tailscale.com/download). Install the Tailscale client by using the download or script as needed for your device, then log in at the Tailscale [Login](https://login.tailscale.com/login) page, using the same credentials that you used for your first device.

2.  Open the [Machines](https://login.tailscale.com/admin/machines) page of the Tailscale admin console. You manage your tailnet devices in the **Machines** page. Your two devices are in the list, with information such as the device name, IP address, who manages it, and so on.

    ![View of the tailnet machines.](/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fmachines-page.d18a35d9.png&w=1080&q=75)

3.  Open the [Users](https://login.tailscale.com/admin/users) page of the admin console. You manage your tailnet users on this page. Your email account is in the list.

    ![View of the tailnet users.](/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fusers-page.041de599.png&w=1080&q=75)

    Because you created the tailnet, your [user role](https://tailscale.com/kb/1138/user-roles) is Owner, which has complete admin access for your tailnet. When other users join your tailnet, you or others that are admins can set their role. A user's role helps determine their access to resources in your tailnet. For example, the [Admin](https://tailscale.com/kb/1138/user-roles#admin) role has more access to resources than the [Member](https://tailscale.com/kb/1138/user-roles#member) role, as shown in the [Permission matrix](https://tailscale.com/kb/1138/user-roles#permission-matrix).


Unlike OpenVPN, which requires a dedicated server maintained by you to manage your network, the Tailscale admin console runs on Tailscale's platform.

With two devices in your tailnet, you can now verify connectivity between the devices.

## [Verify connectivity between the two devices](#verify-connectivity-between-the-two-devices)

Unlike many VPNs, which use a central gateway server between connections, Tailscale devices establish direct peer-to-peer connections.

1.  To show that your two devices can communicate with each other, run a [Tailscale CLI](https://tailscale.com/kb/1080/cli) command. The Tailscale CLI runs on Linux, Windows, and macOS. (If you are running macOS, you need to [set up the Tailscale CLI](https://tailscale.com/kb/1080/cli?tab=macos#using-the-tailscale-cli) on your device first.)

    At a command prompt on one of your tailnet's devices, ping the other device by running:

    ```shell
    tailscale ping <other-device-name-or-ip>
    ```

    You can determine the value to use for `<other-device-name-or-ip>` by going to the [Machines](https://login.tailscale.com/admin/machines) page and copying the name of the other device. Alternatively, you can copy the device IP address.

    The `tailscale ping` command typically responds with a `pong` message that indicates how long it took for your `ping` command to receive a response. This shows you that your devices are able to connect and communicate with each other.

2.  For another command to get familiar with Tailscale, run:

    ```shell
    tailscale netcheck --verbose
    ```

    The `tailscale netcheck` command displays a report on your current physical network conditions. Included at the end of the report is the list of Designated Encrypted Relay for Packets (DERP) servers that Tailscale operates, and how long it takes your device to reach each server. DERP servers make the initial connection between devices to establish direct connections. In the case where direct connections are not possible, DERP servers handle [NAT traversal](https://tailscale.com/blog/how-nat-traversal-works) for the devices.

    If you are running Android or iOS, you cannot run the Tailscale CLI. You can still ping other devices using the Tailscale client.

    1.  On Android, open the Tailscale app. The app shows the list of devices in your tailnet. Long press one of the other devices and then select the Count Down Timer icon. The app shows the result of ten pings from your device to the other device, unless the other device is not connected.
    2.  On iOS, open the Tailscale app. The app shows the list of devices in your tailnet. Long press one of the other devices and then select **Ping**. The app shows the result of ten pings from your device to the other device, unless the other device is not connected.

With your tailnet in place, you can now move on to restricting access to a device.

## [Configure access control to a device](#configure-access-control-to-a-device)

Within your tailnet, you can restrict access based on users, groups, autogroups, tags, Tailscale IP addresses, and subnet ranges.

To read or update the access controls configured for your tailnet, open the [Access controls](https://login.tailscale.com/admin/acls) page of the admin console. This page shows the tailnet policy for the devices and users allowed to connect in your network. The policy stores as a [tailnet policy file](https://tailscale.com/kb/1395/tailnet-policy-file).

Tailscale initialized your tailnet policy file with a [default allow all access policy](https://tailscale.com/kb/1192/acl-samples#allow-all-default-acl). This lets you connect to and use Tailscale without restricting any traffic in your network and grants all devices in the tailnet access to all other devices in the tailnet.

To use a different policy that is less permissive than the default policy, edit your tailnet policy file. As an example, the following policy grants all users access to their own devices.

1.  Open the [Access controls](https://login.tailscale.com/admin/acls) page of the admin console.

2.  Within the **View file** tab, replace the contents with the following JSON:

    ```json
    {
      // All users can access their own devices.
      "grants": [
        {
          "src": ["autogroup:member"],
          "dst": ["autogroup:self"],
          "ip":  ["*"]
        }
      ]
    }
    ```

    You can use the [visual policy editor](https://tailscale.com/kb/1550/visual-editor) to manage your tailnet policy file. Refer to the [visual editor reference](https://tailscale.com/kb/1587/visual-editor-reference) for guidance on using the visual editor.

3.  Select **Save**.


It is suitable for many use cases where you want to allow users to access their own devices, but not other devices in the tailnet.

The syntax for this policy contains the following:

-   `grants`: The policy is based on grants, as opposed to the legacy (but still supported) access control lists (`acls`).
-   `src`: An array of selectors that define the source of the grant. In this case, the array contains the `autogroup:member` [autogroup](https://tailscale.com/kb/1337/acl-syntax#autogroups), which grants access for any user who is a direct member of your tailnet.
-   `dst`: An array of selectors that define the destination of the grant. In this case, the array contains the `autogroup:self` autogroup, which grants access for any user that is authenticated as the same user as the source.
-   `ip`: An array of strings that define the network-layer capabilities to grant. In this case, the array contains `*`, which grants access to all ports on the destination.

For more information about the syntax shown in this policy, refer to [Grants](https://tailscale.com/kb/1324/grants).

You have now modified the tailnet policy file from the default. You're ready to customize it again to provide more granular access control.

## [Restrict access based on user role and purpose](#restrict-access-based-on-user-role-and-purpose)

To let users access devices appropriate for their role and purpose, update your tailnet policy file to use additional controls. For example, configure your policy to support the following scenario:

-   All employees can access devices considered for internal use, like a web server that lists company holidays.
-   Members of the engineering team can access the devices intended for engineering use only.
-   Members of the finance team can access the devices intended for finance use only.
-   Members of the legal team can access the devices intended for legal use only.
-   Your tailnet's admins (such as the IT team) can manage which devices are considered as internal, engineering, finance, or legal.

To designate a purpose for a device, Tailscale provides [tags](https://tailscale.com/kb/1068/tags), which let you manage access control for the device.

You define groups and tags directly in your tailnet policy file.

1.  Open the [Access controls](https://login.tailscale.com/admin/acls) page of the admin console and make the **View file** tab the active tab.

2.  Add a `groups` array, and add an entry to define each team and its members.

    ```json
    {
      "groups": {
        // Alice and Frank are in group:engineering
        "group:engineering": ["alice@example.com", "frank@example.com"],
        // Bob and Dana are in group:finance
        "group:finance": ["bob@example.com", "dana@example.com"],
        // Carl is in group:legal
        "group:legal": ["carl@example.com"]
      },

      // All users can access their own devices.
      "grants": [
        {
          "src": ["autogroup:member"],
          "dst": ["autogroup:self"],
          "ip":  ["*"]
        },

      ]
    }
    ```

    The [`groups`](https://tailscale.com/kb/1337/acl-syntax#groups) section lets you create groups of users, which you can use in access rules, instead of listing users out explicitly. This policy creates groups `group:engineering`, `group:finance`, and `group:legal`, and adds an array of users to each group. For example, `group:engineering` contains `alice@example.com` and `frank@example.com` as members.

3.  Within the `grants` array, add grants for the `engineering` team:

    ```json
      // All users can access their own devices.
      "grants": [
        {
          "src": ["autogroup:member"],
          "dst": ["autogroup:self"],
          "ip":  ["*"]
        },

        // Users in group:engineering can access devices tagged with tag:engineering
        {
          "src": ["group:engineering"],
          "dst": ["tag:engineering"],
          "ip":  ["*"]
        },

       ]
    ```


The `src` is the previously created `group:engineering` group. The `dst` is the `tag:engineering` tag, which results in any member of the engineering team being able to access devices that contain the `tag:engineering` tag.

1.  Also add grants for the `finance` and `legal` teams:

    ```json
      // All users can access their own devices.
      "grants": [
        {
          "src": ["autogroup:member"],
          "dst": ["autogroup:self"],
          "ip":  ["*"]
        },

        // Users in group:engineering can access devices tagged with tag:engineering
        {
          "src": ["group:engineering"],
          "dst": ["tag:engineering"],
          "ip":  ["*"]
        },

        // Users in group:finance can access devices tagged with tag:finance
        {
            "src": ["group:finance"],
            "dst": ["tag:finance"],
            "ip":  ["*"]
        },

        // Users in group:legal can access devices tagged with tag:legal
        {
          "src": ["group:legal"],
          "dst": ["tag:legal"],
          "ip":  ["*"]
        },

     ]
    ```

2.  Add a grant entry that grants all tailnet members access to devices tagged as `tag:internal`.

    ```json
      // All users can access their own devices.
      "grants": [
        {
          "src": ["autogroup:member"],
          "dst": ["autogroup:self"],
          "ip":  ["*"]
        },

        // Users in group:engineering can access devices tagged with tag:engineering
        {
          "src": ["group:engineering"],
          "dst": ["tag:engineering"],
          "ip":  ["*"]
        },

        // Users in group:finance can access devices tagged with tag:finance
        {
            "src": ["group:finance"],
            "dst": ["tag:finance"],
            "ip":  ["*"]
        },

        // Users in group:legal can access devices tagged with tag:legal
        {
          "src": ["group:legal"],
          "dst": ["tag:legal"],
          "ip":  ["*"]
        },

        // All employees can access devices tagged with tag:internal
        {
          "src": ["autogroup:member"],
          "dst": ["tag:internal"],
          "ip":  ["*"]
        }

     ],
    ```

3.  Below the `grants` array, but before the closing bracket of your tailnet policy file, define a `tagOwners` section. Within the `tagOwners` section, add an entry to define each tag and the members of your tailnet that can apply the tag to a device. For brevity of this example, make the `autogroup:admin` [autogroup](https://tailscale.com/kb/1337/acl-syntax#autogroups) the tag owner.

    ```json
        // All employees can access devices tagged with tag:internal
        {
          "src": ["autogroup:member"],
          "dst": ["tag:internal"],
          "ip":  ["*"]
        }

     ],

      "tagOwners": {
        // Users who are Tailscale admins can apply the tag tag:engineering
        "tag:engineering": ["autogroup:admin"],
        // Users who are Tailscale admins can apply the tag tag:finance
        "tag:finance": ["autogroup:admin"],
        // Users who are Tailscale admins can apply the tag tag:legal
        "tag:legal": ["autogroup:admin"],
        // Users who are Tailscale admins can apply the tag tag:internal
        "tag:internal": ["autogroup:admin"]
      }

    }
    ```

    Now any [Admin](https://tailscale.com/kb/1138/user-roles#admin) in your tailnet can apply the tags to devices.

4.  The following shows the entire tailnet policy file:

    ```json
    {
      "groups": {
        // Alice and Frank are in group:engineering
        "group:engineering": ["alice@example.com", "frank@example.com"],
        // Bob and Dana are in group:finance
        "group:finance": ["bob@example.com", "dana@example.com"],
        // Carl is in group:legal
        "group:legal": ["carl@example.com"]
      },

      // All users can access their own devices.
      "grants": [
        {
          "src": ["autogroup:member"],
          "dst": ["autogroup:self"],
          "ip":  ["*"]
        },

        // Users in group:engineering can access devices tagged with tag:engineering
        {
          "src": ["group:engineering"],
          "dst": ["tag:engineering"],
          "ip":  ["*"]
        },

        // Users in group:finance can access devices tagged with tag:finance
        {
            "src": ["group:finance"],
            "dst": ["tag:finance"],
            "ip":  ["*"]
        },

        // Users in group:legal can access devices tagged with tag:legal
        {
          "src": ["group:legal"],
          "dst": ["tag:legal"],
          "ip":  ["*"]
        },

        // All employees can access devices tagged with tag:internal
        {
          "src": ["autogroup:member"],
          "dst": ["tag:internal"],
          "ip":  ["*"]
        }
     ],

      "tagOwners": {
        // Users who are Tailscale admins can apply the tag tag:engineering
        "tag:engineering": ["autogroup:admin"],
        // Users who are Tailscale admins can apply the tag tag:finance
        "tag:finance": ["autogroup:admin"],
        // Users who are Tailscale admins can apply the tag tag:legal
        "tag:legal": ["autogroup:admin"],
        // Users who are Tailscale admins can apply the tag tag:internal
        "tag:internal": ["autogroup:admin"]
      }
    }
    ```

    You can use the [visual policy editor](https://tailscale.com/kb/1550/visual-editor) to manage your tailnet policy file. Refer to the [visual editor reference](https://tailscale.com/kb/1587/visual-editor-reference) for guidance on using the visual editor.

5.  Select **Save**.


Now that you have defined tags for your tailnet, set up a device with the tag named `tag:engineering`.

1.  Add a new device to your tailnet, as done in the [Add a second device to your tailnet](#add-a-second-device-to-your-tailnet) section.

2.  Open the [Machines](https://login.tailscale.com/admin/machines) page of the admin console.

3.  Select the machine that you added to your tailnet.

4.  Select the ![ellipsis icon](/files/images/icons/fa-ellipsis-h.svg) menu.

5.  Select **Edit ACL tags**.

6.  Select **Add tags**.

7.  Select the tag `tag:engineering`.

    ![Add a tag to a device.](/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fedit-tags.0c0b72bc.png&w=1080&q=75)

8.  Select **Save**.


You have now set up identity-first networking based on purpose for your tailnet. For example, any member of the `group:engineering` group can access this device because the policy permits it. Anyone outside of the `group:engineering` cannot access the device.

In addition to tagging a device by using the admin console, you can tag devices using the Tailscale CLI and the Tailscale API.

For additional information about access control within Tailscale, refer to [Manage access](https://tailscale.com/kb/1350/manage).

Now that you have explored access control, move on to DNS configuration.

## [Configure DNS settings](#configure-dns-settings)

If your OpenVPN configuration requires clients to use specific DNS servers, configure your tailnet to do the same. By default, your tailnet has [MagicDNS](https://tailscale.com/kb/1081/magicdns) enabled, which means that your tailnet automatically registers DNS names for devices in your network. You only need to add other DNS servers if you want to use global nameservers or restricted nameservers (known as split DNS).

1.  Open the [DNS](https://login.tailscale.com/admin/dns) page in the Tailscale admin console.
2.  In the **Nameservers** section, select **Add nameserver** and then add any public DNS servers, as well as custom DNS servers, that you want to use.
3.  Also in the [DNS](https://login.tailscale.com/admin/dns) page in the Tailscale admin console, add any search domains. Search domains provide a convenient way for users to access local network resources without having to specify the full domain path every time they connect to a resource. You can specify a list of domain suffixes that are automatically appended to any domain name that is not a fully qualified domain name (FQDN).

Now when users in your tailnet browse the internet or perform other network communication, their DNS queries resolve to the hosts as configured by your DNS settings.

## [Conclusion](#conclusion)

You created a Tailscale network and installed the Tailscale client on two devices. You ensured that the two devices can connect to each other. You also used the Tailscale admin console to manage users, devices, and access control (among other tasks not yet shown). And if your OpenVPN configuration used specific DNS servers, you configured Tailscale to use the same DNS servers.

Continue on to discover more about Tailscale networking features and how to configure them in your tailnet.

## [Further exploration](#further-exploration)

Explore Tailscale features that let you customize network traffic routes, use SSH to securely connect to devices, and manage users and devices. Also discover features that let you enable HTTPS for your devices, as well as monitor your tailnet configuration and network traffic flow.

### [Access devices where you can't install the Tailscale client](#access-devices-where-you-cant-install-the-tailscale-client)

Tailscale works best when you install the Tailscale client on every device in your organization. This enforces end-to-end traffic encryption without additional configuration.

However, there are situations where you can't or don't want to install the Tailscale client on each device. For example, some devices, like printers, might not allow installing the Tailscale client. Additionally, installing the Tailscale client on every device might not make sense. This is true when connecting many devices, like an entire virtual private cloud (VPC), or gradually deploying Tailscale to a legacy network. In these cases, you can set up a [subnet router](https://tailscale.com/kb/1019/subnets) to access these devices from your tailnet. Subnet routers act as a gateway, relaying traffic from your tailnet to a physical subnet. For OS-specific instructions for setting up and using a subnet router, refer to [Set up a subnet router](https://tailscale.com/kb/1019/subnets#set-up-a-subnet-router).

When you set up a subnet router, use the same Classless Inter-domain Routing (CIDR) values that you used in OpenVPN.

When you add [access rules for the advertised subnet routes](https://tailscale.com/kb/1019/subnets?tab=linux#add-access-rules-for-the-advertised-subnet-routes), in Tailscale you grant access to the routes themselves (such as `192.0.2.0/24`). This is different from OpenVPN, which grants routing access to a device, not to the routes that the device provides.

When you set up a device to serve as a subnet router, you need to [enable the subnet routes in the admin console](https://tailscale.com/kb/1019/subnets#enable-subnet-routes-from-the-admin-console) unless you have set up [auto approvers](https://tailscale.com/kb/1337/acl-syntax#autoapprovers). Use auto approvers so that when a device authenticated by a user that has access for the specified routes (as configured in the [`autoApprovers`](https://tailscale.com/kb/1337/acl-syntax#autoapprovers) section of your tailnet policy file), the device automatically has subnet routes approval.

### [Route public internet traffic through a single device](#route-public-internet-traffic-through-a-single-device)

There might be times when you want Tailscale to route your public internet traffic. For example, you might want to route all your public internet traffic if:

-   You're in a coffee shop with untrusted Wi-Fi.
-   You're traveling overseas and need access to an online service (such as banking) only available in your home country.

You can route all your public internet traffic by setting a device on your network as an [exit node](https://tailscale.com/kb/1103/exit-nodes). When you route all traffic through an exit node, you're effectively using default routes (`0.0.0.0/0, ::/0`), similar to how you would if you were using a typical virtual private network (VPN). For OS-specific instructions for setting up and using an exit node, refer to [Use exit nodes](https://tailscale.com/kb/1408/quick-guide-exit-nodes).

When you set up a device to serve as an exit node, you need to [allow the exit node from the admin console](https://tailscale.com/kb/1103/exit-nodes#allow-the-exit-node-from-the-admin-console) unless you have set up [auto approvers](https://tailscale.com/kb/1337/acl-syntax#autoapprovers). Use auto approvers so that when a device authenticated by a user that has access for the specified routes (as configured in the [`autoApprovers`](https://tailscale.com/kb/1337/acl-syntax#autoapprovers) section of your tailnet policy file), the device automatically has exit node approval.

### [Control access to third-party and SaaS apps](#control-access-to-third-party-and-saas-apps)

[App connectors](https://tailscale.com/kb/1281/app-connectors) let you control access to third-party and software as a service (SaaS) applications available over your tailnet in the same way that you would for self-hosted applications. For information about using an app connector, refer to [App connectors](https://tailscale.com/kb/1281/app-connectors).

### [Establish and record SSH sessions](#establish-and-record-ssh-sessions)

[Tailscale SSH](https://tailscale.com/kb/1193/tailscale-ssh) lets Tailscale manage the authentication and authorization of SSH connections in your tailnet. With Tailscale SSH, you can SSH to a device as normal, and optionally verify high-risk connections with [check mode](https://tailscale.com/kb/1193/tailscale-ssh#check-mode).

[Tailscale SSH session recording](https://tailscale.com/kb/1246/tailscale-ssh-session-recording) lets you stream logs of Tailscale SSH sessions to another device in your tailnet. These recordings use end-to-end encryption just like all other Tailscale traffic.

### [Add and approve users and devices](#add-and-approve-users-and-devices)

There's several ways to add users to your tailnet. For details, refer to [Inviting users](https://tailscale.com/kb/1371/invite-users).

User approval is a feature that lets Tailscale network administrators review and approve new users before they can join your tailnet. When you enable user approval, the first time a new user logs in to a tailnet, the user's status is pending. While in a pending state, the user can connect their device to the Tailscale coordination server, but cannot connect to other devices in the tailnet. An Owner, Admin, or IT admin of the tailnet can review the user information and set the user status to approved, or remove the user. For information about enabling user approval, refer to [Enable user approval for your network](https://tailscale.com/kb/1239/user-approval#enable-user-approval-for-your-network).

Device approval is a feature that lets Tailscale network administrators review and approve new devices before they can join your tailnet. Use device approval to ensure only trusted devices, such as workplace-managed laptops and phones, can access a network. For information about enabling device approval, refer to [Enable device approval for your network](https://tailscale.com/kb/1099/device-approval#enable-device-approval-for-your-network).

### [Use auth keys to add new devices](#use-auth-keys-to-add-new-devices)

You can use pre-authenticated keys ("auth keys") to register new devices without needing to sign in using a web browser. This applies whether or not you enable device approval. For details, refer to [Register a device with an auth key](https://tailscale.com/kb/1085/auth-keys#register-a-node-with-the-auth-key).

### [Enable HTTPS](#enable-https)

Connections between Tailscale nodes use end-to-end encryption. Browsers, web APIs, and products like VS Code are not aware of that, however, and can warn users or disable features based on the fact that HTTP URLs to your tailnet services look unencrypted since they're not using Transport Layer Security (TLS) certificates. To provision TLS certificates for devices in your tailnet, refer to [Enabling HTTPS](https://tailscale.com/kb/1153/enabling-https).

### [Monitor tailnet configuration and network flow](#monitor-tailnet-configuration-and-network-flow)

[Configuration audit logs](https://tailscale.com/kb/1203/audit-logging) let you identify _who_ did _what_, and _when_, in your tailnet. Configuration audit logs record actions that modify a tailnet's configuration, including the type of action, the actor, the target resource, and the time. Tailscale enables configuration audit logs for all tailnets and you cannot turn them off. You can monitor your configuration audit logs in the [Logs](https://login.tailscale.com/admin/logs) page of the admin console.

Network flow logs let you understand how and when nodes in your tailnet connect to each other. The data captured in network logs is the flow of network traffic, not the contents of network traffic. Tailscale does not and cannot inspect your traffic. For information about enabling network flow logs, refer to [Enable network flow logs](https://tailscale.com/kb/1219/network-flow-logs#enable-network-flow-logs).
```



### File: 1531-community-projects.md

```markdown
# Tailscale Community Projects

Tailscale Community Projects is a curated collection of community-supported open source projects built on Tailscale's platform. These projects showcase the breadth of how you can use Tailscale's networking and identity primitives to build secure, private tools for organizations and communities.

Tailscale Community Projects fall into the following categories:

-   **Apps**: Applications deployed by the user inside their Tailscale network (known as a tailnet) that natively leverage Tailscale.
-   **Tools**: Programs and scripts that users run manually or in a pipeline for a smoother Tailscale admin experience.
-   **Extensions**: Applications that a user deploys to modify or extend Tailscale's core functionality.
-   **Interfaces**: Applications that let users interact with Tailscale on their devices in new ways beyond our standard Tailscale clients or web interface.

The platform includes projects started by Tailscale, as well as projects from the broader Tailscale community. For details about the available projects, refer to the Tailscale Community Projects [catalog](https://tailscale.com/community/community-projects).

## [Consideration for inclusion](#consideration-for-inclusion)

Inclusion in the catalog is at the sole discretion of Tailscale, and there is no guarantee that a project will be featured. If you would like your project to be considered for inclusion, refer to the instructions in the Community Projects [catalog](https://tailscale.com/community/community-projects).

Some key aspects considered when a project is submitted are that it is:

-   **Open source**: Third-party community projects can carry any valid Open Source Initiative (OSI) [license](https://opensource.org/licenses). Projects should have their own repositories where community members can review the code and contribute issues and pull requests.
-   **Actively maintained**: Although no specific work to address issues/bugs is expected, we ask that projects aim to fix any reported security vulnerabilities as soon as possible.
-   **In compliance**. Projects submitted should be compliant with published Tailscale guidelines.

Tailscale will periodically monitor projects in the catalog to ensure they continue to meet these requirements. We reserve the right to remove projects from the catalog for any reason.

## [Supportability](#supportability)

For information about supportability of projects in the Tailscale Community Projects catalog, refer to the [Tailscale Community Projects](https://tailscale.com/special-terms#community-projects) section in our Special Terms.

Use of projects in the Tailscale Community Projects catalog is at your own risk. Tailscale has no responsibility for any outcomes.

For information about third-party community projects, refer to the documentation of the respective project.
```



### File: 1549-legacy-vpn-migration-guide.md

```markdown
# Migrate from a legacy VPN to Tailscale

## [Introduction](#introduction)

Legacy VPNs may not be sufficient to protect modern networks, and they typically need more setup, management, and maintenance compared to Tailscale. Tailscale is a mesh VPN service designed for protection of modern and legacy networks. Tailscale is built on the WireGuard® protocol, providing performance, privacy, and security by default.

To start your migration, you'll create a small network by installing and configuring Tailscale on two devices. Unlike a traditional VPN, you won't need a central gateway server. Next, you'll explore access controls to customize access within your network, and you'll explore how to configure Domain Name System (DNS) settings for handling DNS queries. When you complete the steps in this guide, you'll have a mesh network with end-to-end encrypted connections. You can build upon this network to completely migrate from a legacy VPN to Tailscale.

This guide applies to running Tailscale on your entire network. Benefits of running a Tailscale network include:

-   End-to-end encryption using WireGuard.
-   Fewer re-authentications required.
-   More reliable connectivity.
-   No hardware required.
-   Automatic encryption key management.
-   Better network performance.
-   Easier maintenance of access controls.
-   More comprehensive logging.
-   Automatically registered DNS names for devices in your network (through [MagicDNS](https://tailscale.com/kb/1081/magicdns)).

## [How Tailscale differs from legacy VPNs](#how-tailscale-differs-from-legacy-vpns)

Legacy VPNs often use a central server maintained by the user to create and manage encryption keys and client setup, and also to tunnel all network traffic between devices.

Tailscale uses WireGuard for creation of encryption keys, and the control plane handles key management. Tailscale provides client downloads and scripts to streamline installation. Tailscale facilitates direct connections between devices where possible. In the cases where it is not possible, a global set of relay servers to facilitate the network traffic, but these relays never decrypt the WireGuard tunnels between your devices.

## [Prerequisites](#prerequisites)

To follow this guide, you need:

-   An email account. Tailscale natively supports the following identity providers:

    -   Apple
    -   Google, including Gmail and Google Workspace (G Suite)
    -   GitHub
    -   Microsoft, including Microsoft Accounts, Microsoft 365, Active Directory, and Microsoft Entra ID

    If you are using a different identity provider, you need to take additional steps. Refer to [Setting up Okta](https://tailscale.com/kb/1066/sso-okta), [Setting up OneLogin](https://tailscale.com/kb/1070/sso-onelogin), or [Custom OIDC providers](https://tailscale.com/kb/1240/sso-custom-oidc), depending on which identity provider you use.

-   Two devices on which to install the Tailscale client. For example, you can use laptops, desktops, servers, and cell phones as the devices. Tailscale runs on most operating systems, including Linux, Windows, macOS, iOS, and Android.


## [Create your first tailnet](#create-your-first-tailnet)

Begin your migration to a Tailscale network (known as a tailnet) by installing the Tailscale client on a single device and logging in with the identity provider that you already use. This process automatically creates the tailnet for you.

1.  Go to the [Sign up](https://login.tailscale.com/start) page of the admin console and log in using a [single sign-on (SSO) identity provider](https://tailscale.com/kb/1013/sso-providers) account.

2.  On the **Welcome to Tailscale** page, select **Business use** or **Personal use**. If you plan to use this network with a team at work, select **Business use**. If you plan to use this network at home or with friends and family, select **Personal use**.

    ![Choosing use case for tailnet creation.](/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fwelcome-page.f3b91c91.png&w=1080&q=75)

    After you make your selection, select **Next**.

3.  On the **Let's add your first device** page, select the operating system (OS) that corresponds to the device you are using.

    ![Choosing an operating system for client installation.](/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fadd-first-device.faa6c43a.png&w=1080&q=75)

    Depending on your OS, you have an opportunity to download the Tailscale client or copy a command script. Install the client by using the download or script as needed for your device.

4.  When prompted to authenticate the client, log in using the same credentials that you used to create the tailnet in Step 1. Once authenticated, your device appears in the browser window.

    ![First device displayed in the browser window.](/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fadd-second-device.80198dfe.png&w=1080&q=75)


With your tailnet created and one device added, you'll connect another device so you can make a network connection between the two devices.

## [Add a second device to your tailnet](#add-a-second-device-to-your-tailnet)

To observe connectivity within your tailnet, add another device.

1.  On another device, go to [https://tailscale.com/download](https://tailscale.com/download). Install the Tailscale client by using the download or script as needed for your device, then log in at the Tailscale [Login](https://login.tailscale.com/login) page, using the same credentials that you used for your first device.

2.  Open the [Machines](https://login.tailscale.com/admin/machines) page of the Tailscale admin console. You manage your tailnet devices in the **Machines** page. Your two devices are in the list, with information such as the device name, IP address, who manages it, and so on.

    ![View of the tailnet machines.](/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fmachines-page.d18a35d9.png&w=1080&q=75)

3.  Open the [Users](https://login.tailscale.com/admin/users) page of the admin console. You manage your tailnet users on this page. Your email account is in the list.

    ![View of the tailnet users.](/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fusers-page.041de599.png&w=1080&q=75)

    Because you created the tailnet, your [user role](https://tailscale.com/kb/1138/user-roles) is Owner, which has complete admin access for your tailnet. When other users join your tailnet, you or others that are admins can set their role. A user's role helps determine their access to resources in your tailnet. For example, the [Admin](https://tailscale.com/kb/1138/user-roles#admin) role has more access to resources than the [Member](https://tailscale.com/kb/1138/user-roles#member) role, as shown in the [Permission matrix](https://tailscale.com/kb/1138/user-roles#permission-matrix).


Unlike some VPNs, which require a dedicated server maintained by you to manage your network, the Tailscale admin console runs on Tailscale's platform.

With two devices in your tailnet, you can now verify connectivity between the devices.

## [Verify connectivity between the two devices](#verify-connectivity-between-the-two-devices)

Unlike many VPNs, which use a central gateway server between connections, Tailscale devices establish direct peer-to-peer connections.

1.  To show that your two devices can communicate with each other, run a [Tailscale CLI](https://tailscale.com/kb/1080/cli) command. The Tailscale CLI runs on Linux, Windows, and macOS. (If you are running macOS, you need to [set up the Tailscale CLI](https://tailscale.com/kb/1080/cli?tab=macos#using-the-tailscale-cli) on your device first.)

    At a command prompt on one of your tailnet's devices, ping the other device by running:

    ```shell
    tailscale ping <other-device-name-or-ip>
    ```

    You can determine the value to use for `<other-device-name-or-ip>` by going to the [Machines](https://login.tailscale.com/admin/machines) page and copying the name of the other device. Alternatively, you can copy the device IP address.

    The `tailscale ping` command typically responds with a `pong` message that indicates how long it took for your `ping` command to receive a response. This shows you that your devices are able to connect and communicate with each other.

2.  For another command to get familiar with Tailscale, run:

    ```shell
    tailscale netcheck --verbose
    ```

    The `tailscale netcheck` command displays a report on your current physical network conditions. Included at the end of the report is the list of Designated Encrypted Relay for Packets (DERP) servers that Tailscale operates, and how long it takes your device to reach each server. DERP servers make the initial connection between devices to establish direct connections. In the case where direct connections are not possible, DERP servers handle [NAT traversal](https://tailscale.com/blog/how-nat-traversal-works) for the devices.

    If you are running Android or iOS, you cannot run the Tailscale CLI. You can still ping other devices using the Tailscale client.

    1.  On Android, open the Tailscale app. The app shows the list of devices in your tailnet. Long press one of the other devices and then select the Count Down Timer icon. The app shows the result of ten pings from your device to the other device, unless the other device is not connected.
    2.  On iOS, open the Tailscale app. The app shows the list of devices in your tailnet. Long press one of the other devices and then select **Ping**. The app shows the result of ten pings from your device to the other device, unless the other device is not connected.

With your tailnet in place, you can now move on to restricting access to a device.

## [Configure access control to a device](#configure-access-control-to-a-device)

Within your tailnet, you can restrict access based on users, groups, autogroups, tags, Tailscale IP addresses, and subnet ranges.

To read or update the access controls configured for your tailnet, open the [Access controls](https://login.tailscale.com/admin/acls) page of the admin console. This page shows the tailnet policy for the devices and users allowed to connect in your network. The policy stores as a [tailnet policy file](https://tailscale.com/kb/1395/tailnet-policy-file).

Tailscale initialized your tailnet policy file with a [default allow all access policy](https://tailscale.com/kb/1192/acl-samples#allow-all-default-acl). This lets you connect to and use Tailscale without restricting any traffic in your network and grants all devices in the tailnet access to all other devices in the tailnet.

To use a different policy that is less permissive than the default policy, edit your tailnet policy file. As an example, the following policy grants all users access to their own devices.

1.  Open the [Access controls](https://login.tailscale.com/admin/acls) page of the admin console.

2.  Within the **View file** tab, replace the contents with the following JSON:

    ```json
    {
      // All users can access their own devices.
      "grants": [
        {
       "src": ["autogroup:member"],
       "dst": ["autogroup:self"],
       "ip":  ["*"]
        }
      ]
    }
    ```

    You can use the [visual policy editor](https://tailscale.com/kb/1550/visual-editor) to manage your tailnet policy file. Refer to the [visual editor reference](https://tailscale.com/kb/1587/visual-editor-reference) for guidance on using the visual editor.

3.  Select **Save**.


It is suitable for many use cases where you want to allow users to access their own devices, but not other devices in the tailnet.

The syntax for this policy contains the following:

-   `grants`: The policy is based on grants, as opposed to the legacy (but still supported) access control lists (`acls`).
-   `src`: An array of selectors that define the source of the grant. In this case, the array contains the `autogroup:member` [autogroup](https://tailscale.com/kb/1337/acl-syntax#autogroups), which grants access for any user who is a direct member of your tailnet.
-   `dst`: An array of selectors that define the destination of the grant. In this case, the array contains the `autogroup:self` autogroup, which grants access for any user that is authenticated as the same user as the source.
-   `ip`: An array of strings that define the network-layer capabilities to grant. In this case, the array contains `*`, which grants access to all ports on the destination.

For more information about the syntax shown in this policy, refer to [Grants](https://tailscale.com/kb/1324/grants).

You have now modified the tailnet policy file from the default. You're ready to customize it again to provide more granular access control.

## [Restrict access based on user role and purpose](#restrict-access-based-on-user-role-and-purpose)

To let users access devices appropriate for their role and purpose, update your tailnet policy file to use additional controls. For example, configure your policy to support the following scenario:

-   All employees can access devices considered for internal use, like a web server that lists company holidays.
-   Members of the engineering team can access the devices intended for engineering use only.
-   Members of the finance team can access the devices intended for finance use only.
-   Members of the legal team can access the devices intended for legal use only.
-   Your tailnet's admins (such as the IT team) can manage which devices are considered as internal, engineering, finance, or legal.

To designate a purpose for a device, Tailscale provides [tags](https://tailscale.com/kb/1068/tags), which let you manage access control for the device.

You define groups and tags directly in your tailnet policy file.

1.  Open the [Access controls](https://login.tailscale.com/admin/acls) page of the admin console and make the **View file** tab the active tab.

2.  Add a `groups` array, and add an entry to define each team and its members.

    ```json
    {
      "groups": {
        // Alice and Frank are in group:engineering
        "group:engineering": ["alice@example.com", "frank@example.com"],
        // Bob and Dana are in group:finance
        "group:finance": ["bob@example.com", "dana@example.com"],
        // Carl is in group:legal
        "group:legal": ["carl@example.com"]
      },

      // All users can access their own devices.
      "grants": [
        {
       "src": ["autogroup:member"],
       "dst": ["autogroup:self"],
       "ip":  ["*"]
        },

      ]
    }
    ```

    The [`groups`](https://tailscale.com/kb/1337/acl-syntax#groups) section lets you create groups of users, which you can use in access rules, instead of listing users out explicitly. This policy creates groups `group:engineering`, `group:finance`, and `group:legal`, and adds an array of users to each group. For example, `group:engineering` contains `alice@example.com` and `frank@example.com` as members.

3.  Within the `grants` array, add grants for the `engineering` team:

    ```json
      // All users can access their own devices.
      "grants": [
        {
       "src": ["autogroup:member"],
       "dst": ["autogroup:self"],
       "ip":  ["*"]
        },

        // Users in group:engineering can access devices tagged with tag:engineering
        {
       "src": ["group:engineering"],
       "dst": ["tag:engineering"],
       "ip":  ["*"]
        },

       ]
    ```

    The `src` is the previously created `group:engineering` group. The `dst` is the `tag:engineering` tag, which results in any member of the engineering team being able to access devices that contain the `tag:engineering` tag.

4.  Also add grants for the `finance` and `legal` teams:

    ```json
      // All users can access their own devices.
      "grants": [
        {
       "src": ["autogroup:member"],
       "dst": ["autogroup:self"],
       "ip":  ["*"]
        },

        // Users in group:engineering can access devices tagged with tag:engineering
        {
       "src": ["group:engineering"],
       "dst": ["tag:engineering"],
       "ip":  ["*"]
        },

        // Users in group:finance can access devices tagged with tag:finance
        {
         "src": ["group:finance"],
         "dst": ["tag:finance"],
         "ip":  ["*"]
        },

        // Users in group:legal can access devices tagged with tag:legal
        {
       "src": ["group:legal"],
       "dst": ["tag:legal"],
       "ip":  ["*"]
        },

     ]
    ```

5.  Add a grant entry that grants all tailnet members access to devices tagged as `tag:internal`.

    ```json
      // All users can access their own devices.
      "grants": [
        {
       "src": ["autogroup:member"],
       "dst": ["autogroup:self"],
       "ip":  ["*"]
        },

        // Users in group:engineering can access devices tagged with tag:engineering
        {
       "src": ["group:engineering"],
       "dst": ["tag:engineering"],
       "ip":  ["*"]
        },

        // Users in group:finance can access devices tagged with tag:finance
        {
         "src": ["group:finance"],
         "dst": ["tag:finance"],
         "ip":  ["*"]
        },

        // Users in group:legal can access devices tagged with tag:legal
        {
       "src": ["group:legal"],
       "dst": ["tag:legal"],
       "ip":  ["*"]
        },

        // All employees can access devices tagged with tag:internal
        {
       "src": ["autogroup:member"],
       "dst": ["tag:internal"],
       "ip":  ["*"]
        }

     ],
    ```

6.  Below the `grants` array, but before the closing bracket of your tailnet policy file, define a `tagOwners` section. Within the `tagOwners` section, add an entry to define each tag and the members of your tailnet that can apply the tag to a device. For brevity of this example, make the `autogroup:admin` [autogroup](https://tailscale.com/kb/1337/acl-syntax#autogroups) the tag owner.

    ```json
        // All employees can access devices tagged with tag:internal
        {
       "src": ["autogroup:member"],
       "dst": ["tag:internal"],
       "ip":  ["*"]
        }

     ],

      "tagOwners": {
        // Users who are Tailscale admins can apply the tag tag:engineering
        "tag:engineering": ["autogroup:admin"],
        // Users who are Tailscale admins can apply the tag tag:finance
        "tag:finance": ["autogroup:admin"],
        // Users who are Tailscale admins can apply the tag tag:legal
        "tag:legal": ["autogroup:admin"],
        // Users who are Tailscale admins can apply the tag tag:internal
        "tag:internal": ["autogroup:admin"]
      }

    }
    ```

    Now any [Admin](https://tailscale.com/kb/1138/user-roles#admin) in your tailnet can apply the tags to devices.

7.  The following shows the entire tailnet policy file:

    ```json
    {
      "groups": {
        // Alice and Frank are in group:engineering
        "group:engineering": ["alice@example.com", "frank@example.com"],
        // Bob and Dana are in group:finance
        "group:finance": ["bob@example.com", "dana@example.com"],
        // Carl is in group:legal
        "group:legal": ["carl@example.com"]
      },

      // All users can access their own devices.
      "grants": [
        {
       "src": ["autogroup:member"],
       "dst": ["autogroup:self"],
       "ip":  ["*"]
        },

        // Users in group:engineering can access devices tagged with tag:engineering
        {
       "src": ["group:engineering"],
       "dst": ["tag:engineering"],
       "ip":  ["*"]
        },

        // Users in group:finance can access devices tagged with tag:finance
        {
         "src": ["group:finance"],
         "dst": ["tag:finance"],
         "ip":  ["*"]
        },

        // Users in group:legal can access devices tagged with tag:legal
        {
       "src": ["group:legal"],
       "dst": ["tag:legal"],
       "ip":  ["*"]
        },

        // All employees can access devices tagged with tag:internal
        {
       "src": ["autogroup:member"],
       "dst": ["tag:internal"],
       "ip":  ["*"]
        }
     ],

      "tagOwners": {
        // Users who are Tailscale admins can apply the tag tag:engineering
        "tag:engineering": ["autogroup:admin"],
        // Users who are Tailscale admins can apply the tag tag:finance
        "tag:finance": ["autogroup:admin"],
        // Users who are Tailscale admins can apply the tag tag:legal
        "tag:legal": ["autogroup:admin"],
        // Users who are Tailscale admins can apply the tag tag:internal
        "tag:internal": ["autogroup:admin"]
      }
    }
    ```

    You can use the [visual policy editor](https://tailscale.com/kb/1550/visual-editor) to manage your tailnet policy file. Refer to the [visual editor reference](https://tailscale.com/kb/1587/visual-editor-reference) for guidance on using the visual editor.

8.  Select **Save**.


Now that you have defined tags for your tailnet, set up a device with the tag named `tag:engineering`.

1.  Add a new device to your tailnet, as done in the [Add a second device to your tailnet](#add-a-second-device-to-your-tailnet) section.

2.  Open the [Machines](https://login.tailscale.com/admin/machines) page of the admin console.

3.  Select the machine that you added to your tailnet.

4.  Select the ![ellipsis icon](/files/images/icons/fa-ellipsis-h.svg) menu.

5.  Select **Edit ACL tags**.

6.  Select **Add tags**.

7.  Select the tag `tag:engineering`.

    ![Add a tag to a device.](/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fedit-tags.0c0b72bc.png&w=1080&q=75)

8.  Select **Save**.


You have now set up identity-first networking based on purpose for your tailnet. For example, any member of the `group:engineering` group can access this device because the policy permits it. Anyone outside of the `group:engineering` cannot access the device.

In addition to tagging a device by using the admin console, you can tag devices using the Tailscale CLI and the Tailscale API.

For additional information about access control within Tailscale, refer to [Manage access](https://tailscale.com/kb/1350/manage).

Now that you have explored access control, move on to DNS configuration.

## [Configure DNS settings](#configure-dns-settings)

If your legacy VPN configuration requires clients to use specific DNS servers, configure your tailnet to do the same. By default, your tailnet has [MagicDNS](https://tailscale.com/kb/1081/magicdns) enabled, which means that your tailnet automatically registers DNS names for devices in your network. You only need to add other DNS servers if you want to use global nameservers or restricted nameservers (known as split DNS).

1.  Open the [DNS](https://login.tailscale.com/admin/dns) page in the Tailscale admin console.
2.  In the **Nameservers** section, select **Add nameserver** and then add any public DNS servers, as well as custom DNS servers, that you want to use.
3.  Also in the [DNS](https://login.tailscale.com/admin/dns) page in the Tailscale admin console, add any search domains. Search domains provide a convenient way for users to access local network resources without having to specify the full domain path every time they connect to a resource. You can specify a list of domain suffixes that are automatically appended to any domain name that is not a fully qualified domain name (FQDN).

Now when users in your tailnet browse the internet or perform other network communication, their DNS queries resolve to the hosts as configured by your DNS settings.

## [Conclusion](#conclusion)

You created a Tailscale network and installed the Tailscale client on two devices. You ensured that the two devices can connect to each other. You also used the Tailscale admin console to manage users, devices, and access control (among other tasks not yet shown). And if your legacy VPN configuration used specific DNS servers, you configured Tailscale to use the same DNS servers.

Continue on to discover more about Tailscale networking features and how to configure them in your tailnet.

## [Further exploration](#further-exploration)

Explore Tailscale features that let you customize network traffic routes, use SSH to securely connect to devices, and manage users and devices. Also discover features that let you enable HTTPS for your devices, as well as monitor your tailnet configuration and network traffic flow.

### [Access devices where you can't install the Tailscale client](#access-devices-where-you-cant-install-the-tailscale-client)

Tailscale works best when you install the Tailscale client on every device in your organization. This enforces end-to-end traffic encryption without additional configuration.

However, there are situations where you can't or don't want to install the Tailscale client on each device. For example, some devices, like printers, might not allow installing the Tailscale client. Additionally, installing the Tailscale client on every device might not make sense. This is true when connecting many devices, like an entire virtual private cloud (VPC), or gradually deploying Tailscale to a legacy network. In these cases, you can set up a [subnet router](https://tailscale.com/kb/1019/subnets) to access these devices from your tailnet. Subnet routers act as a gateway, relaying traffic from your tailnet to a physical subnet. For OS-specific instructions for setting up and using a subnet router, refer to [Set up a subnet router](https://tailscale.com/kb/1019/subnets#set-up-a-subnet-router).

When you set up a subnet router, use the same Classless Inter-domain Routing (CIDR) values that you used in your legacy VPN.

When you add [access rules for the advertised subnet routes](https://tailscale.com/kb/1019/subnets?tab=linux#add-access-rules-for-the-advertised-subnet-routes), in Tailscale you grant access to the routes themselves (such as `192.0.2.0/24`). This is different from some VPNs, which grant routing access to a device, not to the routes that the device provides.

When you set up a device to serve as a subnet router, you need to [enable the subnet routes in the admin console](https://tailscale.com/kb/1019/subnets#enable-subnet-routes-from-the-admin-console) unless you have set up [auto approvers](https://tailscale.com/kb/1337/acl-syntax#autoapprovers). Use auto approvers so that when a device authenticated by a user that has access for the specified routes (as configured in the [`autoApprovers`](https://tailscale.com/kb/1337/acl-syntax#autoapprovers) section of your tailnet policy file), the device automatically has subnet routes approval.

### [Route public internet traffic through a single device](#route-public-internet-traffic-through-a-single-device)

There might be times when you want Tailscale to route your public internet traffic. For example, you might want to route all your public internet traffic if:

-   You're in a coffee shop with untrusted Wi-Fi.
-   You're traveling overseas and need access to an online service (such as banking) only available in your home country.

You can route all your public internet traffic by setting a device on your network as an [exit node](https://tailscale.com/kb/1103/exit-nodes). When you route all traffic through an exit node, you're effectively using default routes (`0.0.0.0/0, ::/0`), similar to how you would if you were using a typical virtual private network (VPN). For OS-specific instructions for setting up and using an exit node, refer to [Use exit nodes](https://tailscale.com/kb/1408/quick-guide-exit-nodes).

When you set up a device to serve as an exit node, you need to [allow the exit node from the admin console](https://tailscale.com/kb/1103/exit-nodes#allow-the-exit-node-from-the-admin-console) unless you have set up [auto approvers](https://tailscale.com/kb/1337/acl-syntax#autoapprovers). Use auto approvers so that when a device authenticated by a user that has access for the specified routes (as configured in the [`autoApprovers`](https://tailscale.com/kb/1337/acl-syntax#autoapprovers) section of your tailnet policy file), the device automatically has exit node approval.

### [Control access to third-party and SaaS apps](#control-access-to-third-party-and-saas-apps)

[App connectors](https://tailscale.com/kb/1281/app-connectors) let you control access to third-party and software as a service (SaaS) applications available over your tailnet in the same way that you would for self-hosted applications. For information about using an app connector, refer to [App connectors](https://tailscale.com/kb/1281/app-connectors).

### [Establish and record SSH sessions](#establish-and-record-ssh-sessions)

[Tailscale SSH](https://tailscale.com/kb/1193/tailscale-ssh) lets Tailscale manage the authentication and authorization of SSH connections in your tailnet. With Tailscale SSH, you can SSH to a device as normal, and optionally verify high-risk connections with [check mode](https://tailscale.com/kb/1193/tailscale-ssh#check-mode).

[Tailscale SSH session recording](https://tailscale.com/kb/1246/tailscale-ssh-session-recording) lets you stream logs of Tailscale SSH sessions to another device in your tailnet. These recordings use end-to-end encryption just like all other Tailscale traffic.

### [Add and approve users and devices](#add-and-approve-users-and-devices)

There's several ways to add users to your tailnet. For details, refer to [Inviting users](https://tailscale.com/kb/1371/invite-users).

User approval is a feature that lets Tailscale network administrators review and approve new users before they can join your tailnet. When you enable user approval, the first time a new user logs in to a tailnet, the user's status is pending. While in a pending state, the user can connect their device to the Tailscale coordination server, but cannot connect to other devices in the tailnet. An Owner, Admin, or IT admin of the tailnet can review the user information and set the user status to approved, or remove the user. For information about enabling user approval, refer to [Enable user approval for your network](https://tailscale.com/kb/1239/user-approval#enable-user-approval-for-your-network).

Device approval is a feature that lets Tailscale network administrators review and approve new devices before they can join your tailnet. Use device approval to ensure only trusted devices, such as workplace-managed laptops and phones, can access a network. For information about enabling device approval, refer to [Enable device approval for your network](https://tailscale.com/kb/1099/device-approval#enable-device-approval-for-your-network).

### [Use auth keys to add new devices](#use-auth-keys-to-add-new-devices)

You can use pre-authenticated keys ("auth keys") to register new devices without needing to sign in using a web browser. This applies whether or not you enable device approval. For details, refer to [Register a device with an auth key](https://tailscale.com/kb/1085/auth-keys#register-a-node-with-the-auth-key).

### [Enable HTTPS](#enable-https)

Connections between Tailscale nodes use end-to-end encryption. Browsers, web APIs, and products like VS Code are not aware of that, however, and can warn users or disable features based on the fact that HTTP URLs to your tailnet services look unencrypted since they're not using Transport Layer Security (TLS) certificates. To provision TLS certificates for devices in your tailnet, refer to [Enabling HTTPS](https://tailscale.com/kb/1153/enabling-https).

### [Monitor tailnet configuration and network flow](#monitor-tailnet-configuration-and-network-flow)

[Configuration audit logs](https://tailscale.com/kb/1203/audit-logging) let you identify _who_ did _what_, and _when_, in your tailnet. Configuration audit logs record actions that modify a tailnet's configuration, including the type of action, the actor, the target resource, and the time. Tailscale enables configuration audit logs for all tailnets and you cannot turn them off. You can monitor your configuration audit logs in the [Logs](https://login.tailscale.com/admin/logs) page of the admin console.

Network flow logs let you understand how and when nodes in your tailnet connect to each other. The data captured in network logs is the flow of network traffic, not the contents of network traffic. Tailscale does not and cannot inspect your traffic. For information about enabling network flow logs, refer to [Enable network flow logs](https://tailscale.com/kb/1219/network-flow-logs#enable-network-flow-logs).
```



### File: 1552-tailscale-services.md

```markdown
# Tailscale Services

Tailscale Services is currently [in beta](https://tailscale.com/kb/1167/release-stages#beta).

Services increase reliability, leverage Tailscale's access-controlled routing, and provide a centralized way to manage all internal resources available in your Tailscale network (known as a tailnet). You can focus on maintaining your applications while Tailscale handles the networking complexity.

Tailscale Services let you publish internal resources (like databases or web servers) as named services in your tailnet.

Instead of connecting to specific devices, users connect to Tailscale Services using stable [MagicDNS](https://tailscale.com/kb/1081/magicdns) names while Tailscale automatically routes traffic to available hosts across your infrastructure.

This approach decouples your resources from the devices hosting them. For example, a database service remains accessible at the same address even when you migrate it to a different host, add redundant hosts for high availability, or route traffic across regions. You gain built-in traffic steering, granular access control, approval workflows, and the ability to configure different endpoint types for different layers of the networking stack.

## [Use cases](#use-cases)

You can use Tailscale Services in a variety of scenarios to securely expose internal resources within your tailnet in a way that decouples them from the devices hosting them. For example:

-   **Developer workflows and internal tooling**: Make any internal application or developer resource highly available, horizontally scalable, and secure without complex load balancer configurations.
-   **Database connectivity**: Connect securely to database clusters (PostgreSQL, MySQL, RDS) with simplified connection scaling and identity-based access controls.
-   **Cluster meshes**: Enable cross-cluster or hybrid-cloud connectivity between any compute resources like EC2 instances, Kubernetes services, or containers.
-   **Version-controlled applications**: Generate stable hostnames for frequently updated, version-controlled, or ephemeral resources that persist across deployments.
-   **IoT integrations**: Stream device logs and telemetry securely to SIEM or logging services without exposing IoT devices to the public internet.
-   **Internal APIs and webhooks**: Expose internal APIs securely without public domains or complex mTLS configurations while maintaining granular access control.

## [Prerequisites](#prerequisites)

To get started with Tailscale Services, you must have:

-   An active tailnet.
-   One or more devices running Tailscale v1.86.0 or later, or an [unstable](https://tailscale.com/kb/1083/install-unstable) v1.87.x release.
-   [Owner, Admin, or Network admin](https://tailscale.com/kb/1138/user-roles) account permissions.
-   An internal resource running on a tailnet device that you want to expose as a Tailscale Service. The device hosting the resource must use a [tag-based](https://tailscale.com/kb/1068/tags) identity.

## [Get started](#get-started)

To get started with Tailscale Services, you need to define a Service through the admin console, configure an endpoint on a tailnet device (the host), then advertise the endpoint.

### [Step 1: Define a Tailscale Service](#step-1-define-a-tailscale-service)

You define a Tailscale Service using the admin console. Each Tailscale Service consists of a MagicDNS name, a TailVIP (Tailscale Virtual IP address), a resource definition, and one or more back-end hosts.

1.  Open the [Services](https://login.tailscale.com/admin/services) page of the admin console.
2.  Select **Advertise**, and then select **Define a Service**.
3.  Within the **Define a Service** dialog, provide a name and description for your Service.
4.  Choose a port or set of endpoints your Service will advertise, including the `tcp:` transport protocol prefix (for example, `tcp:443`). Currently, TCP is the only supported transport protocol. Alternatively, enter `do-not-validate` to skip endpoint validation.
5.  (Optional) Provide the Service with an identity by adding one or more [tags](https://tailscale.com/kb/1068/tags).
6.  Select **Add service**.

You have now defined the Service interface. Next, you need to configure a tailnet device as a Service host.

### [Step 2: Configure a Service host](#step-2-configure-a-service-host)

A Service host is a Tailscale device that runs the Tailscale client and advertises one or more endpoints for a specific Tailscale Service. The host handles incoming connections to the Service and routes them to the appropriate resource. Hosts can advertise both local and remote resources.

Any device you want to use as a Service host must use a [tag-based identity](https://tailscale.com/kb/1068/tags). You cannot use a device authenticated with a user account as a Service host.

Make sure to start the resource on a tailnet device that you want to expose as a Tailscale Service. This resource can be a web server, database, or any other service that you want to make available through Tailscale.

For example, you might start a basic web server using Node.js and the [`http-server` package](https://www.npmjs.com/package/http-server) that listens on port `8080`:

```shell
# Install globally
npm install -g http-server

# Then start a basic web server
http-server -p 8080
```

This example starts a basic web server that serves static files from the current directory on port `8080`.

After you have your resource running and listening for connections, you can configure it as a Service host.

You can configure a Service host using either the `tailscale serve` CLI command or using a [Service configuration file](https://tailscale.com/kb/1589/tailscale-services-configuration-file).

Tailscale recommends using the CLI method because it automatically handles both configuration and advertisement, while the configuration file method gives you control over these as separate steps.

1.  Run the `tailscale serve` command with the `--service` flag followed by the service name, the protocol, the port number, and the destination:

    ```shell
    tailscale serve --service=svc:web-server --https=443 127.0.0.1:8080
    ```

    The command returns output similar to the following:

    ```shell
    This machine is configured as a service host for `svc:web-server`, but approval from an admin is required. Once approved, it will be available in your Tailnet as:

    http://web-server.<tailnet-name>.ts.net:443/
    |-- proxy http://127.0.0.1:8080
    ```

    When you configure and advertise an endpoint using the `tailscale serve` CLI command, it automatically uses background mode (which you would normally need to use the `--bg` flag for when using the `tailscale serve` command).

    This command configures and automatically advertises an endpoint for the resource. When you use the `tailscale serve` command with the HTTPS protocol, Tailscale automatically provisions a TLS certificate for your unique tailnet DNS name.

2.  Run the `tailscale serve status` command to verify your configuration:

    ```shell
    tailscale serve status --json
    ```


### [Step 3: Approve a Service host](#step-3-approve-a-service-host)

If your tailnet has [auto-approval](https://tailscale.com/kb/1337/policy-syntax#autoapprovers) policies set up for the Service, the host is automatically approved. If not, an [Admin, Network admin, or Owner](https://tailscale.com/kb/1138/user-roles) must approve the host before it becomes active.

1.  Open the [Services](https://login.tailscale.com/admin/services) page of the admin console.
2.  Select the name of the Service you created earlier.
3.  Locate the pending advertisements in the **Service hosts** section.
4.  Select **Approve**.

After approval, the host becomes active and starts handling traffic for the Tailscale Service. Users in the tailnet can now connect to the Service using its MagicDNS name or IP addresses (provided they have the necessary access permissions).

### [Step 4: Access Tailscale Services from other devices](#step-4-access-tailscale-services-from-other-devices)

After you configure and approve a Tailscale Service, you need to ensure that other devices in your tailnet can discover and use the routes to the advertised resources. This process varies slightly by operating system.

Android, iOS, macOS, tvOS, and Windows automatically pick up your new routes to Tailscale Services.

By default, Linux devices only discover [Tailscale IP addresses](https://tailscale.com/kb/1015/100.x-addresses). To enable automatic discovery of new subnet routes on Linux devices, use the `--accept-routes` flag with the [`tailscale set`](https://tailscale.com/kb/1080/cli#set) command:

```shell
sudo tailscale set --accept-routes
```

## [Common scenarios](#common-scenarios)

This section covers common scenarios for managing Tailscale Service hosts, including draining a host, removing a host configuration, and updating a Service host configuration.

### [Drain a host](#drain-a-host)

When you need to take a Service host offline, you should first drain the host. Draining a host stops it from accepting new incoming connections while letting existing connections to close gracefully.

Use the `tailscale serve drain` command to stop the host from advertising itself for a service (`svc:<service-name>`):

```shell
tailscale serve drain svc:<service-name>
```

After you run the `tailscale serve drain` command, all associated endpoints on the host stop accepting new incoming connections. However, any ongoing connections remain alive until they close normally.

After all connections close gracefully, you can safely remove all relevant endpoint configurations.

### [Remove a host configuration](#remove-a-host-configuration)

Do not remove an endpoint configuration before draining it. Doing so abruptly ends all connections to the advertised resource.

After draining the endpoint for a resource, you can remove its configuration using one of three ways: remove a specific endpoint (for a single `protocol:port` endpoint mapping), remove the entire host configuration, or reset the configuration file. The best method depends on how much of the configuration file you want to preserve.

You can check your Service configuration file at any point using the `tailscale serve status` command.

```shell
tailscale serve status -json
```

#### [Remove an endpoint](#remove-an-endpoint)

If you configured multiple endpoints for a single resource using different port numbers or protocols, you can use the `off` argument to remove only a specific endpoint mapping. To remove a specific endpoint mapping for a resource for a specific port number, re-run the original `tailscale serve` command (that you used to configure the endpoint) with the `off` argument. You must run the command with the same values and flags as you did to set up the endpoint.

```shell
tailscale serve --service:"svc:<service-name>" --https:<port> <additional-flags> off
```

Adding the `off` argument at the end of the command you used to advertise the endpoint with the same flag removes the endpoint configured for a port. For example, have an endpoint for `web-server` on HTTPS port `443` and an endpoint for `web-server` on HTTP ports `80` and `3000` and you need to remove the endpoint for HTTPS port `443`:

1.  Run this command to disable its configuration for only HTTPS port `443`:

    ```shell
    tailscale serve --service="svc:web-server" --https=443 off
    ```

2.  Then, re-advertise with only HTTP port `80`:

    ```shell
    tailscale serve advertise svc:web-server
    ```


Here's a more complete example of removing an endpoint:

```shell
# Run tailscale up <...>
# Set up a few L7 endpoints:

tailscale serve --service="svc:web-server" --https=443 8080
tailscale serve --service="svc:web-server" --https=443 --set-path /mt2 8081
tailscale serve --service="svc:web-server" --http=80 3000

# When you want to modify config, drain it first.

tailscale serve drain svc:web-server

# Wait until all connections close.

# To only remove the endpoint configuration for the /mt2 path on port 443:

tailscale serve --service="svc:web-server" --https=443 --set-path /mt2 off

# Then, advertise it again and it will only create one endpoint on HTTPS port 443

tailscale serve advertise svc:web-server

# To remove the endpoint configuration for for HTTPS port 443:

tailscale serve --service:"svc:web-server" --https=443 off
# You will see a prompt asking you to confirm
# After you confirm, it removes all configured endpoints on port 443 but preserves other port configured for the same service resource.
# Advertise the service again without the removed HTTPS port:

tailscale serve advertise svc:web-server
```

#### [Remove all endpoint mappings for a Service](#remove-all-endpoint-mappings-for-a-service)

To remove the configuration for a specific Service (which can have one or more endpoints), use the `tailscale serve clear` command.

```shell
tailscale serve clear svc:<service-name>
```

This removes all endpoint configurations for the Service from service configuration file.

Here's a more complete example of removing all endpoint configurations for a resource:

```shell
# Run tailscale up <...>
# Set up a few L7 endpoints:

tailscale serve --service="svc:web-server" --https=443 8080
tailscale serve --service="svc:web-server" --https=443 --set-path /mt2 8081
tailscale serve --service="svc:web-server" --http=80 3000

# When you want to modify config, drain it first:

tailscale serve drain svc:web-server

# Wait until all connections close.

# Remove the configuration for svc:web-server:

tailscale serve clear svc:web-server
```

#### [Remove all Service configurations](#remove-all-service-configurations)

To reset the entire configuration file (removing all configured Service configurations), use the `tailscale serve reset` command.

```shell
tailscale serve reset
```

This removes all configured endpoints from the Services configuration file.

### [Update a Service host configuration](#update-a-service-host-configuration)

You can update or modify a host's Service configuration using the `tailscale serve` command or by editing the Service configuration file directly. You should drain the host before modification.

To update an endpoint configuration for a given protocol, port, and path, run `tailscale serve` with the same flags. For example, to start an endpoint configured with HTTPS on port `443`:

1.  Run the following command to start an endpoint configured with HTTPS on port `443`:

    ```shell
    tailscale serve --service="svc:web-server" --https=443 https://localhost:443
    ```

2.  Then, check the configuration with `tailscale serve get-config --all`:

    ```json
    {
      "version": "0.0.1",
      "services": {
        "svc:web-server": {
          "endpoints": {
           "tcp:443": "https://localhost:443"
          }
        }
      }
    }
    ```

    To update the endpoint default path point to local port `8081`:

3.  Run the following command:

    ```shell
    tailscale serve --service="svc:web-server" --https=443 https://localhost:8081
    ```

4.  Then, check the configuration with `tailscale serve get-config --all`:

    ```json
    {
    "version": "0.0.1",
      "services": {
        "svc:web-server": {
          "endpoints": {
            "tcp:443": "https://localhost:8081"
          }
        }
      }
    }
    ```


To run a different protocol on a port for a local resource, you need to remove the existing endpoint configuration on the port, then add the configuration again. For example, let's say you have an endpoint configured for `my-web-app` with HTTPS on port `443` pointed to a text example, but you need to update it to use HTTP instead of HTTPS:

1.  Remove the endpoint configuration for port `443` by running the following command:

    ```shell
    tailscale serve --service="svc:my-web-app" --https=443 off
    ```

2.  Then, re-run the `tailscale serve` command to set up the endpoint with HTTP:

    ```shell
    tailscale serve --service="svc:my-web-app" --http=443 http://localhost:8081
    ```

    The command returns output similar to the following:

    ```shell
    Available within your tailnet:

    http://web-server.king-grouse.ts.net:443/
    |-- text  "example"
    ```


### [Configure a Service host using a configuration file](#configure-a-service-host-using-a-configuration-file)

To configure a Service host using the [Service configuration syntax](https://tailscale.com/kb/1589/tailscale-services-configuration-file), you need to create a configuration file (such as `serveconfig.json`) that contains the configuration for the Service host. Note that when you use the configuration file method, you must configure each endpoint mapping, then advertise it as two separate steps.

1.  Create a file named `serveconfig.json` that contains a [`tailscale serve`](https://tailscale.com/kb/1242/tailscale-serve) configuration. This example configures an endpoint for a local web server exposed on port `443` over HTTPS:

    ```json
    {
    "version": "0.0.1",
      "services": {
        "svc:web-server": {
          "endpoints": {
            "tcp:443": "https://localhost:443"
          }
        }
      }
    }
    ```

2.  Use the `tailscale serve set-config` command to apply the configuration file:

    ```shell
    tailscale serve set-config --all serveconfig.json
    ```

3.  Run the `tailscale serve status` command to verify your configuration:

    ```shell
    tailscale serve get-config --all
    ```

4.  Advertise the endpoint:

    ```shell
    tailscale serve advertise svc:<service-name>
    ```


Your service host is now handling traffic for your Tailscale Service. You can validate this by running `tailscale status --json | jq '.Self.CapMap."service-host"'` to check the service-host status.

### [Set up automatic approval](#set-up-automatic-approval)

Tailscale clients can advertise new Service hosts, but administrators must approve or deny new advertisements (similar to [subnet route approval](https://tailscale.com/kb/1019/subnets#enable-subnet-routes-from-the-admin-console)). You can set auto-approval policies to enable certain clients, users, or tags to automatically advertise and approve new hosts for a specific Service or group of Services.

1.  Go to the [Access controls](https://login.tailscale.com/admin/acls) page of the admin console.

2.  Create an auto-approval policy to approve new hosts for an individual Tailscale Service or groups of Tailscale Services (defined by a [tag](https://tailscale.com/kb/1068/tags)). The following shows an example:

    ```json
    "autoApprovers": {
      "services": {
        "svc:<service-name>": ["tag:server"],
        "tag:prod-service": ["tag:prod-infra"]
      },
    },
    ```

    You can use the [visual policy editor](https://tailscale.com/kb/1550/visual-editor) to manage your tailnet policy file. Refer to the [visual editor reference](https://tailscale.com/kb/1587/visual-editor-reference) for guidance on using the visual editor.


The example creates an auto-approval rule for Tailscale clients tagged with the `tag:server` to advertise new Service Proxies, for the Tailscale Service `svc:<service-name>`. Additionally, it specifies that Tailscale clients with the tag `tag:prod-infra` can advertise new Service Proxies, and automatically receive approval, for Tailscale Services with the tag `tag:prod-service`.

### [Validate your Service](#validate-your-service)

You can validate that your Service successfully advertised locally, and that it passed validation. To do this, run the following [`tailscale status`](https://tailscale.com/kb/1080/cli#status) command and pass its output to the [`jq`](https://jqlang.org/) command-line JSON processor:

```shell
tailscale status --json | jq '.Self.CapMap."service-host"'
```

The `jq` output should show the `service-host` status.

#### [Configure Service access](#configure-service-access)

You can use a Tailscale Service as a destination in [grant](https://tailscale.com/kb/1324/grants) access control policies.

1.  Go to the [Access controls](https://login.tailscale.com/admin/acls) page of the admin console.
2.  Create a grant rule that grants access to your Service. For example, this grant uses `svc:web-server` a destination, on port `443`, with access granted to `"autogroup:member`.

```json
{
  "src":  ["autogroup:member"],
  "dst":  ["svc:web-server"],
  "ip": ["443"],
},
```

You can use the [visual policy editor](https://tailscale.com/kb/1550/visual-editor) to manage your tailnet policy file. Refer to the [visual editor reference](https://tailscale.com/kb/1587/visual-editor-reference) for guidance on using the visual editor.

You can also reference groups of Tailscale Services using a tag you've assigned to each Service. This example grants access to a group of production Services with access to the Service `svc:database`.

```json
{
  "src":  ["tag:prod-service"],
  "dst":  ["svc:database"],
  "ip": ["5432"],
},
```

### [Check availability](#check-availability)

To check the availability of your Service, you can use the [Services](https://login.tailscale.com/admin/services) page of the admin console.

1.  Open the [Services](https://login.tailscale.com/admin/services) page of the Tailscale admin console.
2.  Within the **Advertised** section, you should find your Tailscale Service listed with configured endpoints.

## [Reference](#reference)

This section provides reference information about Tailscale Services, including endpoint types and service states.

### [Endpoint types](#endpoint-types)

Tailscale supports three types of endpoints, each operating at different layers of the networking stack. While the OSI model isn't a perfect representation of modern networking, it provides a useful framework for understanding these distinctions. There are three different types of endpoints: layer 7 (application), layer 4 (transport), and layer 3 (network). This section explains each type, when to use them, and notes about their specific capabilities

#### [Layer 7 endpoints (application layer)](#layer-7-endpoints-application-layer)

Layer 7 (application) endpoints provide the most sophisticated forwarding mechanism by understanding and manipulating application layer protocols. It can inspect, modify, and route traffic based on application-specific content. These types of endpoints work well when you need Tailscale to inject authentication headers in the packets or path-based routing. For example, `/api/*` requests might go to one server while `/static/*` goes to another.

You can create a layer 7 endpoint by setting the protocol value to `http` or `https` when using `tailscale serve`.

-   The port number is the port to expose the endpoint on.
-   You can use the optional `--set-path` flag to use a custom file path. By default, it uses `/`.
-   The destination can be text, a file path, or a local address. Refer to [Tailscale Serve examples](https://tailscale.com/kb/1313/serve-examples) for more examples.

#### [Layer 4 endpoints (transport layer)](#layer-4-endpoints-transport-layer)

Layer 4 (transport) endpoints operate at the transport (TCP) layer of the [OSI model](https://tailscale.com/kb/1456/osi). They act as TCP forwarders that don't modify packet data, but might not preserve packet boundaries and metadata. These types of endpoints work well for standard TCP services like web servers and databases. They have less overhead than layer 7 endpoints because they don't parse application layer protocols.

You can create a layer 4 endpoint by setting the protocol value to `tcp` or `tls-terminated-tcp` when using `tailscale serve`.

-   The port number is the port to expose a TCP forwarder on. The TCP forwarder forwards raw TLS-terminated brackets.
-   You cannot use the `--set-path` flag to use a custom file path. It must be empty or unset.
-   The destination is the local address where the raw TCP packets will be forwarded to (for example, `tcp://localhost:5432`).

#### [Layer 3 endpoints (network layer)](#layer-3-endpoints-network-layer)

Layer 3 (network) endpoints are a special type of endpoint that operates at the IP packet level and forwards all traffic, unmodified, to the operating system networking stack.

You might consider using a layer 3 endpoint if the application or resource you're serving requires UDP support or you need to preserve exact packet boundaries and sizes. However, keep in mind that they have the following limitations:

-   Require additional operating system configuration to handle the unmodified packets.
-   Don't have any built-in application layer features like authentication headers.
-   Only work on Linux.

You can create a layer 3 endpoint on a Linux device by running the `tailscale serve` command (with the service information) with the `--tun` flag.

```shell
tailscale serve --service=svc:<service-name> --tun
```

Using the `--tun` flag creates a layer 3 protocol-agnostic endpoint, which offers more control over the way packets flow to the resource. This type of endpoint forwards all traffic heading to the Tailscale Service to your local device without modifying it. In this mode, you would likely be doing some of your own `iptables` configuration or something like that to take full control of the packet and make it go to your desired destination.

### [Service states](#service-states)

This section covers the states of Services in the admin console. In the Services page of the admin console, a Service can be in the following states:

-   **Pending approval**: The Service has one or more hosts that have been advertised but are awaiting approval from an [Admin, Network admin, or Owner](https://tailscale.com/kb/1138/user-roles).
-   **Needs configuration**: The host has been defined but has an invalid or missing configuration.
-   **Connected**: At least one host is actively advertising the Service.
-   **Offline**: No hosts are currently advertising the Service.
-   **Pre-approved**: A device has been automatically approved based on an auto-approval policy but is not yet advertising the Service.
-   **Draining**: The host is in the process of draining, meaning it is no longer accepting new connections but is still handling existing ones.

## [Limitations](#limitations)

Tailscale Services has the following limitations while in beta:

-   **TCP-only protocol support**: Services currently only support TCP transport protocol, with UDP unavailable except through layer 3 endpoints on Linux that require additional operating system (OS) level configuration.
-   **No outgoing connections**: Virtual IP addresses (TailVIPs) assigned to Services can only accept incoming connections, preventing any outgoing connections from being initiated.
-   **No hairpinning**: Service host devices cannot access the Services they host.
-   **Linux-only layer 3 endpoints**: Layer 3 endpoints that preserve packet boundaries only work on Linux and require additional tool configuration, such as `iptables`.
-   **Text and file endpoints**: The Service configuration file method does not support `text:` or `file:` destinations. These are only available when using the `tailscale serve` CLI command.
-   **Limitations with multiple network interfaces**: Service Hosts that have multiple network interfaces and define remote resource destinations might experience issues in specific circumstances. For example, a connection to a remote destination might fail if:
    -   The Service Host (1) is a Linux device, (2) is running `tailscaled` without `SO_MARK`, (3) has multiple network interfaces, and (4) does not have the remote destination in its default route table. You can bypass this limitation by running `tailscaled` in [userspace-networking mode](https://tailscale.com/kb/1177/kernel-vs-userspace-routers#userspace-netstack-mode).
    -   The Service Host (1) is a macOS device using the [Mac App Store or Standalone variant](https://tailscale.com/kb/1065/macos-variants), (2) has multiple network interfaces, and (3) does not have the remote endpoint in its default route table. In this case, you can bypass the issue by running the [open source macOS variant](https://tailscale.com/kb/1065/macos-variants#open-source-tailscaled-variant) (which uses `tailscaled` in userspace-networking mode by default).
```



### File: 1554-messages.md

```markdown
# Tailscale messages

Informational and error messages can appear in the admin console, the Tailscale client UI, and the Tailscale client command-line interface (CLI). Understanding the context and purpose of these different message types can help you manage and troubleshoot issues related to your tailnet.

If the information in these topics doesn't resolve your issue and the message persists, contact [Tailscale Support](https://tailscale.com/contact/support).

## [Admin console messages](#admin-console-messages)

-   [Authentication failed while retrieving details from your SSO provider](https://tailscale.com/kb/1583/messages-console-auth-failed-sso)
-   [Failed to load sharing information](https://tailscale.com/kb/1576/messages-console-sharing-failure)
-   [Login name change detected](https://tailscale.com/kb/1569/messages-console-login-name-change)
-   [Multiple users with login](https://tailscale.com/kb/1573/messages-console-multi-user-login)
-   [No auth service](https://tailscale.com/kb/1584/no-auth-service)
-   [Reached use limit](https://tailscale.com/kb/1574/messages-reached-use-limit)
-   [You don't have access to the admin console](https://tailscale.com/kb/1577/messages-console-no-access)
-   [Your account is not an administrator](https://tailscale.com/kb/1575/messages-console-account-not-admin)
-   [Your organization has restricted members from joining external tailnets](https://tailscale.com/kb/1582/messages-console-org-has-restrictions)

## [Client messages](#client-messages)

-   [Coordination server reports an issue](https://tailscale.com/kb/1563/messages-client-control-health)
-   [Could not apply configuration](https://tailscale.com/kb/1568/messages-client-apply-disk-config)
-   [Docker with stateful filtering](https://tailscale.com/kb/1570/docker-stateful-filtering)
-   [Invalid packet filter](https://tailscale.com/kb/1567/messages-client-invalid-packet-filter)
-   [Linux DNS configuration issue](https://tailscale.com/kb/1571/messages-client-resolv-conf-overwritten)
-   [MagicSock function not running](https://tailscale.com/kb/1564/messages-client-magicsock-receive-func-error)
-   [Network down](https://tailscale.com/kb/1559/messages-client-network-down)
-   [No home relay server](https://tailscale.com/kb/1561/messages-client-messages-no-derp-home)
-   [Out of sync](https://tailscale.com/kb/1560/messages-client-not-in-map-poll)
-   [Relay server unavailable](https://tailscale.com/kb/1562/messages-client-no-derp-connections)
-   [Security update available](https://tailscale.com/kb/1557/messages-client-security-update-available)
-   [Tailscale blocked by Screen Time](https://tailscale.com/kb/1555/messages-client-macos-screen-time-controlclient)
-   [Update available](https://tailscale.com/kb/1556/messages-client-update-available)
-   [Using an unstable version](https://tailscale.com/kb/1558/messages-client-is-using-unstable-version)
```



### File: 1586-secure-github-runners.md

```markdown
# Connect GitHub CI/CD workflows to private infrastructure without public exposure

Continuous integration and continuous development (CI/CD) pipelines, such as [GitHub Actions](https://docs.github.com/en/actions) workflows, often need to access private infrastructure including databases, internal APIs, and Kubernetes clusters. Traditional approaches force you into security compromises around the choice to use public infrastructure (GitHub-hosted runners) or maintain your own infrastructure (self-hosted runners). Hosted runners offer flexibility and zero maintenance, but risk exposing internal services and creating vulnerabilities. [Self-hosted runners](https://docs.github.com/en/actions/concepts/runners/self-hosted-runners) increase security but remove the benefits of GitHub's managed infrastructure and add operational overhead.

You can have the low-maintenance of GitHub-hosted runners and the security of self-hosted runners (with no need to [create complicated setups](https://docs.github.com/en/actions/concepts/runners/private-networking)) by using Tailscale to secure runner access to your private infrastructure. The Tailscale GitHub action creates ephemeral, authenticated connections that expire shortly after workflow execution. Your private resources remain unexposed while GitHub's hosted runners connect securely through your Tailscale network (known as a tailnet).

In this guide, you'll implement secure CI/CD patterns using Tailscale's [OAuth clients](https://tailscale.com/kb/1215/oauth-clients), the [Tailscale GitHub Action](https://tailscale.com/kb/1276/tailscale-github-action), and the [`tsnet` library](https://tailscale.com/kb/1244/tsnet). You'll build a demonstration app called `tshello` that proves GitHub runners can access internal services and authenticate connecting users through Tailscale's identity layer. The patterns you establish extend directly to production scenarios, including database migrations, API testing, and Kubernetes deployments, without exposing services or managing persistent credentials.

## [Prerequisites](#prerequisites)

Before you begin this guide you'll need:

-   A [Tailscale account](https://tailscale.com/start) with [Owner, Admin, or Network admin](https://tailscale.com/kb/1138/user-roles) privileges.
-   A local device with Go 1.23 or later installed for creating and testing the demonstration app. The instructions in this guide assume the device is Unix-based (such as macOS or Linux).
-   A device running in your Tailscale network (known as a tailnet) to test connectivity with the [runner](https://docs.github.com/en/actions/concepts/runners).
-   A GitHub repository for which you have [collaborator permissions](https://docs.github.com/en/account-and-profile/reference/permission-levels-for-a-personal-account-repositor).
-   Basic familiarity with [GitHub Actions workflow syntax](https://docs.github.com/en/actions/reference/workflows-and-actions/workflow-syntax), [Tailscale tags](https://tailscale.com/kb/1068/tags), [Go syntax](https://go.dev/ref/spec), and [Go tests](https://go.dev/doc/tutorial/add-a-test).

## [Step 1: Create identity and access controls for workflow runners](#step-1-create-identity-and-access-controls-for-workflow-runners)

Start by creating an identity for the workflow runners. You'll use this identity to authenticate the [ephemeral nodes](https://tailscale.com/kb/1111/ephemeral-nodes) that the runners use and apply [access controls](https://tailscale.com/kb/1393/access-control) that restrict what resources the runners can access.

Do this by editing your [tailnet policy file](https://tailscale.com/kb/1395/tailnet-policy-file) to define ownership of the `tag:ci` tag through the `tagOwners` section and create access rules using the `grants` section.

The tag ownership section defines the tag and which users can apply it to devices while the grants determine what resources tagged devices can access.

Open the [Access controls](https://login.tailscale.com/admin/acls) page of the admin console. If you haven't customized your policy file before, it exhibits the default configuration. You'll add new sections while preserving any existing rules. You can edit the tailnet policy file using the JSON editor or the visual editor.

### [Option 1: Use the JSON editor](#option-1-use-the-json-editor)

To use the JSON editor, select **JSON editor** at the top of the [Access controls](https://login.tailscale.com/admin/acls) page.

First, define the tag owner for the CI runners. Locate the `tagOwners` section or create it if it doesn't exist. Add the `ci` tag with an empty owner. By default, [Owners, Admins, and Network admins](https://tailscale.com/kb/1138/user-roles) can apply tags without explicit ownership.

```json
"tagOwners": {
  "tag:ci": [], // No owners, so Owners, Admins, and Network admins can apply the tag
  // Other tag definitions
}
```

[Owners, Admins, and Network admins](https://tailscale.com/kb/1138/user-roles) can manually tag devices with `tag:ci` if needed.

Next, create access rules for the CI runners. In the `grants` section, add rules that define what your GitHub runners can access. Start with a basic rule that lets CI runners to communicate with all devices in your tailnet:

```json
"grants": [
  {
    "src": ["tag:ci"],
    "dst": ["*"],
    "ip": ["*"]
  },
  // Other access rules
]
```

This grant lets devices using the `tag:ci` identity access any other devices. This is a lenient policy for demonstration only. Do not use this access control policy in production environments.

For production environments, you should restrict access further. Here's an example that limits CI runners to specific resources:

```json
"grants": [
  {
    "src": ["tag:ci"],
    "dst": ["tag:prod-db"],
    "ip": ["5432"]
  },
  {
    "src": ["tag:ci"],
    "dst": ["tag:staging-api"],
    "ip": ["443", "8080"]
  },
  // Other access rules
]
```

These example grants let CI runners access PostgreSQL databases tagged with `tag:prod-db` on port `5432` and staging APIs tagged with `tag:staging-api` on ports `443` and `8080`. Adjust these rules based on your infrastructure and security requirements.

Save your policy file changes. The admin console validates the syntax and applies the new rules immediately.

### [Option 2: Use the visual editor](#option-2-use-the-visual-editor)

To use the visual editor, select **Visual editor** at the top of the [Access controls](https://login.tailscale.com/admin/acls) page.

Select the **Tags** tab, then **Create tag**.

Set the tag name to `ci` and add a note explaining what the tag is for (CI/CD runners). You don't need specify any owners here; leave the owner list empty. By default, [Owners, Admins, and Network admins](https://tailscale.com/kb/1138/user-roles) can apply tags without explicit ownership.

Then, select **Save tag**.

Next, create access rules for your CI runners.

Select the **General access rules** tab, then **Add rule**.

Set the source to `tag:ci`, the destination to **All users and devices**, and the port and protocol to **All ports and protocols**. Optionally, add a note to explain what the access rule is for. Then, select **Save grant**.

This grant lets devices using the `tag:ci` identity access any other devices.

This is a lenient policy for demonstration only. Do not use this access control policy in production environments.

You've set up the appropriate permissions for your tailnet. Next you'll use the `ci` tag you created to configure a Tailscale OAuth client to create on-demand authentication for your workflow.

## [Step 2: Create an OAuth client for ephemeral access](#step-2-create-an-oauth-client-for-ephemeral-access)

Before creating the GitHub Action workflow, you need to configure a [Tailscale OAuth client](https://tailscale.com/kb/1215/oauth-clients) that generates ephemeral auth keys on demand. These auth keys let the GitHub runners join your tailnet as [ephemeral nodes](https://tailscale.com/kb/1111/ephemeral-nodes) tagged with `tag:ci`. Each workflow run gets a unique auth key that expires shortly after job completion. This approach eliminates the need to manage long-lived credentials or manually clean up unused devices.

Go to the [Trust credentials](https://login.tailscale.com/admin/settings/trust-credentials) page of the admin console. Select **Create OAuth client** and configure it with the following settings.

For the description field, enter a meaningful name like "GitHub Actions CI/CD". This helps identify the client's purpose when reviewing access logs or managing multiple OAuth clients.

Under **OAuth client scopes**, select the checkbox for **Devices** with **Write** permissions. This scope lets the OAuth client create **auth keys** that can register new devices (your GitHub runners) to your tailnet. The write permission is essential for the runners to join the tailnet.

The **Devices** scope with write permissions can create auth keys that add devices to your tailnet. Protect the OAuth client ID and client secret as you would any other sensitive credential. Store them only in GitHub's encrypted secrets (and a password manager), never in your repository code.

In the tags field, add the `tag:ci` tag you created earlier. [Tags](https://tailscale.com/kb/1068/tags) identify non-human devices in your tailnet and enable you to create specific access policies for CI/CD runners. You'll define ownership of this tag in your tailnet policy file in the next step.

Select **Create OAuth client**. The admin console displays your OAuth client ID and client secret. Copy both values immediately because you can't access the secret again. If you lose the secret, you'll need to generate a new one from the OAuth client's settings page.

Now, store these credentials as [secrets in your GitHub repository](https://docs.github.com/en/actions). Go to your repository on GitHub and go to **Settings** > **Secrets and variables** > **Actions**. Create two new repository secrets. Name the first secret `TS_OAUTH_CLIENT_ID` and paste your OAuth client ID. Name the second secret `TS_OAUTH_SECRET` and paste your OAuth client secret.

Your OAuth client is now ready to authenticate GitHub Actions workflows. Each workflow run will use these credentials to generate a unique, single-use auth key.

Next, you'll create an auth key that the Go test will use to verify connectivity.

## [Step 3: Create an auth key for the Go test](#step-3-create-an-auth-key-for-the-go-test)

For the Tailscale connectivity test (that you'll create in a later step) to work, you must create a reusable [auth key](https://tailscale.com/kb/1085/auth-keys) and use it to define the `TS_AUTHKEY` environment variable locally and in the GitHub repository secrets. The connectivity test part of the Go test you will create in a later step will use this auth key.

1.  Open the [Keys](https://login.tailscale.com/admin/settings/keys) page of the admin console.
2.  Select Generate auth key.
3.  Give the auth key a description to help you remember what it's for.
4.  Enable **Reusable**.
5.  Keep the expiration at 90 days.
6.  Enable **Ephemeral**.
7.  Enable **Tags**, then add the `tag:ci` tag you created earlier.
8.  Select **Generate key**.

Save the auth key to a safe location where you can retrieve it later. You won't be able to access it again, and you'll need it to run the Go test you'll create later.

Next, add the auth key as a [secret in your GitHub repository](https://docs.github.com/en/actions). Go to your repository on GitHub and go to **Settings** > **Secrets and variables** > **Actions**. Create a new repository secret and name the secret `TS_AUTHKEY` and paste your auth key.

You've created an auth key for the Go test. Next, you'll create a basic `tsnet` app that the test will verify.

You've created your auth keys. Now you'll build a demo app you'll use to test your workflow.

## [Step 4: Create a basic `tsnet` app](#step-4-create-a-basic-tsnet-app)

For demonstration purposes, let's create a basic "Hello, world!" Go application that uses `tsnet`. The [`tsnet` library](https://tailscale.com/kb/1244/tsnet) lets you embed Tailscale functionality inside a Go program. For more detailed steps, refer to the instructions in [Hello `tsnet`](https://tailscale.com/kb/1521/hello-tsnet#create-a-tsnet-hello-world-program).

Create a new directory for the `tshello` app:

```shell
mkdir tshello
cd tshello
```

Start the Go module:

```shell
go mod init tshello
go get tailscale.com/tsnet
```

Create a file named `tshello.go`. This code is from the [Hello `tsnet`](https://tailscale.com/kb/1521/hello-tsnet#create-a-tsnet-hello-world-program) guide. Visit that guide for a detailed explanation of how the code works.

Start with the package declaration and import statements. The imports include standard Go libraries for networking, HTTP operations, and TLS, along with the Tailscale `tsnet` package.

```go
// This program demonstrates how to use tsnet as a library.
package main

import (
    "crypto/tls"
    "flag"
    "fmt"
    "html"
    "log"
    "net/http"
    "strings"

    "tailscale.com/tsnet"
)
```

Define a command-line flag for the server address. This lets you specify which port the server listens on, defaulting to port `80`.

```go
var (
   addr = flag.String("addr", ":80", "address to listen on")
)
```

The main function parses command-line flags and initializes the `tsnet` server. The server creates a TCP listener and obtains a local client for interacting with the Tailscale network.

```go
func main() {
    flag.Parse()
    srv := new(tsnet.Server)
    defer srv.Close()
    ln, err := srv.Listen("tcp", *addr)
    if err != nil {
       log.Fatal(err)
    }
    defer ln.Close()

    lc, err := srv.LocalClient()
    if err != nil {
     log.Fatal(err)
    }
```

When the server listens on port `443`, wrap the listener with TLS using Tailscale's automatic certificate provisioning. This provides HTTPS without manual certificate management.

```go
    if *addr == ":443" {
       ln = tls.NewListener(ln, &tls.Config{
          GetCertificate: lc.GetCertificate,
     })
    }
```

The HTTP handler uses the `WhoIs` API to identify connecting clients through Tailscale's authentication. This demonstrates how the app can verify user identity without implementing separate authentication logic.

```go
    log.Fatal(http.Serve(ln, http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        who, err := lc.WhoIs(r.Context(), r.RemoteAddr)
            if err != nil {
                http.Error(w, err.Error(), 500)
            return
        }
        fmt.Fprintf(w, "<html><body><h1>Hello, world!</h1>\n")
        fmt.Fprintf(w, "<p>You are <b>%s</b> from <b>%s</b> (%s)</p>",
            html.EscapeString(who.UserProfile.LoginName),
            html.EscapeString(firstLabel(who.Node.ComputedName)),
            r.RemoteAddr)
     })))
}
```

Add a helper function that extracts the first label from a domain name. This utility function helps format the device name in the HTTP response.

```go
func firstLabel(s string) string {
    s, _, _ = strings.Cut(s, ".")
    return s
}
```

This application creates a `tsnet` server that joins your tailnet with the hostname "`tshello`". The HTTP handler identifies connecting users through [Tailscale's `WhoIs` API](https://pkg.go.dev/tailscale.com@v1.88.1/client/local#Client.WhoIs), demonstrating that the app can authenticate connections through your tailnet's identity layer.

Install the required dependencies:

```shell
go mod tidy
```

The `go mod tidy` command downloads the `tsnet` library and its dependencies. Your `go.mod` file now includes the exact versions of all required packages.

Test the app locally to make sure it compiles and runs:

```shell
go build -o tshello
./tshello -addr tshello
```

The app starts and attempts to join your tailnet. If you're not already authenticated with Tailscale on your local device, it prompts you to authenticate. Follow the instructions to authenticate.

After you connect, the app displays its [Tailscale IP address](https://tailscale.com/kb/1015/100.x-addresses). You can access it from any device on your tailnet using the hostname you specified or the tailnet IP address.

Stop the local test with `CTRL+C`. Your demonstration app is ready for automated testing in GitHub Actions.

Before continuing, initialize Git and link the local repository to your GitHub repository:

```shell
git init
git remote add origin https://github.com/<username>/<repository-name>.git
git commit -m "Init tshello app"
git push -u origin main
```

You manually verified the program, but now you'll create a test that ensures it works. You'll eventually run this test within your GitHub action.

You have a basic `tsnet` app that joins your tailnet. Next, you'll create a Go test that verifies the app can communicate over Tailscale.

You can access the complete code for the guide in the [tailscale-dev/secure-github-runners](https://github.com/tailscale-dev/secure-github-runners) repository on GitHub.

## [Step 5: Create a Go test](#step-5-create-a-go-test)

Next, you'll add a [Go test](https://go.dev/doc/tutorial/add-a-test) file with tests that verify your GitHub Actions runner can successfully communicate over the Tailscale network. These tests ensure the `tshello` app functions correctly and can identify connecting clients through Tailscale's authentication.

For this test to work, you need to have created an [auth key](https://tailscale.com/kb/1085/auth-keys) and used it to define the `TS_AUTHKEY` environment variable locally and in the GitHub repository secrets. If you skipped creating an auth key, the test will still run, but it will skip the Tailscale connectivity test.

Create a `.env` file and add the following to it (replacing the placeholder with your auth key):

```markup
TS_AUTHKEY=<your-ts-auth-key>
```

Create a Go test file named `tshello_test.go`. The test file includes integration tests that verify Tailscale network connectivity and unit tests that validate code behavior without network access. The integration tests verify server initialization, HTTP client connectivity over the tailnet, and DNS resolution across peers.

Start by declaring the package and importing the necessary dependencies. The imports include standard Go libraries for testing, networking, and HTTP operations, along with the Tailscale `tsnet` package for creating ephemeral Tailscale nodes.

```go
package main

import (
 "context"
 "fmt"
 "io"
 "net"
 "net/http"
 "os"
 "strings"
 "testing"
 "time"

 "tailscale.com/tsnet"
)
```

The `tsnet` package provides the core functionality for creating temporary Tailscale devices (ephemeral nodes) that join your tailnet during test execution. The standard library packages handle HTTP operations, context management, and network operations.

The first test function verifies the `tshello` server can initialize correctly, create a listener, and shut down gracefully. This test creates a temporary `tsnet` server, starts an HTTP server, and validates the startup process.

```go
func TestTshelloServer(t *testing.T) {
 if testing.Short() {
  t.Skip("skipping test in short mode")
 }

 ctx, cancel := context.WithTimeout(context.Background(), 2*time.Minute)
 defer cancel()

 srv := &tsnet.Server{
  Hostname: "tshello-test",
  Dir:      t.TempDir(),
 }
 defer srv.Close()

 ln, err := srv.Listen("tcp", ":0")
 if err != nil {
  t.Fatalf("failed to listen: %v", err)
 }
 defer ln.Close()

 lc, err := srv.LocalClient()
 if err != nil {
  t.Fatalf("failed to get local client: %v", err)
 }

 serverURL := fmt.Sprintf("http://%s", ln.Addr().String())
 t.Logf("Test server listening on %s", serverURL)

 httpServer := &http.Server{
  Handler: http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
   who, err := lc.WhoIs(r.Context(), r.RemoteAddr)
   if err != nil {
    http.Error(w, err.Error(), 500)
    return
   }
   fmt.Fprintf(w, "Hello, %s!", who.UserProfile.LoginName)
  }),
 }

 errCh := make(chan error, 1)
 go func() {
  errCh <- httpServer.Serve(ln)
 }()

 select {
 case <-ctx.Done():
  t.Fatal("test timed out waiting for server to start")
 case err := <-errCh:
  if err != nil && err != http.ErrServerClosed {
   t.Fatalf("server error: %v", err)
  }
 case <-time.After(5 * time.Second):
  t.Log("Server started successfully")
 }

 if err := httpServer.Shutdown(ctx); err != nil {
  t.Logf("server shutdown error: %v", err)
 }
}
```

This test uses a temporary directory for the `tsnet` server state and verifies that the HTTP handler can identify connecting clients using Tailscale's authentication information. The test passes if the server starts successfully and shuts down cleanly within the timeout period.

The next test function creates a `tsnet` client and attempts to connect to running `tshello` instances over the tailnet. This integration test requires a valid auth key and attempts to reach both test and production servers.

```go
func TestTshelloHTTPClient(t *testing.T) {
 if testing.Short() {
  t.Skip("skipping test in short mode")
 }

 authKey := os.Getenv("TS_AUTHKEY")
 if authKey == "" {
  t.Skip("TS_AUTHKEY not set, skipping Tailscale connectivity test")
 }

 ctx, cancel := context.WithTimeout(context.Background(), 2*time.Minute)
 defer cancel()

 srv := &tsnet.Server{
  Hostname: "tshello-client-test",
  Dir:      t.TempDir(),
  AuthKey:  authKey,
 }
 defer srv.Close()

 if err := srv.Start(); err != nil {
  t.Fatalf("failed to start tsnet: %v", err)
 }

 httpClient := srv.HTTPClient()

 targets := []string{
  "tshello-test",
  "tshello",
 }

 for _, target := range targets {
  t.Run(fmt.Sprintf("ping_%s", target), func(t *testing.T) {
   url := fmt.Sprintf("http://%s/", target)

   req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
   if err != nil {
    t.Skipf("failed to create request for %s: %v", target, err)
    return
   }

   resp, err := httpClient.Do(req)
   if err != nil {
    if strings.Contains(err.Error(), "no such host") ||
       strings.Contains(err.Error(), "connection refused") ||
       strings.Contains(err.Error(), "timeout") {
     t.Skipf("target %s not available: %v", target, err)
     return
    }
    t.Errorf("failed to connect to %s: %v", target, err)
    return
   }
   defer resp.Body.Close()

   body, err := io.ReadAll(resp.Body)
   if err != nil {
    t.Errorf("failed to read response from %s: %v", target, err)
    return
   }

   t.Logf("Response from %s (status %d): %s", target, resp.StatusCode, string(body))

   if resp.StatusCode != http.StatusOK {
    t.Errorf("unexpected status code from %s: %d", target, resp.StatusCode)
   }
  })
 }
}
```

The test creates sub tests for each target hostname and gracefully skips targets that aren't available. When running locally without other devices in the tailnet, the test skips unavailable targets. In the GitHub Actions environment, the test connects to the runner's `tshello` instance.

Add another test function that verifies DNS lookups work correctly for peers in your tailnet. This test retrieves the list of peers from the Tailscale status and attempts to resolve each peer's hostname.

```go
func TestTshelloDNSResolution(t *testing.T) {
 if testing.Short() {
  t.Skip("skipping test in short mode")
 }

 authKey := os.Getenv("TS_AUTHKEY")
 if authKey == "" {
  t.Skip("TS_AUTHKEY not set, skipping DNS test")
 }

 ctx, cancel := context.WithTimeout(context.Background(), 1*time.Minute)
 defer cancel()

 srv := &tsnet.Server{
  Hostname: "tshello-dns-test",
  Dir:      t.TempDir(),
  AuthKey:  authKey,
 }
 defer srv.Close()

 if err := srv.Start(); err != nil {
  t.Fatalf("failed to start tsnet: %v", err)
 }

 lc, err := srv.LocalClient()
 if err != nil {
  t.Fatalf("failed to get local client: %v", err)
 }

 status, err := lc.Status(ctx)
 if err != nil {
  t.Fatalf("failed to get status: %v", err)
 }

 t.Logf("Current node: %s", status.Self.HostName)
 t.Logf("Tailnet name: %s", status.CurrentTailnet.Name)
 t.Logf("Number of peers: %d", len(status.Peer))

 for _, peer := range status.Peer {
  t.Logf("Peer: %s (%s)", peer.HostName, peer.TailscaleIPs[0])

  ips, err := net.LookupIP(peer.HostName)
  if err != nil {
   t.Logf("Failed to resolve %s: %v", peer.HostName, err)
   continue
  }

  for _, ip := range ips {
   t.Logf("  Resolved IP: %s", ip)
  }
 }
}
```

The test logs information about the current device, the tailnet name, and each device in the tailnet. It attempts DNS resolution for each tailnet device and logs the results, helping you verify that MagicDNS is working correctly in your test environment.

Finally, add a unit test for the `firstLabel` utility function that extracts the first label from a domain name. This test validates the function works correctly with various input formats.

```go
func TestFirstLabel(t *testing.T) {
 tests := []struct {
  input    string
  expected string
 }{
  {"example.com", "example"},
  {"sub.example.com", "sub"},
  {"localhost", "localhost"},
  {"", ""},
  {"single", "single"},
 }

 for _, tt := range tests {
  t.Run(tt.input, func(t *testing.T) {
   result := firstLabel(tt.input)
   if result != tt.expected {
    t.Errorf("firstLabel(%q) = %q, want %q", tt.input, result, tt.expected)
   }
  })
 }
}
```

This table-driven test creates sub tests for each input case and verifies the function produces the expected output. The unit test runs without requiring network access or authentication.

Load the auth key from the `.env` file:

```shell
export $(cat .env | xargs)
```

Run the tests locally to verify they work:

```shell
go test -v
```

The unit test passes. The integration test doesn't run unless you have a `tshello` instance running in your tailnet. This behavior is intentional because the integration test will run successfully in your GitHub Actions workflow when the runner joins your tailnet.

Commit and push your changes to you GitHub repository:

```shell
git add .
git commit -m "Add tshello test"
git push -u origin main
```

You now have a unit test and integration test. You're ready to run them on GitHub as part of an action.

You can access the complete code for the guide in the [tailscale-dev/secure-github-runners](https://github.com/tailscale-dev/secure-github-runners) repository on GitHub.

## [Step 6: Create the GitHub Actions workflow](#step-6-create-the-github-actions-workflow)

Next, you'll create a [GitHub Actions workflow](https://docs.github.com/en/actions) that uses the [Tailscale GitHub Action](https://tailscale.com/kb/1276/tailscale-github-action) to connect your runner to your tailnet, build the `tshello` app, and verify connectivity. This workflow demonstrates the complete pattern for accessing private resources from continuous integration continuous development (CI/CD) pipelines.

Create the GitHub Actions workflow directory structure in your repository:

```shell
mkdir -p .github/workflows
```

Create a YAML workflow file named `.github/workflows/<name>.yml`:

```shell
touch .github/workflows/<name>.yml
```

Start by defining the workflow name and triggers. This configuration runs the workflow on pushes to the main branch, pull requests, and manual triggers through the GitHub Actions interface.

```yaml
name: Test tshello with Tailscale

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]
  workflow_dispatch:
```

Define the job and specify the runner. The workflow uses an Ubuntu runner provided by GitHub Actions.

```yaml
jobs:
  test:
    runs-on: ubuntu-latest
    steps:
```

The first step checks out your repository code, making it available to subsequent steps in the workflow.

```yaml
    - name: Checkout code
      uses: actions/checkout@v4
```

The next step sets up Go with the specified version. This ensures the runner has the correct Go toolchain for building and testing your application.

```yaml
    - name: Set up Go
      uses: actions/setup-go@v5
      with:
        go-version: '1.23'
```

The [Tailscale GitHub Action](https://tailscale.com/kb/1276/tailscale-github-action) connects the runner to your tailnet. This step uses your OAuth credentials to authenticate and joins the runner as an [ephemeral node](https://tailscale.com/kb/1111/ephemeral-nodes) tagged with `tag:ci`. The runner receives a Tailscale IP address and can resolve other devices through [MagicDNS](https://tailscale.com/kb/1081/magicdns).

```yaml
    - name: Connect to Tailscale
      uses: tailscale/github-action@v4
      with:
        oauth-client-id: ${{ secrets.TS_OAUTH_CLIENT_ID }}
        oauth-secret: ${{ secrets.TS_OAUTH_SECRET }}
        tags: tag:ci
        version: latest
```

After connecting to Tailscale, build the `tshello` application. The build process downloads dependencies and compiles the code.

```yaml
    - name: Build tshello
      run: |
        cd tshello
        go mod download
        go build -v ./...
```

Run the test suite with a timeout to prevent the tests from hanging if it encounters an issue. The tests verify that the application functions correctly and can communicate over the Tailscale network.

```yaml
    - name: Run tests
      run: |
        cd tshello
        go test -v -timeout 30s ./...
```

Verify the runner's Tailscale connection by checking its status and IP address. This step demonstrates that the runner successfully joined your tailnet and received a valid Tailscale IP address.

```yaml
    - name: Test connectivity
      run: |
        # Test that we can reach the Tailscale network
        tailscale status

        # Show our IP address
        tailscale ip -4
```

This workflow shows how the runner joins your tailnet as an ephemeral node with the `tag:ci` tag. The `tshello` app runs on the same runner, creating its own `tsnet` node that other devices on your tailnet can access.

Commit and push your workflow to GitHub:

```shell
git add .
git commit -m "Add GitHub workflow"
git push origin main
```

In a web browser, go to the **Actions** tab in your GitHub repository to ensure the workflow is running. Select it to [monitor](https://docs.github.com/en/actions) the real-time logs as the runner connects to your tailnet, builds the `tshello` app, and runs the tests.

Your GitHub Actions workflow is now running with a secure connection to your tailnet. You can verify this connection and observe how ephemeral nodes behave in your infrastructure.

While your workflow runs, open the [Machines](https://login.tailscale.com/admin/machines) page of the admin console and check to ensure a device with a name like `github-actions-runner` tagged with `tag:ci` exits. This is your ephemeral GitHub runner. The device shows as connected for the duration of the workflow, then automatically disappears when the job completes.

You can also review the workflow logs in GitHub Actions. The "Verify Tailscale connection" step shows the runner's Tailscale IP address and status. This IP address is from the `100.64.0.0/10` [CGNAT](https://tailscale.com/kb/1015/100.x-addresses) range that Tailscale uses. Any device on your tailnet can reach this runner using this IP address during the workflow execution.

The "Test connectivity to `tshello`" step demonstrates that the `tsnet`\-based app successfully joined your tailnet. The app receives its own Tailscale identity and can authenticate connecting clients. In a production scenario, this same pattern lets your services identify which CI runner or user is making requests.

Check the [Logs](https://login.tailscale.com/admin/logs) page of the admin console. Here, you can access audit entries for the OAuth client creating an auth key and the ephemeral node joining and leaving your tailnet. These logs provide a complete audit trail of all CI/CD access to your infrastructure.

The ephemeral nature of these connections provides security benefit because ephemeral nodes exist only during job execution, reducing the attack surface. Each job gets fresh credentials that can't be reused. There's no accumulation of stale devices in your tailnet because unused ephemeral nodes are automatically cleaned up. The automatic cleanup eliminates manual maintenance.

You've successfully created a secure GitHub Actions workflow that connects to your private infrastructure without exposing services to the internet. Next, you'll explore how to extend this pattern to production scenarios.

You can access the complete code for the guide in the [tailscale-dev/secure-github-runners](https://github.com/tailscale-dev/secure-github-runners) repository on GitHub.

## [Step 7: Extend, monitor, and optimize for production use cases](#step-7-extend-monitor-and-optimize-for-production-use-cases)

The `tshello` demonstration illustrates core capabilities that extend directly to production use cases. Your GitHub Actions workflows can now access any private resource on your tailnet using the same pattern.

For database migrations, your workflow can connect directly to PostgreSQL, MySQL, or MongoDB instances running on your tailnet. Replace the `tshello` test with actual migration commands:

```yaml
- name: Run database migrations
  run: |
    export DATABASE_URL="postgresql://user:pass@prod-db.tail-scale.ts.net:5432/my-app"
    npm run migrate:latest
    npm run migrate:status
```

The database remains completely private with no internet-facing ports. The connection is encrypted and authenticated through Tailscale and your audit logs show exactly which workflow accessed the database and when.

For API testing, your integration tests can hit internal services that aren't exposed to the internet:

```yaml
- name: Run API integration tests
  run: |
    export API_BASE_URL="https://staging-api.tail-scale.ts.net"
    npm test:integration
```

Your staging environment stays private while still being accessible for automated testing. The tests run with the same network access they'd have in production.

For Kubernetes deployments, you can use `kubectl` commands:

```yaml
- name: Deploy to Kubernetes
  run: |
    kubectl config set-cluster production --server=https://k8s-api.tail-scale.ts.net:6443
    kubectl apply -f ./k8s/production/
    kubectl rollout status deployment/my-app -n production
```

Your Kubernetes API server needs no public endpoint. The connection goes through your secure tailnet with full audit logging.

For pulling from private registries, Docker commands work without exposing your registry:

```yaml
- name: Build and push container
  run: |
    docker build -t registry.tail-scale.ts.net/my-app:${{ github.sha }} .
    docker push registry.tail-scale.ts.net/my-app:${{ github.sha }}
```

Each of these scenarios follows the same pattern. Your workflow joins the tailnet, performs its operations with full access to private resources, then automatically disconnects. No manual cleanup, no lingering access, no exposed services.

Monitoring ephemeral nodes and optimizing workflow performance ensures your CI/CD pipelines run efficiently and securely. The Tailscale admin console provides visibility into all ephemeral connections, while strategic optimization reduces workflow execution time.

Monitor ephemeral nodes through the [Machines](https://login.tailscale.com/admin/machines) page during workflow execution. Each runner appears with its ephemeral status indicator and `tag:ci` label. The connection duration shows how long the workflow has been running. After job completion, these ephemeral nodes disappear automatically, keeping your machine list clean.

Review the authentication patterns in the [Logs](https://login.tailscale.com/admin/logs) page. Each workflow run generates log entries for auth key creation, node registration, and disconnection. Filter logs by the tag `tag:ci` to review all CI/CD activity. These logs help you understand usage patterns and troubleshoot connection issues.

Optimize workflow performance by [caching the Tailscale binary](https://tailscale.com/kb/1276/tailscale-github-action#cache-tailscale-binaries). The GitHub Action handles this automatically, but you can tune the behavior:

```yaml
- name: Connect to Tailscale
  uses: tailscale/github-action@v4
  with:
    oauth-client-id: ${{ secrets.TS_OAUTH_CLIENT_ID }}
    oauth-secret: ${{ secrets.TS_OAUTH_SECRET }}
    tags: tag:ci
    version: '1.76.1'  # Pin version for consistency
    use-cache: 'true' # Enable caching
```

Pinning the Tailscale version ensures consistent behavior across workflow runs and maximizes cache hits, reducing download time.

For workflows that run multiple jobs needing Tailscale access, consider using [matrix strategies](https://docs.github.com/en/actions):

```yaml
strategy:
  matrix:
    service: [database, api, frontend]
jobs:
  test:
    runs-on: ubuntu-latest
    steps:
    - name: Connect to Tailscale
      uses: tailscale/github-action@v4
      with:
        oauth-client-id: ${{ secrets.TS_OAUTH_CLIENT_ID }}
        oauth-secret: ${{ secrets.TS_OAUTH_SECRET }}
        tags: tag:ci

    - name: Test ${{ matrix.service }}
      run: |
        ./test-${{ matrix.service }}.sh
```

Each matrix job gets its own ephemeral connection, allowing parallel testing against your private infrastructure.

## [Conclusion](#conclusion)

Your GitHub Actions workflows now securely access private infrastructure through temporary, authenticated Tailscale connections that exist only during job execution. You've eliminated public exposure of internal services while maintaining the simplicity of GitHub's hosted runners and removing the operational overhead of self-hosted infrastructure.

The `tshello` demonstration, while basic, proves powerful capabilities that extend to production scenarios. Database migrations execute from GitHub Actions without exposing database ports. API integration tests run against internal staging environments. Deployment scripts access on-premise resources securely. Multi-cloud architectures where GitHub Actions orchestrate resources across providers work seamlessly.

The pattern of ephemeral, tagged access provides a security model that scales with your infrastructure complexity. Each connection is authenticated, authorized, and audited. The automatic cleanup ensures no lingering access. Your security team gains complete visibility through audit logs while your development team maintains deployment velocity.

This foundation enables advanced patterns like [blue-green deployments](https://en.wikipedia.org/wiki/Blue%E2%80%93green_deployment) to private Kubernetes clusters, automated security scanning of internal services, performance testing against production-like environments, and compliance workflows that access regulated systems. Each use case follows the same secure pattern you've implemented here.
```



### File: 1598-apple-tv-route-traffic.md

```markdown
# Secure your internet traffic on public Wi-Fi using an Apple TV

When you connect to public Wi-Fi in places like hotels, airports, or cafés, your internet activity gets exposed to others on the same public network. This exposure can put your privacy at risk when you check email, log in to bank accounts, use cloud services, or engage in any other activity involving your personal information.

By routing your internet traffic through your Apple TV, you protect that activity. Your device creates a secure, encrypted connection to your Apple TV, which then sends your traffic to the internet using your home network. This process keeps your browsing private, even while you use unfamiliar or unsecured networks. We also refer to this type of traffic routing as an [exit node](https://tailscale.com/kb/1103/exit-nodes).

In addition to improving privacy, routing traffic through your Apple TV can help with location-based access. Some websites and streaming platforms only allow connections from your home country or region. By sending traffic through the Apple TV, those services identify it as coming from your home network, which can allow access to region-locked content.

The benefits of routing your Tailscale network (known as a tailnet) traffic using an Apple TV include:

-   Use a device you may already own. No need for extra hardware or network configuration.
-   Apple TVs are typically always on and connected to your home internet, making them a reliable option for routing traffic when you're away.
-   Tailscale is free with the Personal plan that supports up to 3 users and 100 devices.
-   The Tailscale app for Apple TV is free and available in the Apple App Store.

## [Prerequisites](#prerequisites)

To follow this guide, you need:

-   A device such as a phone or laptop to log in and create the tailnet. Tailscale runs on most operating systems, including Linux, Windows, macOS, iOS, and Android.
-   An email account that uses a [single sign-on (SSO) identity provider](https://tailscale.com/kb/1013/sso-providers), such as Apple, Google, or Microsoft.
-   An Apple TV HD or Apple TV 4K running tvOS version 17 or later.

## [Step 1: Create your tailnet](#step-1-create-your-tailnet)

To create your own tailnet, [download](https://tailscale.com/download) and install the client on a device such as a phone or laptop, and log in using your existing identity provider. Choose the **Personal** option and follow the remaining instructions to complete the process. Your personal tailnet is now configured and ready to use.

![Choosing use case for tailnet creation.](/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fwelcome-page.f3b91c91.png&w=1080&q=75)

Now go to the [Machines](https://login.tailscale.com/admin/machines) page of the admin console, confirming it's connected to your tailnet. The admin console is where you can manage the users, devices, and permissions for your tailnet.

![Choosing use case for tailnet creation.](/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fmachines-page.4278f047.png&w=1080&q=75)

Next you'll configure Tailscale on your Apple TV.

## [Step 2: Install and configure Tailscale on your Apple TV to route traffic](#step-2-install-and-configure-tailscale-on-your-apple-tv-to-route-traffic)

To install Tailscale on your Apple TV, open the App Store, search for the Tailscale app, and download it. Once installed, open the app, follow the prompts, and grant any requested permissions.

Launch the app and select **Connect** to add the Apple TV to your tailnet. A QR code will appear on screen. You can scan it with your phone or enter the provided URL into a browser on another device. This step signs you in and authorizes the Apple TV to join your tailnet. To confirm the connection, go to the [Machines](https://login.tailscale.com/admin/machines) page of the admin console and look for the Apple TV in the device list.

Now open the Tailscale app on the Apple TV and go to the **Exit Node** section. Select **Run as Exit Node**. Then, in the [Machines](https://login.tailscale.com/admin/machines) page of the admin console, find the Apple TV in the list, select the ![ellipsis icon](/files/images/icons/fa-ellipsis-h.svg) button, choose **Edit route settings**, and toggle **Use as exit node** to enable it. Other devices in your tailnet can now route their traffic through your Apple TV.

Devices in a tailnet are occasionally required to re-authenticate to keep your network secure. To avoid DNS interruptions, go to the [Machines](https://login.tailscale.com/admin/machines) page of the admin console, select the ![ellipsis icon](/files/images/icons/fa-ellipsis-h.svg) button next to the Raspberry Pi, then select **Disable key expiry**.

Next you'll configure devices to use the Apple TV to route traffic.

## [Step 3: Configure devices to use Apple TV for traffic routing](#step-3-configure-devices-to-use-apple-tv-for-traffic-routing)

To configure a device to route its traffic through your Apple TV, open the Tailscale app on a device, go to the **Exit Nodes** section, and select the Apple TV. The instructions for enabling an exit node vary depending on the device's operating system.

[Android](https://tailscale.com/kb/1598/apple-tv-route-traffic?tab=android)[iOS](https://tailscale.com/kb/1598/apple-tv-route-traffic?tab=ios)[Linux](https://tailscale.com/kb/1598/apple-tv-route-traffic?tab=linux)[macOS](https://tailscale.com/kb/1598/apple-tv-route-traffic?tab=macos)[tvOS](https://tailscale.com/kb/1598/apple-tv-route-traffic?tab=tvos)[Windows](https://tailscale.com/kb/1598/apple-tv-route-traffic?tab=windows)

1.  Open the Tailscale app on the Android device and go to the **Exit Node** section.
2.  Select the exit node that you want to use. If you want to allow direct access to your local network when routing traffic through an exit node, toggle **Allow LAN access** on.
3.  On the app home screen, confirm that the selected device displays in the **Exit Node** section. When an exit node is being used for the device, the section will turn blue.

To stop a device from using an exit node, go to the **Exit Node** section and select **None**.

Now the device's internet traffic will be securely routed through the Apple TV's network connection.

## [Conclusion](#conclusion)

In this guide, you configured your Apple TV as a secure routing point for your tailnet. This setup gives you an always-available way to protect your network traffic, whether you're on public Wi-Fi, traveling, or working remotely. By sending traffic through your home network, you maintain a trusted connection and can access region-specific content.

## [Further exploration](#further-exploration)

-   [Add additional devices](https://tailscale.com/kb/1316/device-add) to your tailnet.
-   [Invite other users](https://tailscale.com/kb/1271/invite-any-user) to your tailnet to let them route their device traffic.
-   Configure [VPN On Demand](https://tailscale.com/kb/1291/ios-vpn-on-demand) on iOS and macOS devices to automatically enable traffic routing to your Apple TV when you leave your home.
-   Configure [shortcuts](https://tailscale.com/kb/1233/mac-ios-shortcuts#exit-nodes) on iOS and macOS devices to enable or disable routing through your Apple TV.
-   Configure your Apple TV as a [subnet router](https://tailscale.com/kb/1280/appletv#advertise-apple-tv-as-a-subnet-router) to let you remotely access home network devices that don't have Tailscale installed, such as printers or smart home devices.
-   Refer to [Install Tailscale on an Apple TV](https://tailscale.com/kb/1280/appletv) for more information and troubleshooting tips.
```



### File: 1599-rustdesk.md

```markdown
# Access remote desktops using RustDesk

Sometimes you might need to access a computer desktop when you're not able to physically sit in front of it. You might be traveling and need a file on your home desktop, or you might want to help a family member fix their laptop from far away.

[RustDesk](https://rustdesk.com/) lets you remotely connect to another device's desktop. Typically, RustDesk needs a server in the middle to help devices find each other and pass along the connection. You can use RustDesk's public servers or set up your own at home, but running your own server requires additional setup.

Tailscale removes the need to use a RustDesk server entirely. When you install Tailscale on your devices, they can find and connect to each other directly as if they were on the same home network. This lets you use RustDesk without relying on external servers or managing your own. Your connections stay private and secure, and you have remote access without needing extra infrastructure.

## [Prerequisites](#prerequisites)

To follow this guide, you need:

-   A device, such as a phone or laptop, to log in and create the Tailscale network (known as a tailnet), and at least two devices for installing both the Tailscale client and RustDesk. Tailscale runs on most operating systems, including Linux, Windows, macOS, iOS, and Android.
-   An email account that uses a [single sign-on (SSO) identity provider](https://tailscale.com/kb/1013/sso-providers), such as Apple, Google, or Microsoft.

## [Step 1: Create your tailnet](#step-1-create-your-tailnet)

To create a tailnet, [download](https://tailscale.com/download) and install the client on a device such as a phone or laptop, and log in using your existing identity provider. Choose the **Personal** option and follow the remaining instructions to complete the process. Your personal tailnet is now configured and ready to use.

![Select a type of tailnet.](/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fwelcome-page.f3b91c91.png&w=1080&q=75)

Now go to the [Machines](https://login.tailscale.com/admin/machines) page of the admin console and confirm your device connects to your tailnet. The admin console is where you can manage the users, devices, and permissions for your tailnet.

![Machines page of the admin console.](/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fmachines-page.4014fd44.png&w=1080&q=75)

Next, you'll install the Tailscale client on your devices.

## [Step 2: Install Tailscale on your devices](#step-2-install-tailscale-on-your-devices)

To install the Tailscale client, go to the [Downloads](https://tailscale.com/download) page, download the client for your OS, and install. For each device you add, you'll need to log in using your existing identity provider from a web browser. When the confirmation screen displays, go to the [Machines](https://login.tailscale.com/admin/machines) page of the admin console, and verify the device connected to your tailnet.

Devices in a tailnet are occasionally required to re-authenticate to keep your network secure. To avoid disruptions, go to the [Machines](https://login.tailscale.com/admin/machines) page of the admin console, select the ![ellipsis icon](/files/images/icons/fa-ellipsis-h.svg) button next to the device, then select **Disable key expiry**. Keep in mind that disabling key expiry can make a device less secure.

Next, you'll install RustDesk on your devices.

## [Step 3: Install and configure RustDesk on your devices](#step-3-install-and-configure-rustdesk-on-your-devices)

To install RustDesk on your devices, go to the [RustDesk](https://rustdesk.com/) site, then select **Download**. This redirects you to the latest available downloads page. Locate the file for your device, download, and install.

To configure the RustDesk application, open the app, go to the **Security** section and enable **Direct IP access**. At this point, you need to decide whether to rely on the default one-time password or set a permanent password. The one-time password works, but it can be inconvenient for headless or unattended devices, such as machines without a monitor or where no one is at the device to provide it. Setting a permanent password ensures you can connect every time using the same one.

The names of settings in the RustDesk client vary across different operating systems. For more information, refer to the official [RustDesk documentation](https://rustdesk.com/docs/en/).

Next, you'll use RustDesk to connect to another device's desktop.

## [Step 4: Connect to a device using RustDesk over your tailnet](#step-4-connect-to-a-device-using-rustdesk-over-your-tailnet)

When connecting to a device using RustDesk over your tailnet, you must obtain the tailnet IP address and the RustDesk password for the remote device.

To identify the Tailscale IP address for the remote device, go to the [Machines](https://login.tailscale.com/admin/machines)\] page of the admin console, locate the device, and copy the `100.x.x.x` address for the device.

Use the following instructions for the operating system you are using to connect to another desktop.

[macOS](https://tailscale.com/kb/1599/rustdesk?tab=macos)[Windows](https://tailscale.com/kb/1599/rustdesk?tab=windows)[Linux](https://tailscale.com/kb/1599/rustdesk?tab=linux)[iOS](https://tailscale.com/kb/1599/rustdesk?tab=ios)[Android](https://tailscale.com/kb/1599/rustdesk?tab=android)

To connect to a remote device, go to the **Control Remote Desktop** box, paste the `100.x.x.x` Tailscale IP address for the device you want to connect to, then select **Connect**. When prompted, enter the password.

If you've previously connected and the password has not changed, you don't need to re-enter the password.

Now you can remotely and securely access a desktop over your tailnet, as if you were in physically front of it.

## [Conclusion](#conclusion)

In this guide, you configured RustDesk with Tailscale, providing a secure and server-free way to reach your devices from anywhere. By setting up a personal tailnet, installing Tailscale on your devices, and enabling RustDesk's direct IP access, you can connect directly using private tailnet addresses without relying on public servers or running your own. This approach not only reduces setup overhead but also ensures your connections stay private, making remote desktop access more reliable and easier to manage.

## [Further exploration](#further-exploration)

-   Refer to the [RustDesk documentation](https://rustdesk.com/docs/en/) to learn more about configuring and using the RustDesk client.
-   [Invite other users](https://tailscale.com/kb/1271/invite-any-user) to your tailnet.
-   Configure ad blocking for your tailnet using [Raspberry Pi](https://tailscale.com/kb/1114/pi-hole), [Control D](https://tailscale.com/kb/1403/control-d), or [NextDNS](https://tailscale.com/kb/1218/nextdns).
-   Configure a device in your tailnet to [route your tailnet traffic](https://tailscale.com/kb/1408/quick-guide-exit-nodes) for secure browsing wherever you are.
-   Configure a device in your tailnet as a [subnet router](https://tailscale.com/kb/1406/quick-guide-subnets) to remotely access home network devices that don't have Tailscale installed, such as printers or smart home devices.
```



### File: 1601-connect-mongodb-atlas.md

```markdown
# Create a secure connection to MongoDB Atlas

## [Introduction](#introduction)

Many Software as a Service (SaaS) applications require a list of allowed IP address ranges to restrict connectivity to only intended devices and users. If you connect to public Wi-Fi in places like hotels, airports, or cafés, you likely won't have application access due to the allowed IP address list not containing your IP address. For some organizations, when a new user joins the organization, an admin needs to add their IP address to the set of allowed IP addresses, which slows down onboarding of the user.

Tailscale [app connectors](https://tailscale.com/kb/1281/app-connectors) let you route SaaS applications through dedicated devices in your Tailscale network (known as a tailnet). Instead of maintaining an allowlist of all IP addresses on your tailnet, you maintain an allowlist of only the app connector IP addresses. Your users still have access if they work from a café, and new users on your tailnet have access as soon as they join your tailnet. You can use an app connector to securely connect to SaaS applications like a [MongoDB Atlas](https://www.mongodb.com/products/platform) database, and deny access to anyone that is not in your tailnet.

In this guide, you will update your [tailnet policy file](https://tailscale.com/kb/1395/tailnet-policy-file) to restrict access to a MongoDB Atlas database, configure and run an app connector to route requests to the database, and update the Atlas IP address list to allow access only through the app connector. When you finish this guide, you'll have set access restrictions to let only your tailnet users access the database.

## [Prerequisites](#prerequisites)

Before you begin this guide you'll need the following:

-   A MongoDB Atlas database. For information about MongoDB Atlas, refer to MongoDB's [What is MongoDB Atlas?](https://www.mongodb.com/docs/atlas/) topic.
-   A user name and password for your Atlas database.
-   A MongoDB Atlas role of Project Owner, so that you can edit the Atlas IP access list.
-   Your Atlas connection string. This is in the form `<cluster-name>.<hash>.mongodb.net`. For example, `cluster0.abcdef.mongodb.net`. For information about retrieving your connection string, refer to [Find your MongoDB Atlas connection string](https://www.mongodb.com/docs/manual/reference/connection-string/#find-your-mongodb-atlas-connection-string).
-   A Tailscale account. [Create an account](https://login.tailscale.com/start) if you don't have one already.
-   A Linux device to use as an app connector for your tailnet. This solution will show you how to start this device as an app connector for Atlas. For now, ensure the device meets the app connector [requirements](https://tailscale.com/kb/1342/app-connectors-setup#requirements) and is already in your tailnet.
-   A different device in your tailnet that has [MongoDB Shell](https://www.mongodb.com/docs/mongodb-shell/) installed. You will use this device to connect to your MongoDB Atlas database.
-   A Tailscale role of either [Owner, Admin, or Network admin](https://tailscale.com/kb/1138/user-roles) so that you can edit your [tailnet policy file](https://tailscale.com/kb/1395/tailnet-policy-file).

## [Step 1: Update your tailnet policy file](#step-1-update-your-tailnet-policy-file)

Configure your [tailnet policy file](https://tailscale.com/kb/1395/tailnet-policy-file) to securely route tailnet traffic to your Atlas database. You need to make the following updates to your tailnet policy file:

-   Create a Tailscale group for your Atlas admins.
-   Create a tag to use for your app connector devices, which will connect your tailnet users to your Atlas database.
-   Configure auto approval of your app connector devices, so that when they join your tailnet, their routes to the Atlas database are automatically approved. This lets you set up an app connector device by running a single [`tailscale up`](https://tailscale.com/kb/1241/tailscale-up) command on the device.
-   Create a grant that lets your tailnet users access the Atlas database.
-   Define the set of domains for your specific MongoDB Atlas project. Your Atlas app connector uses these domains to route tailnet traffic to the Atlas database.

You need to be an [Owner, Admin, or Network admin](https://tailscale.com/kb/1138/user-roles) to edit a tailnet policy file.

### [Create an Atlas admins group](#create-an-atlas-admins-group)

Tailscale [groups](https://tailscale.com/kb/1337/policy-syntax#groups) let you create groups of users, which you can use in access rules (instead of listing users out explicitly). Create a group named `atlas-admins` so that you can add all of your Atlas admins into a single group.

1.  Go to the [Visual editor](https://login.tailscale.com/admin/acls/visual) tab of the admin console.

2.  Select **Groups**, and then select **Create tag**.

3.  For **Group name**, enter `atlas-admins`.

4.  For **Members**, select yourself from the dropdown list. If you have others in your tailnet that you want to administer your Atlas app connector, add them to this group also.

5.  (Optional) For **Note**, enter any note you'd like to keep for this group.

6.  Select **Save group**.


Now that you have the `atlas-admins` group, you can use it in a tag.

### [Create a tag for your app connector devices](#create-a-tag-for-your-app-connector-devices)

Tailscale [tags](https://tailscale.com/kb/1068/tags) let you authenticate and identity non-user devices. A tag consists of an identifier and the users and groups that can apply the tag. Create a `tag:atlas-app-connector` tag so that you and any other members of the `atlas-admin` group can apply the tag to the devices you want to use for your Atlas app connectors.

1.  Go to the [Visual editor](https://login.tailscale.com/admin/acls/visual) tab of the admin console.

2.  Select **Tags**, and then select **Create tag**.

3.  For **Tag name**, enter `atlas-app-connector`.

4.  For **Tag owner**, select `group:atlas-admins`.

5.  (Optional) For **Note**, enter any note you'd like to keep for this tag.

6.  Select **Save tag**.


Now that you have the tag named `atlas-app-connector`, you can use it to auto approve routes to your Atlas database.

### [Create an auto approver for your app connector routes](#create-an-auto-approver-for-your-app-connector-routes)

Add an [`autoApprovers`](https://tailscale.com/kb/1337/policy-syntax#autoapprovers) rule to automatically approve specific routes for devices that have the `atlas-app-connector` tag. After you configure app traffic to route through an app connector, any DNS request to the configured app domains triggers route discovery.

1.  Go to the [Visual editor](https://login.tailscale.com/admin/acls/visual) tab of the admin console.

2.  Select **Auto approvers**, and then select **Add route**.

3.  For **Route**, enter `0.0.0.0/0`.

4.  For **Route is approved for**, select `tag:atlas-app-connector`.

5.  (Optional) For **Note**, enter any note you'd like to keep for this auto approver route.

6.  Select **Add route** again.

7.  For **Route**, enter `::/0`.

8.  For **Route is approved for**, select `tag:atlas-app-connector`.

9.  (Optional) For **Note**, enter any note you'd like to keep for this auto approver route.

10.  Select **Save route auto approver**.


### [Provide MongoDB Atlas access to your tailnet users](#provide-mongodb-atlas-access-to-your-tailnet-users)

Add a [`grants`](https://tailscale.com/kb/1337/policy-syntax#grants) rule to route Atlas traffic through the app connectors.

You must allow tailnet devices to access the routes an app connector advertises. One way to do this is to add an access control policy to your tailnet policy file that grants access to `autogroup:internet` (any port number) for members of the tailnet, which will also grant users access to any [exit nodes](https://tailscale.com/kb/1103/exit-nodes) in the tailnet.

1.  Go to the [Visual editor](https://login.tailscale.com/admin/acls/visual) tab of the admin console.

2.  Select **General access rules**, and then select **Add rule**.

3.  For **Source**, select `autogroup:member`.

4.  For **Destination**, select `autogroup:internet`.

5.  For **Destination and protocol**, select `All ports and protocols`.

6.  (Optional) For **Note**, enter any note you'd like to keep for this grant.

7.  Select **Save grant**.


### [Set the Atlas domains](#set-the-atlas-domains)

Add your Atlas project domains to your connector, by adding a [node attribute](https://tailscale.com/kb/1337/policy-syntax#nodeattrs) for the `tag:atlas-app-connector` tag that you created. Any device that you run for this app connector will use these domains to map client requests to your Atlas database.

Your Atlas connection string contains the MongoDB Atlas domain for your Atlas project, in the form of `<cluster-name>.<hash>.mongodb.net`. For example, `cluster0.abcdef.mongodb.net`. For that example, use `*.abcdef.mongodb.net` for your domain string in the following step. If you want to restrict access to only specific a specific cluster, you can use a domain string like `cluster0.abcdef.mongodb.net`.

Now that you have your Atlas domain, add it to your app connector's node attributes.

Add your Atlas domain to the app connector

Configure your app connector to handle the routing of database requests based on your Atlas domain.

1.  Go to the [Visual editor](https://login.tailscale.com/admin/acls/visual) tab of the admin console.

2.  Select **Node attributes**, and then select **Add node attribute**.

3.  For **Targets**, select `All users and devices`.

4.  (Optional) For **Note**, enter any note you'd like to keep for this node attribute.

5.  For **App**, enter `tailscale.com/app-connectors`.

6.  For **Capability**, enter the following (replacing `<hash>` with your connection string's hash):

    ```json
    {
      "connectors": [
        "tag:atlas-app-connector"
      ],
      "domains": [
        "*.<hash>.mongodb.net"
      ],
      "name": "Atlas"
    }
    ```

    If you want to specify a specific cluster instead of `*` for the `domains` entry, use `"<cluster-name>.<hash>.mongodb.net"`instead of `"*.<hash>.mongodb.net"`.

7.  Select **Save node attribute**.


Now that you configured your app connector for Atlas access, start your app connector device.

## [Step 2: Start an app connector for Atlas](#step-2-start-an-app-connector-for-atlas)

Run a device in your tailnet to securely route your user traffic to your MongoDB Atlas database.

The app connector device must be running Linux, already added to your tailnet, have a public IP address, and IP port forwarding enabled, as described in the app connector [Requirements](https://tailscale.com/kb/1342/app-connectors-setup#requirements).

On your Linux device that you want to use as an app connect, run the following [`tailscale up`](https://tailscale.com/kb/1241/tailscale-up) command:

```shell
tailscale up --advertise-connector --advertise-tags=tag:atlas-app-connector
```

The `--advertise-connector` flag enables the device to route traffic for specific domains according to the configuration in the tailnet policy file. The `--advertise-tags` flag tells the Tailscale client to authenticate the device with the `tag:atlas-app-connector` tag.

By default, devices in a tailnet are occasionally required to re-authenticate to keep your network secure. To avoid DNS interruptions if the app connector device needs to re-authenticate, go to the [Machines](https://login.tailscale.com/admin/machines) page of the admin console, select the ![ellipsis icon](/files/images/icons/fa-ellipsis-h.svg) button next to the app connector device, then select **Disable key expiry**.

Now that your app connector is running and serving as an Atlas app connector, you can allowlist its IP address in Atlas to let your tailnet users access the database.

## [Step 3: Allowlist the app connector in Atlas](#step-3-allowlist-the-app-connector-in-atlas)

Atlas permits client connections only from entries in the [Atlas access list](https://www.mongodb.com/docs/atlas/security/ip-access-list). Update the Atlas access list to use the egress IP addresses from your app connector.

First, get the IP address of your app connector from the Tailscale admin console.

1.  Open the [Apps](https://login.tailscale.com/admin/apps) page of the admin console.

2.  Select **MongoDB Atlas**.

3.  In the **Egress IPs** section, copy the IP address.

    You can enter only one IP address at a time into the Atlas access list. If you have more than one **Egress IP** address, you need to individually copy and paste them to the Atlas IP access list.


Next, add the IP address to the Atlas list of allowed IP addresses.

1.  In the [Atlas dashboard](https://www.mongodb.com), go to **Project** and make your Atlas project the active project, if it is not already.
2.  In the sidebar, under **Security**, select **Network Access**, and then select **IP Access List**.
3.  Select **Add IP Address**.
4.  For **Access List Entry**, enter the app connector egress IP address that you copied from the Tailscale admin console.
5.  (Optional) For **Comment**, enter any comment you'd like to keep for this IP address.
6.  (Optional) Set a time limit for the duration of access allowed for this IP address.
7.  Select **Confirm**.

If you have more IP addresses in your app connector's **Egress IPs** list, repeat this step to add them to the Atlas access list.

### [Remove unneeded IP addresses from the Atlas access list](#remove-unneeded-ip-addresses-from-the-atlas-access-list)

If your Atlas access list contains IP addresses that are not specific to your app connector, remove them. Otherwise, someone outside of your tailnet could access the database.

1.  In the **Network Access** page, for any IP address that your want to delete, select **Delete**.
2.  Select **Delete** again to confirm you want to delete it.

For more information about MongoDB Atlas IP access lists, refer to MongoDB's [Configure IP Access List Entries](https://www.mongodb.com/docs/atlas/security/ip-access-list) topic.

Now that you configured your Atlas project to accept requests from only the specified IP address range, you can make a connection from a device in your tailnet.

## [Step 4: Connect to your database](#step-4-connect-to-your-database)

Use the device in your tailnet with `mongosh` installed to connect to your database. Use a device separate from the app connector device.

1.  If the device is a Linux device, run the following [`tailscale set`](https://tailscale.com/kb/1080/cli#set) command so the client accepts the routes provided by the app connector:

    ```shell
    tailscale set --accept-routes
    ```

    Tailscale clients on other operating systems accept the routes by default.

2.  Run the following (replace the placeholders with the values for your Atlas database):

    ```shell
    mongosh "mongodb+srv://<cluster-name>.<hash>.mongodb.net/" \
      --apiVersion 1 \
      --username <database-user-name>
    ```

    If the `mongosh` command succeeds, the `mongosh` prompt opens. To confirm you can connect to your database, run:

    ```shell
     show dbs;
    ```

    The command should provide a list the databases in your Atlas project, similar to:

    ```shell
    myDatabase     72.00 KiB
    admin         356.00 KiB
    local         997.79 MiB
    ```


When you finish using the `mongosh` prompt, enter `exit` to close the `mongosh` prompt.

Now that you've tested a connection from a separate device, try the same `mongosh` steps but first ensure that the separate device is running in a different LAN. If both the app connector and the separate device are using the same LAN, their IP addresses are in the same IP address that you allowlisted. If the separate device runs on a different local area network, it uses an IP address different than the app connector IP address. If the device is on a different LAN and still successfully connects to your Atlas database, that means you have successfully allowed access from the Atlas side.

Now you're ready to confirm that the connection requires Tailscale.

### [Confirm your connection requires Tailscale](#confirm-your-connection-requires-tailscale)

1.  On a device separate from your app connector, and on a different local area network than used by the app connector, disable the Tailscale client. You can disable the Tailscale client through the Tailscale client UI, or through the [`tailscale down`](https://tailscale.com/kb/1080/cli#down) command.

2.  Run the following command (replace the placeholders with the values for your Atlas database):

    ```shell
    mongosh "mongodb+srv://<cluster-name>.<hash>.mongodb.net/" \
      --apiVersion 1 \
      --username <database-user-name>
    ```

    This command should fail to connect to your database, because the device will not be able to use the app connector due to Tailscale not running. If the device is not running Tailscale and it does successfully connect to your database, and you confirmed that the device has a different IP address than the app connector, that means your Atlas allowed IP addresses is too permissive. Check whether there are any IP addresses that should not have access and remove them.

    If you can connect to your Atlas database on a device that is not running Tailscale and the device IP address is different from the app connector IP address, check your Atlas and tailnet policy file settings, and correct as needed. Otherwise, your database access is not secure.


After you confirm that the connection required Tailscale, remember to enable Tailscale on the client. You can enable the Tailscale client through the Tailscale client UI, or through the [`tailscale up`](https://tailscale.com/kb/1241/tailscale-up) command.

## [Conclusion](#conclusion)

In this guide you configured an app connector so that your tailnet clients can access a MongoDB Atlas database and anyone outside of your tailnet cannot access the database. You also ensured that a device needs Tailscale enabled to allow access.

To ensure that your tailnet users have high availability to your database, consider [adding another app connector](#start-app-connector) device so that a single point of app connector failure won't lock out Atlas access. If you add another app connector, remember to [add its egress IP address](#allowlist-app-connector) to the Atlas access list.

For more information about app connectors, refer to [App connectors](https://tailscale.com/kb/1281/app-connectors).
```



### File: compare.md

```markdown
# Tailscale vs. alternatives

Unsure which VPN to go with? Navigate the strengths and drawbacks of other VPN solutions when compared to Tailscale.

[

Get started



](https://login.tailscale.com/start)[

Contact Sales



](https://tailscale.com/contact/sales)

![compare](https://cdn.sanity.io/images/w77i7m8x/production/317e2af7dbb89583f9eda66c1e370470b54985c7-1440x492.svg?w=3840&q=75&fit=clip&auto=format)

## Why choose Tailscale?

Tailscale is a secure and private, identity-based, infrastructure agnostic network with a flexible topology, resilient networking, and a streamlined setup.

It's a network that just works.

![scale](https://cdn.sanity.io/images/w77i7m8x/production/10f7f126203ef51cbc43006324056174e76cbf7a-138x102.svg?w=384&q=75&fit=clip&auto=format)

#### Built for scale

Let's face it: traditional VPNs don't scale well. When connections to internal networks go through a central VPN concentrator, bottlenecks are commonplace. Speed and reliability take a hit, too.

![connect](https://cdn.sanity.io/images/w77i7m8x/production/3300f692f65d69bc84d7d49b52d70790880a0af4-138x102.svg?w=384&q=75&fit=clip&auto=format)

#### Designed for connectivity

Tailscale's peer-to-peer mesh network allows your machines to connect to each other directly - with coordination provided centrally - reducing bottlenecks, speeding things up, and improving reliability.

![optimized](https://cdn.sanity.io/images/w77i7m8x/production/5957d18f5b16eb2f691c363f838d3dc7a0b62f7b-138x102.svg?w=384&q=75&fit=clip&auto=format)

#### Optimized for security

Tailscale's "zero trust," identity-based approach to security enables the use of single sign-on (SSO) and user group-based security policies. So you can operate with total peace-of-mind.

## VPN comparisons

[

Tailscale vs.

Cisco Secure Client



](https://tailscale.com/compare/cisco-secure-client)[

Tailscale vs.

Fortinet



](https://tailscale.com/compare/fortinet)[

Tailscale vs.

OpenVPN



](https://tailscale.com/compare/openvpn)[

Tailscale vs.

Palo Alto Networks GlobalProtect



](https://tailscale.com/compare/palo-alto-networks-globalprotect)[

Tailscale vs.

AWS Client VPN



](https://tailscale.com/compare/aws-client-vpn)[

Tailscale vs.

ZeroTier



](https://tailscale.com/compare/zerotier)[

Tailscale vs.

Nebula



](https://tailscale.com/compare/nebula)[

Tailscale vs.

Cloudflare Access



](https://tailscale.com/compare/cloudflare-access)[

Tailscale vs.

ngrok



](https://tailscale.com/compare/ngrok)[

Tailscale vs.

HashiCorp Boundary



](https://tailscale.com/compare/hashicorp-boundary)[

Tailscale vs.

Zscaler



](https://tailscale.com/compare/zscaler)[

Tailscale vs.

Pritunl



](https://tailscale.com/compare/pritunl)[

Tailscale vs.

Twingate



](https://tailscale.com/compare/twingate)[

Tailscale vs.

WireGuard



](https://tailscale.com/compare/wireguard)[

Tailscale vs.

Build It Yourself



](https://tailscale.com/compare/build-it-yourself)

![alt](https://cdn.sanity.io/images/w77i7m8x/production/d7941622dbe9bf7ddc814c81ec89c714fdcc4c7e-134x28.svg?w=384&q=75&fit=clip&auto=format)

"With our old VPN, we'd spend a lot of time worrying about client-side issues for our users. With Tailscale, we do need to maintain some infrastructure, but from an engineering perspective, that's easy compared to the chaotic client-side issues we used to deal with."

Hirotaka Nakajima, Senior Software Engineer at Mercari

[

Read full story



](https://tailscale.com/customers/mercari)
```



### File: kb.md

```markdown
# Docs

Welcome to the Tailscale documentation. Pick a category to browse, or use the search box to find documents matching your keywords.

[

#### Start using Tailscale

Install Tailscale, create a network, and invite your team.



](https://tailscale.com/kb/1346/start)[

#### How-to Guides

Step-by-step instructions on how to use Tailscale features to make managing your network easy.



](https://tailscale.com/kb/1348/guides)[

#### Integrations

How to use Tailscale to various kinds of servers, services, or devices.



](https://tailscale.com/kb/1356/integrations)[

#### FAQ

Answers to common questions.



](https://tailscale.com/kb/1366/faq)[

#### Technical reference

Explore reference guides for Tailscale tools and features, including access control policies, command-line interface (Tailscale CLI), API, and best practices for managing your tailnet. Understand access controls, production strategies, security, and key terminology.



](https://tailscale.com/kb/1367/reference)[

#### Resources

Access resources about Tailscale software changes, comparisons with other products, open source community projects, security, privacy, and compliance.



](https://tailscale.com/kb/1368/resources)
```



### File: security.md

```markdown
# Security at Tailscale

Thousands of teams trust Tailscale - and that's in part thanks to our commitment to security and privacy.

![mercury](https://cdn.sanity.io/images/w77i7m8x/production/459a7a8492910eeb22f22bb8d4c0f864b0bae25f-199x81.svg?w=640&q=75&fit=clip&auto=format)

![instacart](https://cdn.sanity.io/images/w77i7m8x/production/d4219a3f402a5d534e4b066a6c2c6f413845bbe6-199x81.svg?w=640&q=75&fit=clip&auto=format)

![retool](https://cdn.sanity.io/images/w77i7m8x/production/cb246bbbf44aa4a4ae8cc03ea2b9f4bf277ce9a6-199x82.svg?w=640&q=75&fit=clip&auto=format)

![duolingo](https://cdn.sanity.io/images/w77i7m8x/production/0e3a834c863fd6aa4bb9c01eccef6799d799e0e4-199x81.svg?w=640&q=75&fit=clip&auto=format)

![mercari](https://cdn.sanity.io/images/w77i7m8x/production/c65151b7efb15a50edb234819fa5a5423637baad-199x81.svg?w=640&q=75&fit=clip&auto=format)

![sso](https://cdn.sanity.io/images/w77i7m8x/production/5d26fe334bce8c35d820097ed7c37dfc02d452f2-56x56.svg?w=128&q=75&fit=clip&auto=format)

SSO and MFA

Tailscale relies on your existing identity provider to authenticate users, and automatically uses authentication settings like MFA.

![Access Controls Lists](https://cdn.sanity.io/images/w77i7m8x/production/69022073fd725cffb7209a3c1f1a22fbb103b398-56x56.svg?w=128&q=75&fit=clip&auto=format)

Access Controls Lists

ACLs allow you to define which users can connect to which devices in your network.

![End-to-end encrypted](https://cdn.sanity.io/images/w77i7m8x/production/0ef72ae13ddf626d93d83b1c6e367c28a409568a-56x56.svg?w=128&q=75&fit=clip&auto=format)

End-to-end encrypted

Tailscale is built on top of WireGuard®, a modern VPN that provides end-to-end encryption between devices. Tailscale cannot read your traffic.

![SOC 2](https://cdn.sanity.io/images/w77i7m8x/production/8ed1d8caba727d8426023182bb57299c5dd44d3e-56x56.svg?w=128&q=75&fit=clip&auto=format)

SOC 2

Tailscale has completed a SOC 2 Type II certification, meeting AICPA's Trust Services Criteria for security, availability, and confidentiality.

![Latacora](https://cdn.sanity.io/images/w77i7m8x/production/dcacd12a50b027719c0612457971b547589d1edb-56x56.svg?w=128&q=75&fit=clip&auto=format)

Latacora Audits

Tailscale works with Latacora, a security firm that specializes in information security, to conduct security audits.

![Security Bulletins](https://cdn.sanity.io/images/w77i7m8x/production/46b0234af1b51972adc7f28d36174fae42f6f2f1-56x56.svg?w=128&q=75&fit=clip&auto=format)

Security Bulletins

Tailscale publishes security bulletins to disclose security issues in our product.

## [Security by design](#security-by-design)

##### [**Tailscale connections are end-to-end encrypted with WireGuard®**](#tailscale-connections-are-end-to-end-encrypted-with-wireguardr)

Tailscale is built on top of [WireGuard.](https://www.wireguard.com/)

WireGuard is a modern VPN designed for usability, performance, and security. WireGuard uses state-of-the-art cryptography and provides end-to-end encryption for connection between devices. WireGuard's protocol has been [reviewed by cryptographers](https://eprint.iacr.org/2018/080.pdf) and the [code audited](https://arstechnica.com/gadgets/2020/03/wireguard-vpn-makes-it-to-1-0-0-and-into-the-next-linux-kernel/), with only minor issues discovered and fixed.

We designed Tailscale to make it even easier to use WireGuard to secure your network connections.

##### [**Tailscale sees your metadata, not your data**](#tailscale-sees-your-metadata-not-your-data)

Tailscale does not (and cannot) inspect your traffic. Privacy is a fundamental human right, and we designed Tailscale accordingly. We don't want your data.

[Your data is end-to-end encrypted and transmitted point-to-point](https://tailscale.com/blog/how-tailscale-works/). Your devices' private encryption keys never leave their respective nodes, and our coordination server only collects and exchanges public keys. DERP relay servers do not log your data - you can confirm this yourself as the [code is open-source](https://github.com/tailscale/tailscale/tree/main/derp). Even when your connection uses a DERP relay server, the only data Tailscale could see and capture is encrypted.

We never see information about your public Internet traffic. If you use an [exit node](https://tailscale.com/kb/1103/exit-nodes/), they're your exit nodes, not ours, so we still can't see your public Internet traffic. If you use [MagicDNS or Split DNS](https://tailscale.com/kb/1054/dns/), your public DNS queries may end up passing through your device's local Tailscale DNS proxy, but they are not logged. Again, you can verify this yourself because the [code is open-source](https://github.com/tailscale/tailscale).

We do receive metadata about which of your private nodes connect to which other private nodes, including public IP addresses. This is required to provide the service, as the purpose of Tailscale's coordination server is to help your nodes find each other.

##### [Your network remains available even if Tailscale is not](#your-network-remains-available-even-if-tailscale-is-not)

Tailscale connects devices point-to-point. Even if Tailscale's coordination server is down, you can still access your network.

Tailscale's coordination server is used to help your nodes find each other. Once this information is exchanged, however, your nodes have all the information they need to connect. Though the coordination server needs to be available for you to make administrative changes, removing this dependency means you don't have a single point of failure for your users to connect to your services.

Although Tailscale tries to connect devices point-to-point, [that's not always possible](https://tailscale.com/blog/how-nat-traversal-works/), so we have [globally distributed DERP relay servers](https://tailscale.com/kb/1232/derp-servers) to help devices connect to each other when connections are hard to establish. The DERP servers run in multiple regions and have no shared state between regions, which means a DERP region can have an outage and your Tailscale clients will fail over to a different one.

##### [Tailscale is written in Go](#tailscale-is-written-in-go)

Tailscale uses [wireguard-go](https://github.com/WireGuard/wireguard-go). Tailscale's core functionality, including the coordination server, logging infrastructure, DERP relay servers, and clients, are written in [Go](https://go.dev/). Go is a language that provides automatic memory management, and so doesn't rely on the developer to allocate and free up memory - which prevents a [whole class of memory safety vulnerabilities](https://cwe.mitre.org/data/definitions/119.html).

## [Security Features](#security-features)

##### [SSO and MFA](#sso-and-mfa)

Tailscale relies on your existing identity provider to authenticate users. Any authentication settings from your identity provider are automatically used by Tailscale, including MFA and context-aware access. Authenticate to Tailscale with [identity providers including Google, Microsoft AD, GitHub, Okta, and OneLogin](https://tailscale.com/kb/1013/sso-providers/).

##### [Access Controls Lists (ACLs)](#access-controls-lists-acls)

Tailscale's [ACLs](https://tailscale.com/kb/1018/acls/) allow you to define what users, groups, IP addresses, CIDRs, hosts, and tags can connect to each other in your network. Using ACLs, you can define [role-based access controls](https://tailscale.com/blog/rbac-like-it-was-meant-to-be/) for users accessing services in your network in terms of user identities, rather than in terms of IP addresses. ACLs are directional and default deny.

##### [User roles](#user-roles)

Tailscale provides multiple [user roles](https://tailscale.com/kb/1138/user-roles/) that restrict who can modify your tailnet's configurations. These allow for separation of duties between admins who can modify users and devices, such as IT administrators, and those who can modify network configurations, such as the networking team.

To take advantage of all of Tailscale's security features and best protect your network, we recommend following our [hardening guide](https://tailscale.com/kb/1196/security-hardening).

##### [Security disclosures](#security-disclosures)

Tailscale publishes [security bulletins](https://tailscale.com/security-bulletins/) to disclose security issues in our product.

If you're directly affected by a security issue in Tailscale, and [we have your contact information](https://tailscale.com/kb/1224/contact-preferences/), we will contact you.

Securing a virtual private network requires both the provider and the user to share in the burden of responsibility. To understand how responsibilities are shared between you and Tailscale, see the [shared responsibility model](https://tailscale.com/kb/1212/shared-responsibility).

##### [Tailnet lock](#tailnet-lock)

[Tailnet lock](https://tailscale.com/kb/1226/tailnet-lock) lets you control which nodes are signed and verified by trusted nodes in your tailnet, meaning you don't need to trust the Tailscale coordination server for distributing public [node keys](https://tailscale.com/blog/tailscale-key-management/#node-keys) to peer nodes in your tailnet. You can control which nodes are trusted to sign another node's public key.

## [Compliance & Certifications](#compliance-and-certifications)

![soc2](https://cdn.sanity.io/images/w77i7m8x/production/bffb4e73df55d9d7bde8bf6186aa99fb5d6dbd3b-375x372.jpg?w=750&q=75&fit=clip&auto=format)

##### [SOC 2](#soc-2)

Tailscale has completed a [SOC 2](https://tailscale.com/security-bulletins/) Type II certification.

Achieving SOC 2 compliance means that Tailscale has implemented procedures, policies and controls necessary to meet AICPA's Trust Services Criteria for security, availability, and confidentiality, and that these processes and controls have been tested to ensure that they are operating effectively.

Obtain a copy of the report from our [legal page](https://tailscale.com/legal).

## [Security policies](#security-policies)

Tailscale publishes the [security policies](https://tailscale.com/security-policies/) we use publicly, so you can transparently see where we are in terms of security maturity.

To track how these change over time, or to use these policies yourself, see the [policies on GitHub](https://github.com/tailscale/security-policies).

## [Security Controls](#security-controls)

Tailscale has many security controls in place to ensure the security of the service.

##### [Network & infrastructure security](#network-and-infrastructure-security)

-   Requires business need to access the production environment.
-   Requires SSO and MFA to manage the production environment.
-   Requires connections over Tailscale or using SSH keys to access the production environment.
-   Logs operations in the production environment, and audits these for unusual activity.

##### [Data security](#data-security)

-   Encrypts data at rest and in transit.
-   Backs up data at least hourly, and tests recovery at least annually.
-   Retains data in line with our [Privacy Policy](https://tailscale.com/privacy-policy/).

##### [Application security](#application-security)

-   Requires a peer review for source code changes.
-   Regularly conducts audits of our source code.
-   Regularly reviews potential vulnerabilities in our environment and applies relevant patches.
-   Reviews access permissions at least quarterly.

##### [Incident response](#incident-response)

-   Responds to security issues reported to [security@tailscale.com](mailto:security@tailscale.com) promptly.
-   Discloses security issues in [security bulletins](https://tailscale.com/security-bulletins/).

##### [Business practices](#business-practices)

-   Checks references for all new employees.
-   Requires new and existing employees to regularly complete security awareness training.
-   Requires new employees to sign a non-disclosure agreement.
-   Reviews new vendors prior to using their services, and existing vendors at least annually.

![Lactora](https://cdn.sanity.io/images/w77i7m8x/production/9e153adad14c97445be599dabc208d5893b79a51-175x175.svg?w=384&q=75&fit=clip&auto=format)

Tailscale works with [Latacora](https://www.latacora.com/) to conduct security audits and ongoing analysis of our application security, network security, and corporate security. Latacora also provides feedback and guidance on new product features and Tailscale's architecture.

## [Privacy](#privacy)

In addition to securing your information, we keep it private. Tailscale values and respects your privacy. [You are not the product](https://tailscale.com/blog/free-plan/).

To learn more about what data we collect, and how we use it, see our [Privacy Policy](https://tailscale.com/privacy-policy/).

{"@context":"https://schema.org","@type":"FAQPage","mainEntity":\[{"@type":"Question","name":"Can Tailscale decrypt my traffic and see my data?","acceptedAnswer":{"@type":"Answer","text":"No. Devices running Tailscale only exchange their public keys. Private keys never leave the device. All traffic is end-to-end encrypted, always."}},{"@type":"Question","name":"Is my traffic routed through your servers?","acceptedAnswer":{"@type":"Answer","text":"No. Tailscale routes traffic over the shortest path possible. In most cases, this is a direct, peer-to-peer connection.\\nIn cases where a direct connection cannot be established, devices will communicate by bouncing traffic off one or more geographically distributed DERP relay servers. Your traffic remains end-to-end encrypted when it passes through a relay server, and Tailscale can't decrypt it."}},{"@type":"Question","name":"Will others be able to access my computer?","acceptedAnswer":{"@type":"Answer","text":"Tailscale allows you to connect your computer to other devices logged in to the same Tailscale network. Only devices that are permitted to access your computer as defined in ACLs can initiate connections to your computer. You can also locally block incoming connections to your device."}},{"@type":"Question","name":"Does Tailscale encrypt my data?","acceptedAnswer":{"@type":"Answer","text":"Yes. Tailscale encrypts customer metadata in the coordination server at rest using 256-bit AES and in transit using TLS. Customer data is encrypted in transit using WireGuard."}},{"@type":"Question","name":"Does Tailscale back up my data?","acceptedAnswer":{"@type":"Answer","text":"Tailscale backs up customer metadata in the coordination server hourly and tests backups at least annually."}},{"@type":"Question","name":"Does Tailscale conduct security audits?","acceptedAnswer":{"@type":"Answer","text":"Yes. We work with Latacora to conduct regular security audits. These include traditional assessments, but also monitoring, maturity model review, design review and advisory services. On top of that, we also have peer code reviews, automated static analysis checks, and dependency vulnerability scans."}},{"@type":"Question","name":"What infrastructure does Tailscale use?","acceptedAnswer":{"@type":"Answer","text":"Tailscale's infrastructure includes the following:\\nA client, run on each of a user's devices. This is available for many platforms including macOS, Windows, Linux, iOS, and Android.\\nA coordination server, which distributes public keys and controls settings for the service. Tailscale's control plane runs on Linux servers in Amazon Web Service (AWS), in AWS Virtual Private Clouds (VPCs). Coordination server data is stored in SQLite and backed up to AWS S3, with analytics stored in Snowflake.\\nDesignated Encrypted Relay for Packets (DERP) relay servers, which help clients establish end-to-end encrypted connections where they have trouble connecting directly. Tailscale's DERP relay servers run on Linux servers in multiple regions on multiple infrastructure providers. Learn more about How Tailscale works."}},{"@type":"Question","name":"Is Tailscale's infrastructure multi-tenant?","acceptedAnswer":{"@type":"Answer","text":"Yes. Tailscale's coordination server, which distributes public keys and controls settings, is multi-tenant. This only stores customer metadata and public keys, not data or private keys.\\nTailscale's DERP relay servers, which help establish point-to-point connections, are multi-tenant. These only route encrypted customer data, never unencrypted data."}},{"@type":"Question","name":"What data does Tailscale collect?","acceptedAnswer":{"@type":"Answer","text":"In order to provide the service, Tailscale collects device information, including OS, hardware, public IP addresses, network routing information, information on the installed Tailscale client, and other device settings. Tailscale also uses user account information, such as email addresses, to authenticate users to their accounts.\\nSee our Privacy Policy for more details on how we collect and use personal information."}},{"@type":"Question","name":"Does Tailscale have a DPA? Who are your subprocessors?","acceptedAnswer":{"@type":"Answer","text":"Yes. Tailscale provides a Data Privacy Addendum to all customers, and publishes a list of subprocessors."}},{"@type":"Question","name":"Can I opt out of logging?","acceptedAnswer":{"@type":"Answer","text":"Tailscale collects customer metadata related to connection attempts, authentication, and routing to help us to monitor and debug networks.\\nIf you opt out of logging, Tailscale may not be able to provide technical support. To learn how to opt out, see Opting out of client logging.\\nYou cannot limit coordination server logs."}},{"@type":"Question","name":"Is Tailscale SOC 2 compliant?","acceptedAnswer":{"@type":"Answer","text":"Yes. Tailscale has completed a SOC 2 Type II audit covering AICPA's Trust Services Criteria for security, availability, and confidentiality. Obtain a copy of the report from our compliance page. Note that the report is confidential, and prospective customers will need to contact support and sign an NDA to access the report."}},{"@type":"Question","name":"Is Tailscale HIPAA compliant?","acceptedAnswer":{"@type":"Answer","text":"HIPAA defines controls for securing health information.\\nAs Tailscale does not store customer data, only metadata, Tailscale doesn't have any services in scope for HIPAA. US-based healthcare customers do not need and Tailscale does not execute business associate agreements (BAAs) with our US-based healthcare clients.\\nTailscale can be a supporting safeguard for your HIPAA-compliant system to provide integrity and encryption for electronic protected health information transmitted over an electronic communications network (HIPAA 45 CFR § 164.312(e)(1))."}},{"@type":"Question","name":"Is Tailscale PCI compliant?","acceptedAnswer":{"@type":"Answer","text":"PCI DSS 4.0 defines controls for securing credit card information and requires eligible merchants to complete the SAQ A form to demonstrate compliance.\\nTailscale does not store credit card information, and instead uses Stripe to securely process transactions. Stripe is certified to PCI DSS Service Provider Level 1, which is the highest level of security certification available in the payments industry.\\nAs Tailscale does not directly store or process credit card information, Tailscale doesn't have any services in scope for PCI DSS. However, under the PCI DSS 4.0 requirements, Tailscale has completed the SAQ A form to ensure that our service provider, Stripe, is PCI-compliant and contractually obligated to handle all PCI obligations."}}\]}

## Security FAQs

### Can Tailscale decrypt my traffic and see my data?

No. Devices running Tailscale only exchange their public keys. Private keys never leave the device. All traffic is end-to-end encrypted, always.

### Is my traffic routed through your servers?

No. Tailscale routes traffic over the shortest path possible. In most cases, this is a direct, peer-to-peer connection.

In cases where a direct connection cannot be established, devices will communicate by bouncing traffic off one or more geographically distributed [DERP relay servers](https://tailscale.com/kb/1118/custom-derp-servers/#what-are-derp-servers). Your traffic remains end-to-end encrypted when it passes through a relay server, and Tailscale can't decrypt it.

### Will others be able to access my computer?

Tailscale allows you to connect your computer to other devices logged in to the same Tailscale network. Only devices that are permitted to access your computer as defined in [ACLs](https://tailscale.com/kb/1018/acls/) can initiate connections to your computer. You can also locally [block incoming connections](https://tailscale.com/kb/1072/client-preferences/#allow-incoming-connections) to your device.

### Does Tailscale encrypt my data?

Yes. Tailscale encrypts customer metadata in the coordination server at rest using 256-bit AES and in transit using TLS. Customer data is encrypted in transit using WireGuard.

### Does Tailscale back up my data?

Tailscale backs up customer metadata in the coordination server hourly and tests backups at least annually.

### Does Tailscale conduct security audits?

Yes. We work with Latacora to conduct regular security audits. These include traditional assessments, but also monitoring, maturity model review, design review and advisory services. On top of that, we also have peer code reviews, automated static analysis checks, and dependency vulnerability scans.

### What infrastructure does Tailscale use?

Tailscale's infrastructure includes the following:

-   A client, run on each of a user's devices. This is available for [many platforms including macOS, Windows, Linux, iOS, and Android](https://tailscale.com/download).
-   A coordination server, which distributes public keys and controls settings for the service. Tailscale's control plane runs on Linux servers in Amazon Web Service (AWS), in AWS Virtual Private Clouds (VPCs). [Coordination server data is stored in SQLite](https://tailscale.com/blog/database-for-2022/) and backed up to AWS S3, with analytics stored in Snowflake.
-   [Designated Encrypted Relay for Packets (DERP) relay servers](https://tailscale.com/kb/1118/custom-derp-servers/#what-are-derp-servers), which help clients establish end-to-end encrypted connections where they have trouble connecting directly. Tailscale's DERP relay servers run on Linux servers in multiple regions on multiple infrastructure providers. Learn more about [How Tailscale works](https://tailscale.com/blog/how-tailscale-works/).

### Is Tailscale's infrastructure multi-tenant?

Yes. Tailscale's coordination server, which distributes public keys and controls settings, is multi-tenant. This only stores customer metadata and public keys, not data or private keys.

Tailscale's DERP relay servers, which help establish point-to-point connections, are multi-tenant. These only route encrypted customer data, never unencrypted data.

### What data does Tailscale collect?

In order to provide the service, Tailscale collects device information, including OS, hardware, public IP addresses, network routing information, information on the installed Tailscale client, and other device settings. Tailscale also uses user account information, such as email addresses, to authenticate users to their accounts.

See our [Privacy Policy](https://tailscale.com/privacy-policy/#collect) for more details on how we collect and use personal information.

### Does Tailscale have a DPA? Who are your subprocessors?

Yes. Tailscale provides a [Data Privacy Addendum](https://tailscale.com/dpa) to all customers, and publishes a [list of subprocessors](https://tailscale.com/dpa-subprocessors).

### Can I opt out of logging?

Tailscale collects customer metadata related to connection attempts, authentication, and routing to help us to monitor and debug networks.

If you opt out of logging, Tailscale may not be able to provide technical support. To learn how to opt out, see [Opting out of client logging](https://tailscale.com/kb/1011/log-mesh-traffic/#opting-out-of-client-logging).

You cannot limit coordination server logs.

### Is Tailscale SOC 2 compliant?

Yes. Tailscale has completed a [SOC 2](https://us.aicpa.org/interestareas/frc/assuranceadvisoryservices/serviceorganization-smanagement) Type II audit covering AICPA's Trust Services Criteria for security, availability, and confidentiality. Obtain a copy of the report from our [compliance page](https://tailscale.com/compliance). Note that the report is confidential, and prospective customers will need to [contact support](https://tailscale.com/contact/support) and sign an NDA to access the report.

### Is Tailscale HIPAA compliant?

HIPAA defines controls for securing health information.

As Tailscale does not store customer data, only metadata, Tailscale doesn't have any services in scope for HIPAA. US-based healthcare customers do not need and Tailscale does not execute business associate agreements (BAAs) with our US-based healthcare clients.

Tailscale can be a supporting safeguard for your HIPAA-compliant system to provide integrity and encryption for electronic protected health information transmitted over an electronic communications network (HIPAA 45 CFR § 164.312(e)(1)).

### Is Tailscale PCI compliant?

PCI DSS 4.0 defines controls for securing credit card information and requires eligible merchants to complete the [SAQ A](https://docs-prv.pcisecuritystandards.org/SAQ%20\(Assessment\)/SAQ/PCI-DSS-v4-0-SAQ-A-r2.pdf) form to demonstrate compliance.

Tailscale does not store credit card information, and instead uses [Stripe](https://stripe.com/) to securely process transactions. [Stripe is certified to PCI DSS Service Provider Level 1](https://stripe.com/docs/security/stripe), which is the highest level of security certification available in the payments industry.

As Tailscale does not directly store or process credit card information**,** Tailscale doesn't have any services in scope for PCI DSS. However, under the PCI DSS 4.0 requirements, Tailscale has completed the [SAQ A](https://cdn.sanity.io/files/w77i7m8x/production/cf639662e5a5445fc6919c75d434cf8fa462dbad.pdf) form to ensure that our service provider, Stripe, is PCI-compliant and contractually obligated to handle all PCI obligations.

## Have a security concern about Tailscale?

Get in touch with our security team at [security@tailscale.com](mailto:security@tailscale.com) to disclose any security vulnerabilities.

Upon discovering a vulnerability, we ask that you act in a way to protect our users' information:

-   Inform us as soon as possible.
-   Test against fake data and accounts, not our users' information.
-   Work with us to close the vulnerability before disclosing it to others.

Tailscale does not have a bounty program.
```



### File: support.md

```markdown
# Quality support, whenever you need it

## Search the Knowledgebase

[

## Tailscale status

Check status of Tailscale services.

](https://status.tailscale.com/)[

## Connect on social channels

Reach out to the Tailscale community for help and advice.

](https://tailscale.com/contact/support#socials)[

## Submit a support request

Contact Tailscale's Support Team.

](https://tailscale.com/contact/support#support-form)

## Socials

You can also reach out to our community.

[![x logo](https://cdn.sanity.io/images/w77i7m8x/production/e20d37072cb9c9de232ff54a98789e983f6f0955-28x24.svg?w=64&q=75&fit=clip&auto=format)

On X, by tagging
@Tailscale

](https://twitter.com/tailscale)[![reddit logo](https://cdn.sanity.io/images/w77i7m8x/production/ffa42f08dc26972c65eceeddda7db076ae01286b-35x29.svg?w=96&q=75&fit=clip&auto=format)

On Reddit, in
r/Tailscale

](https://www.reddit.com/r/Tailscale/)[![stackoverflow logo](https://cdn.sanity.io/images/w77i7m8x/production/62df953ea01933430d60c3d2259ce6130c446831-34x39.svg?w=96&q=75&fit=clip&auto=format)

On Stack Overflow, with the tag tailscale

](https://stackoverflow.com/questions/tagged/tailscale)[![mastodon logo](https://cdn.sanity.io/images/w77i7m8x/production/a3f2336964a4ecbbd53c18ee067ddf6e39ca0a32-35x36.svg?w=96&q=75&fit=clip&auto=format)

On Mastodon, by tagging @tailscale@hachyderm.io

](https://hachyderm.io/@tailscale)[![Github](https://cdn.sanity.io/images/w77i7m8x/production/16e66caf8b6fff6da1c1b82b79d5c8678d393486-32x32.svg?w=64&q=75&fit=clip&auto=format)

On Github, at tailscale

](https://github.com/tailscale/tailscale/issues)[![bluesky logo](https://cdn.sanity.io/images/w77i7m8x/production/884de9169ee44438a5653e1ff81015c7af1b9a83-32x29.png?w=64&q=75&fit=clip&auto=format)

On Bluesky, by tagging
@tailscale.com

](https://bsky.app/profile/tailscale.com)

## Still need help?

Contact us via the form below.
```
